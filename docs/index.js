var __create = Object.create;
var __getProtoOf = Object.getPrototypeOf;
var __defProp = Object.defineProperty;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);

// node_modules/react/cjs/react.development.js
var require_react_development = __commonJS((exports, module) => {
  if (true) {
    (function() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error);
      }
      var ReactVersion = "18.3.1";
      var REACT_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }
        return null;
      }
      var ReactCurrentDispatcher = {
        current: null
      };
      var ReactCurrentBatchConfig = {
        transition: null
      };
      var ReactCurrentActQueue = {
        current: null,
        isBatchingLegacy: false,
        didScheduleLegacyUpdate: false
      };
      var ReactCurrentOwner = {
        current: null
      };
      var ReactDebugCurrentFrame = {};
      var currentExtraStackFrame = null;
      function setExtraStackFrame(stack) {
        {
          currentExtraStackFrame = stack;
        }
      }
      {
        ReactDebugCurrentFrame.setExtraStackFrame = function(stack) {
          {
            currentExtraStackFrame = stack;
          }
        };
        ReactDebugCurrentFrame.getCurrentStack = null;
        ReactDebugCurrentFrame.getStackAddendum = function() {
          var stack = "";
          if (currentExtraStackFrame) {
            stack += currentExtraStackFrame;
          }
          var impl = ReactDebugCurrentFrame.getCurrentStack;
          if (impl) {
            stack += impl() || "";
          }
          return stack;
        };
      }
      var enableScopeAPI = false;
      var enableCacheElement = false;
      var enableTransitionTracing = false;
      var enableLegacyHidden = false;
      var enableDebugTracing = false;
      var ReactSharedInternals = {
        ReactCurrentDispatcher,
        ReactCurrentBatchConfig,
        ReactCurrentOwner
      };
      {
        ReactSharedInternals.ReactDebugCurrentFrame = ReactDebugCurrentFrame;
        ReactSharedInternals.ReactCurrentActQueue = ReactCurrentActQueue;
      }
      function warn(format) {
        {
          {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format, args);
          }
        }
      }
      function error(format) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1;_key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame2.getStackAddendum();
          if (stack !== "") {
            format += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      var didWarnStateUpdateForUnmountedComponent = {};
      function warnNoop(publicInstance, callerName) {
        {
          var _constructor = publicInstance.constructor;
          var componentName = _constructor && (_constructor.displayName || _constructor.name) || "ReactClass";
          var warningKey = componentName + "." + callerName;
          if (didWarnStateUpdateForUnmountedComponent[warningKey]) {
            return;
          }
          error("Can't call %s on a component that is not yet mounted. " + "This is a no-op, but it might indicate a bug in your application. " + "Instead, assign to `this.state` directly or define a `state = {};` " + "class property with the desired state in the %s component.", callerName, componentName);
          didWarnStateUpdateForUnmountedComponent[warningKey] = true;
        }
      }
      var ReactNoopUpdateQueue = {
        isMounted: function(publicInstance) {
          return false;
        },
        enqueueForceUpdate: function(publicInstance, callback, callerName) {
          warnNoop(publicInstance, "forceUpdate");
        },
        enqueueReplaceState: function(publicInstance, completeState, callback, callerName) {
          warnNoop(publicInstance, "replaceState");
        },
        enqueueSetState: function(publicInstance, partialState, callback, callerName) {
          warnNoop(publicInstance, "setState");
        }
      };
      var assign = Object.assign;
      var emptyObject = {};
      {
        Object.freeze(emptyObject);
      }
      function Component(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      Component.prototype.isReactComponent = {};
      Component.prototype.setState = function(partialState, callback) {
        if (typeof partialState !== "object" && typeof partialState !== "function" && partialState != null) {
          throw new Error("setState(...): takes an object of state variables to update or a " + "function which returns an object of state variables.");
        }
        this.updater.enqueueSetState(this, partialState, callback, "setState");
      };
      Component.prototype.forceUpdate = function(callback) {
        this.updater.enqueueForceUpdate(this, callback, "forceUpdate");
      };
      {
        var deprecatedAPIs = {
          isMounted: ["isMounted", "Instead, make sure to clean up subscriptions and pending requests in " + "componentWillUnmount to prevent memory leaks."],
          replaceState: ["replaceState", "Refactor your code to use setState instead (see " + "https://github.com/facebook/react/issues/3236)."]
        };
        var defineDeprecationWarning = function(methodName, info) {
          Object.defineProperty(Component.prototype, methodName, {
            get: function() {
              warn("%s(...) is deprecated in plain JavaScript React classes. %s", info[0], info[1]);
              return;
            }
          });
        };
        for (var fnName in deprecatedAPIs) {
          if (deprecatedAPIs.hasOwnProperty(fnName)) {
            defineDeprecationWarning(fnName, deprecatedAPIs[fnName]);
          }
        }
      }
      function ComponentDummy() {}
      ComponentDummy.prototype = Component.prototype;
      function PureComponent(props, context, updater) {
        this.props = props;
        this.context = context;
        this.refs = emptyObject;
        this.updater = updater || ReactNoopUpdateQueue;
      }
      var pureComponentPrototype = PureComponent.prototype = new ComponentDummy;
      pureComponentPrototype.constructor = PureComponent;
      assign(pureComponentPrototype, Component.prototype);
      pureComponentPrototype.isPureReactComponent = true;
      function createRef() {
        var refObject = {
          current: null
        };
        {
          Object.seal(refObject);
        }
        return refObject;
      }
      var isArrayImpl = Array.isArray;
      function isArray(a) {
        return isArrayImpl(a);
      }
      function typeName(value) {
        {
          var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
          var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          return type;
        }
      }
      function willCoercionThrow(value) {
        {
          try {
            testStringCoercion(value);
            return false;
          } catch (e) {
            return true;
          }
        }
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkKeyStringCoercion(value) {
        {
          if (willCoercionThrow(value)) {
            error("The provided key is an unsupported type %s." + " This value must be coerced to a string before before using it here.", typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName) {
          return displayName;
        }
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromType(type) {
        if (type == null) {
          return null;
        }
        {
          if (typeof type.tag === "number") {
            error("Received an unexpected object in getComponentNameFromType(). " + "This is likely a bug in React. Please file an issue.");
          }
        }
        if (typeof type === "function") {
          return type.displayName || type.name || null;
        }
        if (typeof type === "string") {
          return type;
        }
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type.displayName || null;
              if (outerName !== null) {
                return outerName;
              }
              return getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return getComponentNameFromType(init(payload));
              } catch (x) {
                return null;
              }
            }
          }
        }
        return null;
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var RESERVED_PROPS = {
        key: true,
        ref: true,
        __self: true,
        __source: true
      };
      var specialPropKeyWarningShown, specialPropRefWarningShown, didWarnAboutStringRefs;
      {
        didWarnAboutStringRefs = {};
      }
      function hasValidRef(config) {
        {
          if (hasOwnProperty.call(config, "ref")) {
            var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.ref !== undefined;
      }
      function hasValidKey(config) {
        {
          if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.key !== undefined;
      }
      function defineKeyPropWarningGetter(props, displayName) {
        var warnAboutAccessingKey = function() {
          {
            if (!specialPropKeyWarningShown) {
              specialPropKeyWarningShown = true;
              error("%s: `key` is not a prop. Trying to access it will result " + "in `undefined` being returned. If you need to access the same " + "value within the child component, you should pass it as a different " + "prop. (https://reactjs.org/link/special-props)", displayName);
            }
          }
        };
        warnAboutAccessingKey.isReactWarning = true;
        Object.defineProperty(props, "key", {
          get: warnAboutAccessingKey,
          configurable: true
        });
      }
      function defineRefPropWarningGetter(props, displayName) {
        var warnAboutAccessingRef = function() {
          {
            if (!specialPropRefWarningShown) {
              specialPropRefWarningShown = true;
              error("%s: `ref` is not a prop. Trying to access it will result " + "in `undefined` being returned. If you need to access the same " + "value within the child component, you should pass it as a different " + "prop. (https://reactjs.org/link/special-props)", displayName);
            }
          }
        };
        warnAboutAccessingRef.isReactWarning = true;
        Object.defineProperty(props, "ref", {
          get: warnAboutAccessingRef,
          configurable: true
        });
      }
      function warnIfStringRefCannotBeAutoConverted(config) {
        {
          if (typeof config.ref === "string" && ReactCurrentOwner.current && config.__self && ReactCurrentOwner.current.stateNode !== config.__self) {
            var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
            if (!didWarnAboutStringRefs[componentName]) {
              error('Component "%s" contains the string ref "%s". ' + "Support for string refs will be removed in a future major release. " + "This case cannot be automatically converted to an arrow function. " + "We ask you to manually fix this case by using useRef() or createRef() instead. " + "Learn more about using refs safely here: " + "https://reactjs.org/link/strict-mode-string-ref", componentName, config.ref);
              didWarnAboutStringRefs[componentName] = true;
            }
          }
        }
      }
      var ReactElement = function(type, key, ref, self, source, owner, props) {
        var element = {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          ref,
          props,
          _owner: owner
        };
        {
          element._store = {};
          Object.defineProperty(element._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false
          });
          Object.defineProperty(element, "_self", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: self
          });
          Object.defineProperty(element, "_source", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: source
          });
          if (Object.freeze) {
            Object.freeze(element.props);
            Object.freeze(element);
          }
        }
        return element;
      };
      function createElement(type, config, children) {
        var propName;
        var props = {};
        var key = null;
        var ref = null;
        var self = null;
        var source = null;
        if (config != null) {
          if (hasValidRef(config)) {
            ref = config.ref;
            {
              warnIfStringRefCannotBeAutoConverted(config);
            }
          }
          if (hasValidKey(config)) {
            {
              checkKeyStringCoercion(config.key);
            }
            key = "" + config.key;
          }
          self = config.__self === undefined ? null : config.__self;
          source = config.__source === undefined ? null : config.__source;
          for (propName in config) {
            if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
              props[propName] = config[propName];
            }
          }
        }
        var childrenLength = arguments.length - 2;
        if (childrenLength === 1) {
          props.children = children;
        } else if (childrenLength > 1) {
          var childArray = Array(childrenLength);
          for (var i = 0;i < childrenLength; i++) {
            childArray[i] = arguments[i + 2];
          }
          {
            if (Object.freeze) {
              Object.freeze(childArray);
            }
          }
          props.children = childArray;
        }
        if (type && type.defaultProps) {
          var defaultProps = type.defaultProps;
          for (propName in defaultProps) {
            if (props[propName] === undefined) {
              props[propName] = defaultProps[propName];
            }
          }
        }
        {
          if (key || ref) {
            var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
            if (key) {
              defineKeyPropWarningGetter(props, displayName);
            }
            if (ref) {
              defineRefPropWarningGetter(props, displayName);
            }
          }
        }
        return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
      }
      function cloneAndReplaceKey(oldElement, newKey) {
        var newElement = ReactElement(oldElement.type, newKey, oldElement.ref, oldElement._self, oldElement._source, oldElement._owner, oldElement.props);
        return newElement;
      }
      function cloneElement(element, config, children) {
        if (element === null || element === undefined) {
          throw new Error("React.cloneElement(...): The argument must be a React element, but you passed " + element + ".");
        }
        var propName;
        var props = assign({}, element.props);
        var key = element.key;
        var ref = element.ref;
        var self = element._self;
        var source = element._source;
        var owner = element._owner;
        if (config != null) {
          if (hasValidRef(config)) {
            ref = config.ref;
            owner = ReactCurrentOwner.current;
          }
          if (hasValidKey(config)) {
            {
              checkKeyStringCoercion(config.key);
            }
            key = "" + config.key;
          }
          var defaultProps;
          if (element.type && element.type.defaultProps) {
            defaultProps = element.type.defaultProps;
          }
          for (propName in config) {
            if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
              if (config[propName] === undefined && defaultProps !== undefined) {
                props[propName] = defaultProps[propName];
              } else {
                props[propName] = config[propName];
              }
            }
          }
        }
        var childrenLength = arguments.length - 2;
        if (childrenLength === 1) {
          props.children = children;
        } else if (childrenLength > 1) {
          var childArray = Array(childrenLength);
          for (var i = 0;i < childrenLength; i++) {
            childArray[i] = arguments[i + 2];
          }
          props.children = childArray;
        }
        return ReactElement(element.type, key, ref, self, source, owner, props);
      }
      function isValidElement(object) {
        return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
      }
      var SEPARATOR = ".";
      var SUBSEPARATOR = ":";
      function escape(key) {
        var escapeRegex = /[=:]/g;
        var escaperLookup = {
          "=": "=0",
          ":": "=2"
        };
        var escapedString = key.replace(escapeRegex, function(match) {
          return escaperLookup[match];
        });
        return "$" + escapedString;
      }
      var didWarnAboutMaps = false;
      var userProvidedKeyEscapeRegex = /\/+/g;
      function escapeUserProvidedKey(text) {
        return text.replace(userProvidedKeyEscapeRegex, "$&/");
      }
      function getElementKey(element, index) {
        if (typeof element === "object" && element !== null && element.key != null) {
          {
            checkKeyStringCoercion(element.key);
          }
          return escape("" + element.key);
        }
        return index.toString(36);
      }
      function mapIntoArray(children, array, escapedPrefix, nameSoFar, callback) {
        var type = typeof children;
        if (type === "undefined" || type === "boolean") {
          children = null;
        }
        var invokeCallback = false;
        if (children === null) {
          invokeCallback = true;
        } else {
          switch (type) {
            case "string":
            case "number":
              invokeCallback = true;
              break;
            case "object":
              switch (children.$$typeof) {
                case REACT_ELEMENT_TYPE:
                case REACT_PORTAL_TYPE:
                  invokeCallback = true;
              }
          }
        }
        if (invokeCallback) {
          var _child = children;
          var mappedChild = callback(_child);
          var childKey = nameSoFar === "" ? SEPARATOR + getElementKey(_child, 0) : nameSoFar;
          if (isArray(mappedChild)) {
            var escapedChildKey = "";
            if (childKey != null) {
              escapedChildKey = escapeUserProvidedKey(childKey) + "/";
            }
            mapIntoArray(mappedChild, array, escapedChildKey, "", function(c) {
              return c;
            });
          } else if (mappedChild != null) {
            if (isValidElement(mappedChild)) {
              {
                if (mappedChild.key && (!_child || _child.key !== mappedChild.key)) {
                  checkKeyStringCoercion(mappedChild.key);
                }
              }
              mappedChild = cloneAndReplaceKey(mappedChild, escapedPrefix + (mappedChild.key && (!_child || _child.key !== mappedChild.key) ? escapeUserProvidedKey("" + mappedChild.key) + "/" : "") + childKey);
            }
            array.push(mappedChild);
          }
          return 1;
        }
        var child;
        var nextName;
        var subtreeCount = 0;
        var nextNamePrefix = nameSoFar === "" ? SEPARATOR : nameSoFar + SUBSEPARATOR;
        if (isArray(children)) {
          for (var i = 0;i < children.length; i++) {
            child = children[i];
            nextName = nextNamePrefix + getElementKey(child, i);
            subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
          }
        } else {
          var iteratorFn = getIteratorFn(children);
          if (typeof iteratorFn === "function") {
            var iterableChildren = children;
            {
              if (iteratorFn === iterableChildren.entries) {
                if (!didWarnAboutMaps) {
                  warn("Using Maps as children is not supported. " + "Use an array of keyed ReactElements instead.");
                }
                didWarnAboutMaps = true;
              }
            }
            var iterator = iteratorFn.call(iterableChildren);
            var step;
            var ii = 0;
            while (!(step = iterator.next()).done) {
              child = step.value;
              nextName = nextNamePrefix + getElementKey(child, ii++);
              subtreeCount += mapIntoArray(child, array, escapedPrefix, nextName, callback);
            }
          } else if (type === "object") {
            var childrenString = String(children);
            throw new Error("Objects are not valid as a React child (found: " + (childrenString === "[object Object]" ? "object with keys {" + Object.keys(children).join(", ") + "}" : childrenString) + "). " + "If you meant to render a collection of children, use an array " + "instead.");
          }
        }
        return subtreeCount;
      }
      function mapChildren(children, func, context) {
        if (children == null) {
          return children;
        }
        var result = [];
        var count = 0;
        mapIntoArray(children, result, "", "", function(child) {
          return func.call(context, child, count++);
        });
        return result;
      }
      function countChildren(children) {
        var n = 0;
        mapChildren(children, function() {
          n++;
        });
        return n;
      }
      function forEachChildren(children, forEachFunc, forEachContext) {
        mapChildren(children, function() {
          forEachFunc.apply(this, arguments);
        }, forEachContext);
      }
      function toArray(children) {
        return mapChildren(children, function(child) {
          return child;
        }) || [];
      }
      function onlyChild(children) {
        if (!isValidElement(children)) {
          throw new Error("React.Children.only expected to receive a single React element child.");
        }
        return children;
      }
      function createContext(defaultValue) {
        var context = {
          $$typeof: REACT_CONTEXT_TYPE,
          _currentValue: defaultValue,
          _currentValue2: defaultValue,
          _threadCount: 0,
          Provider: null,
          Consumer: null,
          _defaultValue: null,
          _globalName: null
        };
        context.Provider = {
          $$typeof: REACT_PROVIDER_TYPE,
          _context: context
        };
        var hasWarnedAboutUsingNestedContextConsumers = false;
        var hasWarnedAboutUsingConsumerProvider = false;
        var hasWarnedAboutDisplayNameOnConsumer = false;
        {
          var Consumer = {
            $$typeof: REACT_CONTEXT_TYPE,
            _context: context
          };
          Object.defineProperties(Consumer, {
            Provider: {
              get: function() {
                if (!hasWarnedAboutUsingConsumerProvider) {
                  hasWarnedAboutUsingConsumerProvider = true;
                  error("Rendering <Context.Consumer.Provider> is not supported and will be removed in " + "a future major release. Did you mean to render <Context.Provider> instead?");
                }
                return context.Provider;
              },
              set: function(_Provider) {
                context.Provider = _Provider;
              }
            },
            _currentValue: {
              get: function() {
                return context._currentValue;
              },
              set: function(_currentValue) {
                context._currentValue = _currentValue;
              }
            },
            _currentValue2: {
              get: function() {
                return context._currentValue2;
              },
              set: function(_currentValue2) {
                context._currentValue2 = _currentValue2;
              }
            },
            _threadCount: {
              get: function() {
                return context._threadCount;
              },
              set: function(_threadCount) {
                context._threadCount = _threadCount;
              }
            },
            Consumer: {
              get: function() {
                if (!hasWarnedAboutUsingNestedContextConsumers) {
                  hasWarnedAboutUsingNestedContextConsumers = true;
                  error("Rendering <Context.Consumer.Consumer> is not supported and will be removed in " + "a future major release. Did you mean to render <Context.Consumer> instead?");
                }
                return context.Consumer;
              }
            },
            displayName: {
              get: function() {
                return context.displayName;
              },
              set: function(displayName) {
                if (!hasWarnedAboutDisplayNameOnConsumer) {
                  warn("Setting `displayName` on Context.Consumer has no effect. " + "You should set it directly on the context with Context.displayName = '%s'.", displayName);
                  hasWarnedAboutDisplayNameOnConsumer = true;
                }
              }
            }
          });
          context.Consumer = Consumer;
        }
        {
          context._currentRenderer = null;
          context._currentRenderer2 = null;
        }
        return context;
      }
      var Uninitialized = -1;
      var Pending = 0;
      var Resolved = 1;
      var Rejected = 2;
      function lazyInitializer(payload) {
        if (payload._status === Uninitialized) {
          var ctor = payload._result;
          var thenable = ctor();
          thenable.then(function(moduleObject2) {
            if (payload._status === Pending || payload._status === Uninitialized) {
              var resolved = payload;
              resolved._status = Resolved;
              resolved._result = moduleObject2;
            }
          }, function(error2) {
            if (payload._status === Pending || payload._status === Uninitialized) {
              var rejected = payload;
              rejected._status = Rejected;
              rejected._result = error2;
            }
          });
          if (payload._status === Uninitialized) {
            var pending = payload;
            pending._status = Pending;
            pending._result = thenable;
          }
        }
        if (payload._status === Resolved) {
          var moduleObject = payload._result;
          {
            if (moduleObject === undefined) {
              error("lazy: Expected the result of a dynamic imp" + "ort() call. " + `Instead received: %s

Your code should look like: 
  ` + "const MyComponent = lazy(() => imp" + `ort('./MyComponent'))

` + "Did you accidentally put curly braces around the import?", moduleObject);
            }
          }
          {
            if (!("default" in moduleObject)) {
              error("lazy: Expected the result of a dynamic imp" + "ort() call. " + `Instead received: %s

Your code should look like: 
  ` + "const MyComponent = lazy(() => imp" + "ort('./MyComponent'))", moduleObject);
            }
          }
          return moduleObject.default;
        } else {
          throw payload._result;
        }
      }
      function lazy(ctor) {
        var payload = {
          _status: Uninitialized,
          _result: ctor
        };
        var lazyType = {
          $$typeof: REACT_LAZY_TYPE,
          _payload: payload,
          _init: lazyInitializer
        };
        {
          var defaultProps;
          var propTypes;
          Object.defineProperties(lazyType, {
            defaultProps: {
              configurable: true,
              get: function() {
                return defaultProps;
              },
              set: function(newDefaultProps) {
                error("React.lazy(...): It is not supported to assign `defaultProps` to " + "a lazy component import. Either specify them where the component " + "is defined, or create a wrapping component around it.");
                defaultProps = newDefaultProps;
                Object.defineProperty(lazyType, "defaultProps", {
                  enumerable: true
                });
              }
            },
            propTypes: {
              configurable: true,
              get: function() {
                return propTypes;
              },
              set: function(newPropTypes) {
                error("React.lazy(...): It is not supported to assign `propTypes` to " + "a lazy component import. Either specify them where the component " + "is defined, or create a wrapping component around it.");
                propTypes = newPropTypes;
                Object.defineProperty(lazyType, "propTypes", {
                  enumerable: true
                });
              }
            }
          });
        }
        return lazyType;
      }
      function forwardRef(render) {
        {
          if (render != null && render.$$typeof === REACT_MEMO_TYPE) {
            error("forwardRef requires a render function but received a `memo` " + "component. Instead of forwardRef(memo(...)), use " + "memo(forwardRef(...)).");
          } else if (typeof render !== "function") {
            error("forwardRef requires a render function but was given %s.", render === null ? "null" : typeof render);
          } else {
            if (render.length !== 0 && render.length !== 2) {
              error("forwardRef render functions accept exactly two parameters: props and ref. %s", render.length === 1 ? "Did you forget to use the ref parameter?" : "Any additional parameter will be undefined.");
            }
          }
          if (render != null) {
            if (render.defaultProps != null || render.propTypes != null) {
              error("forwardRef render functions do not support propTypes or defaultProps. " + "Did you accidentally pass a React component?");
            }
          }
        }
        var elementType = {
          $$typeof: REACT_FORWARD_REF_TYPE,
          render
        };
        {
          var ownName;
          Object.defineProperty(elementType, "displayName", {
            enumerable: false,
            configurable: true,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name;
              if (!render.name && !render.displayName) {
                render.displayName = name;
              }
            }
          });
        }
        return elementType;
      }
      var REACT_MODULE_REFERENCE;
      {
        REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
      }
      function isValidElementType(type) {
        if (typeof type === "string" || typeof type === "function") {
          return true;
        }
        if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
          return true;
        }
        if (typeof type === "object" && type !== null) {
          if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
            return true;
          }
        }
        return false;
      }
      function memo(type, compare) {
        {
          if (!isValidElementType(type)) {
            error("memo: The first argument must be a component. Instead " + "received: %s", type === null ? "null" : typeof type);
          }
        }
        var elementType = {
          $$typeof: REACT_MEMO_TYPE,
          type,
          compare: compare === undefined ? null : compare
        };
        {
          var ownName;
          Object.defineProperty(elementType, "displayName", {
            enumerable: false,
            configurable: true,
            get: function() {
              return ownName;
            },
            set: function(name) {
              ownName = name;
              if (!type.name && !type.displayName) {
                type.displayName = name;
              }
            }
          });
        }
        return elementType;
      }
      function resolveDispatcher() {
        var dispatcher = ReactCurrentDispatcher.current;
        {
          if (dispatcher === null) {
            error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for" + ` one of the following reasons:
` + `1. You might have mismatching versions of React and the renderer (such as React DOM)
` + `2. You might be breaking the Rules of Hooks
` + `3. You might have more than one copy of React in the same app
` + "See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
          }
        }
        return dispatcher;
      }
      function useContext(Context) {
        var dispatcher = resolveDispatcher();
        {
          if (Context._context !== undefined) {
            var realContext = Context._context;
            if (realContext.Consumer === Context) {
              error("Calling useContext(Context.Consumer) is not supported, may cause bugs, and will be " + "removed in a future major release. Did you mean to call useContext(Context) instead?");
            } else if (realContext.Provider === Context) {
              error("Calling useContext(Context.Provider) is not supported. " + "Did you mean to call useContext(Context) instead?");
            }
          }
        }
        return dispatcher.useContext(Context);
      }
      function useState(initialState) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useState(initialState);
      }
      function useReducer(reducer, initialArg, init) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useReducer(reducer, initialArg, init);
      }
      function useRef(initialValue) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useRef(initialValue);
      }
      function useEffect(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useEffect(create, deps);
      }
      function useInsertionEffect(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useInsertionEffect(create, deps);
      }
      function useLayoutEffect(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useLayoutEffect(create, deps);
      }
      function useCallback(callback, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useCallback(callback, deps);
      }
      function useMemo(create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useMemo(create, deps);
      }
      function useImperativeHandle(ref, create, deps) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useImperativeHandle(ref, create, deps);
      }
      function useDebugValue(value, formatterFn) {
        {
          var dispatcher = resolveDispatcher();
          return dispatcher.useDebugValue(value, formatterFn);
        }
      }
      function useTransition() {
        var dispatcher = resolveDispatcher();
        return dispatcher.useTransition();
      }
      function useDeferredValue(value) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useDeferredValue(value);
      }
      function useId() {
        var dispatcher = resolveDispatcher();
        return dispatcher.useId();
      }
      function useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        var dispatcher = resolveDispatcher();
        return dispatcher.useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
      }
      var disabledDepth = 0;
      var prevLog;
      var prevInfo;
      var prevWarn;
      var prevError;
      var prevGroup;
      var prevGroupCollapsed;
      var prevGroupEnd;
      function disabledLog() {}
      disabledLog.__reactDisabledLog = true;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          disabledDepth--;
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          if (disabledDepth < 0) {
            error("disabledDepth fell below zero. " + "This is a bug in React. Please file an issue.");
          }
        }
      }
      var ReactCurrentDispatcher$1 = ReactSharedInternals.ReactCurrentDispatcher;
      var prefix;
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix === undefined) {
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          }
          return `
` + prefix + name;
        }
      }
      var reentry = false;
      var componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap;
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) {
          return "";
        }
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== undefined) {
            return frame;
          }
        }
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = undefined;
        var previousDispatcher;
        {
          previousDispatcher = ReactCurrentDispatcher$1.current;
          ReactCurrentDispatcher$1.current = null;
          disableLogs();
        }
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === "string") {
            var sampleLines = sample.stack.split(`
`);
            var controlLines = control.stack.split(`
`);
            var s = sampleLines.length - 1;
            var c = controlLines.length - 1;
            while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
              c--;
            }
            for (;s >= 1 && c >= 0; s--, c--) {
              if (sampleLines[s] !== controlLines[c]) {
                if (s !== 1 || c !== 1) {
                  do {
                    s--;
                    c--;
                    if (c < 0 || sampleLines[s] !== controlLines[c]) {
                      var _frame = `
` + sampleLines[s].replace(" at new ", " at ");
                      if (fn.displayName && _frame.includes("<anonymous>")) {
                        _frame = _frame.replace("<anonymous>", fn.displayName);
                      }
                      {
                        if (typeof fn === "function") {
                          componentFrameCache.set(fn, _frame);
                        }
                      }
                      return _frame;
                    }
                  } while (s >= 1 && c >= 0);
                }
                break;
              }
            }
          }
        } finally {
          reentry = false;
          {
            ReactCurrentDispatcher$1.current = previousDispatcher;
            reenableLogs();
          }
          Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "";
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        {
          if (typeof fn === "function") {
            componentFrameCache.set(fn, syntheticFrame);
          }
        }
        return syntheticFrame;
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        {
          return describeNativeComponentFrame(fn, false);
        }
      }
      function shouldConstruct(Component2) {
        var prototype = Component2.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) {
          return "";
        }
        if (typeof type === "function") {
          {
            return describeNativeComponentFrame(type, shouldConstruct(type));
          }
        }
        if (typeof type === "string") {
          return describeBuiltInComponentFrame(type);
        }
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
              } catch (x) {}
            }
          }
        }
        return "";
      }
      var loggedTypeFailures = {};
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame$1.setExtraStackFrame(null);
          }
        }
      }
      function checkPropTypes(typeSpecs, values, location2, componentName, element) {
        {
          var has = Function.call.bind(hasOwnProperty);
          for (var typeSpecName in typeSpecs) {
            if (has(typeSpecs, typeSpecName)) {
              var error$1 = undefined;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; " + "it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`." + "This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  err.name = "Invariant Violation";
                  throw err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error("%s: type specification of %s" + " `%s` is invalid; the type checker " + "function must return `null` or an `Error` but returned a %s. " + "You may have forgotten to pass an argument to the type checker " + "creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and " + "shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
              }
              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error("Failed %s type: %s", location2, error$1.message);
                setCurrentlyValidatingElement(null);
              }
            }
          }
        }
      }
      function setCurrentlyValidatingElement$1(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            setExtraStackFrame(stack);
          } else {
            setExtraStackFrame(null);
          }
        }
      }
      var propTypesMisspellWarningShown;
      {
        propTypesMisspellWarningShown = false;
      }
      function getDeclarationErrorAddendum() {
        if (ReactCurrentOwner.current) {
          var name = getComponentNameFromType(ReactCurrentOwner.current.type);
          if (name) {
            return `

Check the render method of \`` + name + "`.";
          }
        }
        return "";
      }
      function getSourceInfoErrorAddendum(source) {
        if (source !== undefined) {
          var fileName = source.fileName.replace(/^.*[\\\/]/, "");
          var lineNumber = source.lineNumber;
          return `

Check your code at ` + fileName + ":" + lineNumber + ".";
        }
        return "";
      }
      function getSourceInfoErrorAddendumForProps(elementProps) {
        if (elementProps !== null && elementProps !== undefined) {
          return getSourceInfoErrorAddendum(elementProps.__source);
        }
        return "";
      }
      var ownerHasKeyUseWarning = {};
      function getCurrentComponentErrorInfo(parentType) {
        var info = getDeclarationErrorAddendum();
        if (!info) {
          var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
          if (parentName) {
            info = `

Check the top-level render call using <` + parentName + ">.";
          }
        }
        return info;
      }
      function validateExplicitKey(element, parentType) {
        if (!element._store || element._store.validated || element.key != null) {
          return;
        }
        element._store.validated = true;
        var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
        if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
          return;
        }
        ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
        var childOwner = "";
        if (element && element._owner && element._owner !== ReactCurrentOwner.current) {
          childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
        }
        {
          setCurrentlyValidatingElement$1(element);
          error('Each child in a list should have a unique "key" prop.' + "%s%s See https://reactjs.org/link/warning-keys for more information.", currentComponentErrorInfo, childOwner);
          setCurrentlyValidatingElement$1(null);
        }
      }
      function validateChildKeys(node, parentType) {
        if (typeof node !== "object") {
          return;
        }
        if (isArray(node)) {
          for (var i = 0;i < node.length; i++) {
            var child = node[i];
            if (isValidElement(child)) {
              validateExplicitKey(child, parentType);
            }
          }
        } else if (isValidElement(node)) {
          if (node._store) {
            node._store.validated = true;
          }
        } else if (node) {
          var iteratorFn = getIteratorFn(node);
          if (typeof iteratorFn === "function") {
            if (iteratorFn !== node.entries) {
              var iterator = iteratorFn.call(node);
              var step;
              while (!(step = iterator.next()).done) {
                if (isValidElement(step.value)) {
                  validateExplicitKey(step.value, parentType);
                }
              }
            }
          }
        }
      }
      function validatePropTypes(element) {
        {
          var type = element.type;
          if (type === null || type === undefined || typeof type === "string") {
            return;
          }
          var propTypes;
          if (typeof type === "function") {
            propTypes = type.propTypes;
          } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
            propTypes = type.propTypes;
          } else {
            return;
          }
          if (propTypes) {
            var name = getComponentNameFromType(type);
            checkPropTypes(propTypes, element.props, "prop", name, element);
          } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
            propTypesMisspellWarningShown = true;
            var _name = getComponentNameFromType(type);
            error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
          }
          if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
            error("getDefaultProps is only used on classic React.createClass " + "definitions. Use a static property named `defaultProps` instead.");
          }
        }
      }
      function validateFragmentProps(fragment) {
        {
          var keys = Object.keys(fragment.props);
          for (var i = 0;i < keys.length; i++) {
            var key = keys[i];
            if (key !== "children" && key !== "key") {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid prop `%s` supplied to `React.Fragment`. " + "React.Fragment can only have `key` and `children` props.", key);
              setCurrentlyValidatingElement$1(null);
              break;
            }
          }
          if (fragment.ref !== null) {
            setCurrentlyValidatingElement$1(fragment);
            error("Invalid attribute `ref` supplied to `React.Fragment`.");
            setCurrentlyValidatingElement$1(null);
          }
        }
      }
      function createElementWithValidation(type, props, children) {
        var validType = isValidElementType(type);
        if (!validType) {
          var info = "";
          if (type === undefined || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
            info += " You likely forgot to export your component from the file " + "it's defined in, or you might have mixed up default and named imports.";
          }
          var sourceInfo = getSourceInfoErrorAddendumForProps(props);
          if (sourceInfo) {
            info += sourceInfo;
          } else {
            info += getDeclarationErrorAddendum();
          }
          var typeString;
          if (type === null) {
            typeString = "null";
          } else if (isArray(type)) {
            typeString = "array";
          } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
            typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
            info = " Did you accidentally export a JSX literal instead of a component?";
          } else {
            typeString = typeof type;
          }
          {
            error("React.createElement: type is invalid -- expected a string (for " + "built-in components) or a class/function (for composite " + "components) but got: %s.%s", typeString, info);
          }
        }
        var element = createElement.apply(this, arguments);
        if (element == null) {
          return element;
        }
        if (validType) {
          for (var i = 2;i < arguments.length; i++) {
            validateChildKeys(arguments[i], type);
          }
        }
        if (type === REACT_FRAGMENT_TYPE) {
          validateFragmentProps(element);
        } else {
          validatePropTypes(element);
        }
        return element;
      }
      var didWarnAboutDeprecatedCreateFactory = false;
      function createFactoryWithValidation(type) {
        var validatedFactory = createElementWithValidation.bind(null, type);
        validatedFactory.type = type;
        {
          if (!didWarnAboutDeprecatedCreateFactory) {
            didWarnAboutDeprecatedCreateFactory = true;
            warn("React.createFactory() is deprecated and will be removed in " + "a future major release. Consider using JSX " + "or use React.createElement() directly instead.");
          }
          Object.defineProperty(validatedFactory, "type", {
            enumerable: false,
            get: function() {
              warn("Factory.type is deprecated. Access the class directly " + "before passing it to createFactory.");
              Object.defineProperty(this, "type", {
                value: type
              });
              return type;
            }
          });
        }
        return validatedFactory;
      }
      function cloneElementWithValidation(element, props, children) {
        var newElement = cloneElement.apply(this, arguments);
        for (var i = 2;i < arguments.length; i++) {
          validateChildKeys(arguments[i], newElement.type);
        }
        validatePropTypes(newElement);
        return newElement;
      }
      function startTransition(scope, options) {
        var prevTransition = ReactCurrentBatchConfig.transition;
        ReactCurrentBatchConfig.transition = {};
        var currentTransition = ReactCurrentBatchConfig.transition;
        {
          ReactCurrentBatchConfig.transition._updatedFibers = new Set;
        }
        try {
          scope();
        } finally {
          ReactCurrentBatchConfig.transition = prevTransition;
          {
            if (prevTransition === null && currentTransition._updatedFibers) {
              var updatedFibersCount = currentTransition._updatedFibers.size;
              if (updatedFibersCount > 10) {
                warn("Detected a large number of updates inside startTransition. " + "If this is due to a subscription please re-write it to use React provided hooks. " + "Otherwise concurrent mode guarantees are off the table.");
              }
              currentTransition._updatedFibers.clear();
            }
          }
        }
      }
      var didWarnAboutMessageChannel = false;
      var enqueueTaskImpl = null;
      function enqueueTask(task) {
        if (enqueueTaskImpl === null) {
          try {
            var requireString = ("require" + Math.random()).slice(0, 7);
            var nodeRequire = module && module[requireString];
            enqueueTaskImpl = nodeRequire.call(module, "timers").setImmediate;
          } catch (_err) {
            enqueueTaskImpl = function(callback) {
              {
                if (didWarnAboutMessageChannel === false) {
                  didWarnAboutMessageChannel = true;
                  if (typeof MessageChannel === "undefined") {
                    error("This browser does not have a MessageChannel implementation, " + "so enqueuing tasks via await act(async () => ...) will fail. " + "Please file an issue at https://github.com/facebook/react/issues " + "if you encounter this warning.");
                  }
                }
              }
              var channel = new MessageChannel;
              channel.port1.onmessage = callback;
              channel.port2.postMessage(undefined);
            };
          }
        }
        return enqueueTaskImpl(task);
      }
      var actScopeDepth = 0;
      var didWarnNoAwaitAct = false;
      function act(callback) {
        {
          var prevActScopeDepth = actScopeDepth;
          actScopeDepth++;
          if (ReactCurrentActQueue.current === null) {
            ReactCurrentActQueue.current = [];
          }
          var prevIsBatchingLegacy = ReactCurrentActQueue.isBatchingLegacy;
          var result;
          try {
            ReactCurrentActQueue.isBatchingLegacy = true;
            result = callback();
            if (!prevIsBatchingLegacy && ReactCurrentActQueue.didScheduleLegacyUpdate) {
              var queue = ReactCurrentActQueue.current;
              if (queue !== null) {
                ReactCurrentActQueue.didScheduleLegacyUpdate = false;
                flushActQueue(queue);
              }
            }
          } catch (error2) {
            popActScope(prevActScopeDepth);
            throw error2;
          } finally {
            ReactCurrentActQueue.isBatchingLegacy = prevIsBatchingLegacy;
          }
          if (result !== null && typeof result === "object" && typeof result.then === "function") {
            var thenableResult = result;
            var wasAwaited = false;
            var thenable = {
              then: function(resolve, reject) {
                wasAwaited = true;
                thenableResult.then(function(returnValue2) {
                  popActScope(prevActScopeDepth);
                  if (actScopeDepth === 0) {
                    recursivelyFlushAsyncActWork(returnValue2, resolve, reject);
                  } else {
                    resolve(returnValue2);
                  }
                }, function(error2) {
                  popActScope(prevActScopeDepth);
                  reject(error2);
                });
              }
            };
            {
              if (!didWarnNoAwaitAct && typeof Promise !== "undefined") {
                Promise.resolve().then(function() {}).then(function() {
                  if (!wasAwaited) {
                    didWarnNoAwaitAct = true;
                    error("You called act(async () => ...) without await. " + "This could lead to unexpected testing behaviour, " + "interleaving multiple act calls and mixing their " + "scopes. " + "You should - await act(async () => ...);");
                  }
                });
              }
            }
            return thenable;
          } else {
            var returnValue = result;
            popActScope(prevActScopeDepth);
            if (actScopeDepth === 0) {
              var _queue = ReactCurrentActQueue.current;
              if (_queue !== null) {
                flushActQueue(_queue);
                ReactCurrentActQueue.current = null;
              }
              var _thenable = {
                then: function(resolve, reject) {
                  if (ReactCurrentActQueue.current === null) {
                    ReactCurrentActQueue.current = [];
                    recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                  } else {
                    resolve(returnValue);
                  }
                }
              };
              return _thenable;
            } else {
              var _thenable2 = {
                then: function(resolve, reject) {
                  resolve(returnValue);
                }
              };
              return _thenable2;
            }
          }
        }
      }
      function popActScope(prevActScopeDepth) {
        {
          if (prevActScopeDepth !== actScopeDepth - 1) {
            error("You seem to have overlapping act() calls, this is not supported. " + "Be sure to await previous act() calls before making a new one. ");
          }
          actScopeDepth = prevActScopeDepth;
        }
      }
      function recursivelyFlushAsyncActWork(returnValue, resolve, reject) {
        {
          var queue = ReactCurrentActQueue.current;
          if (queue !== null) {
            try {
              flushActQueue(queue);
              enqueueTask(function() {
                if (queue.length === 0) {
                  ReactCurrentActQueue.current = null;
                  resolve(returnValue);
                } else {
                  recursivelyFlushAsyncActWork(returnValue, resolve, reject);
                }
              });
            } catch (error2) {
              reject(error2);
            }
          } else {
            resolve(returnValue);
          }
        }
      }
      var isFlushing = false;
      function flushActQueue(queue) {
        {
          if (!isFlushing) {
            isFlushing = true;
            var i = 0;
            try {
              for (;i < queue.length; i++) {
                var callback = queue[i];
                do {
                  callback = callback(true);
                } while (callback !== null);
              }
              queue.length = 0;
            } catch (error2) {
              queue = queue.slice(i + 1);
              throw error2;
            } finally {
              isFlushing = false;
            }
          }
        }
      }
      var createElement$1 = createElementWithValidation;
      var cloneElement$1 = cloneElementWithValidation;
      var createFactory = createFactoryWithValidation;
      var Children = {
        map: mapChildren,
        forEach: forEachChildren,
        count: countChildren,
        toArray,
        only: onlyChild
      };
      exports.Children = Children;
      exports.Component = Component;
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.Profiler = REACT_PROFILER_TYPE;
      exports.PureComponent = PureComponent;
      exports.StrictMode = REACT_STRICT_MODE_TYPE;
      exports.Suspense = REACT_SUSPENSE_TYPE;
      exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ReactSharedInternals;
      exports.act = act;
      exports.cloneElement = cloneElement$1;
      exports.createContext = createContext;
      exports.createElement = createElement$1;
      exports.createFactory = createFactory;
      exports.createRef = createRef;
      exports.forwardRef = forwardRef;
      exports.isValidElement = isValidElement;
      exports.lazy = lazy;
      exports.memo = memo;
      exports.startTransition = startTransition;
      exports.unstable_act = act;
      exports.useCallback = useCallback;
      exports.useContext = useContext;
      exports.useDebugValue = useDebugValue;
      exports.useDeferredValue = useDeferredValue;
      exports.useEffect = useEffect;
      exports.useId = useId;
      exports.useImperativeHandle = useImperativeHandle;
      exports.useInsertionEffect = useInsertionEffect;
      exports.useLayoutEffect = useLayoutEffect;
      exports.useMemo = useMemo;
      exports.useReducer = useReducer;
      exports.useRef = useRef;
      exports.useState = useState;
      exports.useSyncExternalStore = useSyncExternalStore;
      exports.useTransition = useTransition;
      exports.version = ReactVersion;
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error);
      }
    })();
  }
});

// node_modules/react/index.js
var require_react = __commonJS((exports, module) => {
  var react_development = __toESM(require_react_development());
  if (false) {} else {
    module.exports = react_development;
  }
});

// node_modules/scheduler/cjs/scheduler.development.js
var require_scheduler_development = __commonJS((exports) => {
  if (true) {
    (function() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error);
      }
      var enableSchedulerDebugging = false;
      var enableProfiling = false;
      var frameYieldMs = 5;
      function push(heap, node) {
        var index = heap.length;
        heap.push(node);
        siftUp(heap, node, index);
      }
      function peek(heap) {
        return heap.length === 0 ? null : heap[0];
      }
      function pop(heap) {
        if (heap.length === 0) {
          return null;
        }
        var first = heap[0];
        var last = heap.pop();
        if (last !== first) {
          heap[0] = last;
          siftDown(heap, last, 0);
        }
        return first;
      }
      function siftUp(heap, node, i) {
        var index = i;
        while (index > 0) {
          var parentIndex = index - 1 >>> 1;
          var parent = heap[parentIndex];
          if (compare(parent, node) > 0) {
            heap[parentIndex] = node;
            heap[index] = parent;
            index = parentIndex;
          } else {
            return;
          }
        }
      }
      function siftDown(heap, node, i) {
        var index = i;
        var length = heap.length;
        var halfLength = length >>> 1;
        while (index < halfLength) {
          var leftIndex = (index + 1) * 2 - 1;
          var left = heap[leftIndex];
          var rightIndex = leftIndex + 1;
          var right = heap[rightIndex];
          if (compare(left, node) < 0) {
            if (rightIndex < length && compare(right, left) < 0) {
              heap[index] = right;
              heap[rightIndex] = node;
              index = rightIndex;
            } else {
              heap[index] = left;
              heap[leftIndex] = node;
              index = leftIndex;
            }
          } else if (rightIndex < length && compare(right, node) < 0) {
            heap[index] = right;
            heap[rightIndex] = node;
            index = rightIndex;
          } else {
            return;
          }
        }
      }
      function compare(a, b) {
        var diff = a.sortIndex - b.sortIndex;
        return diff !== 0 ? diff : a.id - b.id;
      }
      var ImmediatePriority = 1;
      var UserBlockingPriority = 2;
      var NormalPriority = 3;
      var LowPriority = 4;
      var IdlePriority = 5;
      function markTaskErrored(task, ms) {}
      var hasPerformanceNow = typeof performance === "object" && typeof performance.now === "function";
      if (hasPerformanceNow) {
        var localPerformance = performance;
        exports.unstable_now = function() {
          return localPerformance.now();
        };
      } else {
        var localDate = Date;
        var initialTime = localDate.now();
        exports.unstable_now = function() {
          return localDate.now() - initialTime;
        };
      }
      var maxSigned31BitInt = 1073741823;
      var IMMEDIATE_PRIORITY_TIMEOUT = -1;
      var USER_BLOCKING_PRIORITY_TIMEOUT = 250;
      var NORMAL_PRIORITY_TIMEOUT = 5000;
      var LOW_PRIORITY_TIMEOUT = 1e4;
      var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt;
      var taskQueue = [];
      var timerQueue = [];
      var taskIdCounter = 1;
      var currentTask = null;
      var currentPriorityLevel = NormalPriority;
      var isPerformingWork = false;
      var isHostCallbackScheduled = false;
      var isHostTimeoutScheduled = false;
      var localSetTimeout = typeof setTimeout === "function" ? setTimeout : null;
      var localClearTimeout = typeof clearTimeout === "function" ? clearTimeout : null;
      var localSetImmediate = typeof setImmediate !== "undefined" ? setImmediate : null;
      var isInputPending = typeof navigator !== "undefined" && navigator.scheduling !== undefined && navigator.scheduling.isInputPending !== undefined ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;
      function advanceTimers(currentTime) {
        var timer = peek(timerQueue);
        while (timer !== null) {
          if (timer.callback === null) {
            pop(timerQueue);
          } else if (timer.startTime <= currentTime) {
            pop(timerQueue);
            timer.sortIndex = timer.expirationTime;
            push(taskQueue, timer);
          } else {
            return;
          }
          timer = peek(timerQueue);
        }
      }
      function handleTimeout(currentTime) {
        isHostTimeoutScheduled = false;
        advanceTimers(currentTime);
        if (!isHostCallbackScheduled) {
          if (peek(taskQueue) !== null) {
            isHostCallbackScheduled = true;
            requestHostCallback(flushWork);
          } else {
            var firstTimer = peek(timerQueue);
            if (firstTimer !== null) {
              requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
            }
          }
        }
      }
      function flushWork(hasTimeRemaining, initialTime2) {
        isHostCallbackScheduled = false;
        if (isHostTimeoutScheduled) {
          isHostTimeoutScheduled = false;
          cancelHostTimeout();
        }
        isPerformingWork = true;
        var previousPriorityLevel = currentPriorityLevel;
        try {
          if (enableProfiling) {
            try {
              return workLoop(hasTimeRemaining, initialTime2);
            } catch (error) {
              if (currentTask !== null) {
                var currentTime = exports.unstable_now();
                markTaskErrored(currentTask, currentTime);
                currentTask.isQueued = false;
              }
              throw error;
            }
          } else {
            return workLoop(hasTimeRemaining, initialTime2);
          }
        } finally {
          currentTask = null;
          currentPriorityLevel = previousPriorityLevel;
          isPerformingWork = false;
        }
      }
      function workLoop(hasTimeRemaining, initialTime2) {
        var currentTime = initialTime2;
        advanceTimers(currentTime);
        currentTask = peek(taskQueue);
        while (currentTask !== null && !enableSchedulerDebugging) {
          if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {
            break;
          }
          var callback = currentTask.callback;
          if (typeof callback === "function") {
            currentTask.callback = null;
            currentPriorityLevel = currentTask.priorityLevel;
            var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;
            var continuationCallback = callback(didUserCallbackTimeout);
            currentTime = exports.unstable_now();
            if (typeof continuationCallback === "function") {
              currentTask.callback = continuationCallback;
            } else {
              if (currentTask === peek(taskQueue)) {
                pop(taskQueue);
              }
            }
            advanceTimers(currentTime);
          } else {
            pop(taskQueue);
          }
          currentTask = peek(taskQueue);
        }
        if (currentTask !== null) {
          return true;
        } else {
          var firstTimer = peek(timerQueue);
          if (firstTimer !== null) {
            requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);
          }
          return false;
        }
      }
      function unstable_runWithPriority(priorityLevel, eventHandler) {
        switch (priorityLevel) {
          case ImmediatePriority:
          case UserBlockingPriority:
          case NormalPriority:
          case LowPriority:
          case IdlePriority:
            break;
          default:
            priorityLevel = NormalPriority;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      }
      function unstable_next(eventHandler) {
        var priorityLevel;
        switch (currentPriorityLevel) {
          case ImmediatePriority:
          case UserBlockingPriority:
          case NormalPriority:
            priorityLevel = NormalPriority;
            break;
          default:
            priorityLevel = currentPriorityLevel;
            break;
        }
        var previousPriorityLevel = currentPriorityLevel;
        currentPriorityLevel = priorityLevel;
        try {
          return eventHandler();
        } finally {
          currentPriorityLevel = previousPriorityLevel;
        }
      }
      function unstable_wrapCallback(callback) {
        var parentPriorityLevel = currentPriorityLevel;
        return function() {
          var previousPriorityLevel = currentPriorityLevel;
          currentPriorityLevel = parentPriorityLevel;
          try {
            return callback.apply(this, arguments);
          } finally {
            currentPriorityLevel = previousPriorityLevel;
          }
        };
      }
      function unstable_scheduleCallback(priorityLevel, callback, options) {
        var currentTime = exports.unstable_now();
        var startTime2;
        if (typeof options === "object" && options !== null) {
          var delay = options.delay;
          if (typeof delay === "number" && delay > 0) {
            startTime2 = currentTime + delay;
          } else {
            startTime2 = currentTime;
          }
        } else {
          startTime2 = currentTime;
        }
        var timeout;
        switch (priorityLevel) {
          case ImmediatePriority:
            timeout = IMMEDIATE_PRIORITY_TIMEOUT;
            break;
          case UserBlockingPriority:
            timeout = USER_BLOCKING_PRIORITY_TIMEOUT;
            break;
          case IdlePriority:
            timeout = IDLE_PRIORITY_TIMEOUT;
            break;
          case LowPriority:
            timeout = LOW_PRIORITY_TIMEOUT;
            break;
          case NormalPriority:
          default:
            timeout = NORMAL_PRIORITY_TIMEOUT;
            break;
        }
        var expirationTime = startTime2 + timeout;
        var newTask = {
          id: taskIdCounter++,
          callback,
          priorityLevel,
          startTime: startTime2,
          expirationTime,
          sortIndex: -1
        };
        if (startTime2 > currentTime) {
          newTask.sortIndex = startTime2;
          push(timerQueue, newTask);
          if (peek(taskQueue) === null && newTask === peek(timerQueue)) {
            if (isHostTimeoutScheduled) {
              cancelHostTimeout();
            } else {
              isHostTimeoutScheduled = true;
            }
            requestHostTimeout(handleTimeout, startTime2 - currentTime);
          }
        } else {
          newTask.sortIndex = expirationTime;
          push(taskQueue, newTask);
          if (!isHostCallbackScheduled && !isPerformingWork) {
            isHostCallbackScheduled = true;
            requestHostCallback(flushWork);
          }
        }
        return newTask;
      }
      function unstable_pauseExecution() {}
      function unstable_continueExecution() {
        if (!isHostCallbackScheduled && !isPerformingWork) {
          isHostCallbackScheduled = true;
          requestHostCallback(flushWork);
        }
      }
      function unstable_getFirstCallbackNode() {
        return peek(taskQueue);
      }
      function unstable_cancelCallback(task) {
        task.callback = null;
      }
      function unstable_getCurrentPriorityLevel() {
        return currentPriorityLevel;
      }
      var isMessageLoopRunning = false;
      var scheduledHostCallback = null;
      var taskTimeoutID = -1;
      var frameInterval = frameYieldMs;
      var startTime = -1;
      function shouldYieldToHost() {
        var timeElapsed = exports.unstable_now() - startTime;
        if (timeElapsed < frameInterval) {
          return false;
        }
        return true;
      }
      function requestPaint() {}
      function forceFrameRate(fps) {
        if (fps < 0 || fps > 125) {
          console["error"]("forceFrameRate takes a positive int between 0 and 125, " + "forcing frame rates higher than 125 fps is not supported");
          return;
        }
        if (fps > 0) {
          frameInterval = Math.floor(1000 / fps);
        } else {
          frameInterval = frameYieldMs;
        }
      }
      var performWorkUntilDeadline = function() {
        if (scheduledHostCallback !== null) {
          var currentTime = exports.unstable_now();
          startTime = currentTime;
          var hasTimeRemaining = true;
          var hasMoreWork = true;
          try {
            hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);
          } finally {
            if (hasMoreWork) {
              schedulePerformWorkUntilDeadline();
            } else {
              isMessageLoopRunning = false;
              scheduledHostCallback = null;
            }
          }
        } else {
          isMessageLoopRunning = false;
        }
      };
      var schedulePerformWorkUntilDeadline;
      if (typeof localSetImmediate === "function") {
        schedulePerformWorkUntilDeadline = function() {
          localSetImmediate(performWorkUntilDeadline);
        };
      } else if (typeof MessageChannel !== "undefined") {
        var channel = new MessageChannel;
        var port = channel.port2;
        channel.port1.onmessage = performWorkUntilDeadline;
        schedulePerformWorkUntilDeadline = function() {
          port.postMessage(null);
        };
      } else {
        schedulePerformWorkUntilDeadline = function() {
          localSetTimeout(performWorkUntilDeadline, 0);
        };
      }
      function requestHostCallback(callback) {
        scheduledHostCallback = callback;
        if (!isMessageLoopRunning) {
          isMessageLoopRunning = true;
          schedulePerformWorkUntilDeadline();
        }
      }
      function requestHostTimeout(callback, ms) {
        taskTimeoutID = localSetTimeout(function() {
          callback(exports.unstable_now());
        }, ms);
      }
      function cancelHostTimeout() {
        localClearTimeout(taskTimeoutID);
        taskTimeoutID = -1;
      }
      var unstable_requestPaint = requestPaint;
      var unstable_Profiling = null;
      exports.unstable_IdlePriority = IdlePriority;
      exports.unstable_ImmediatePriority = ImmediatePriority;
      exports.unstable_LowPriority = LowPriority;
      exports.unstable_NormalPriority = NormalPriority;
      exports.unstable_Profiling = unstable_Profiling;
      exports.unstable_UserBlockingPriority = UserBlockingPriority;
      exports.unstable_cancelCallback = unstable_cancelCallback;
      exports.unstable_continueExecution = unstable_continueExecution;
      exports.unstable_forceFrameRate = forceFrameRate;
      exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;
      exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;
      exports.unstable_next = unstable_next;
      exports.unstable_pauseExecution = unstable_pauseExecution;
      exports.unstable_requestPaint = unstable_requestPaint;
      exports.unstable_runWithPriority = unstable_runWithPriority;
      exports.unstable_scheduleCallback = unstable_scheduleCallback;
      exports.unstable_shouldYield = shouldYieldToHost;
      exports.unstable_wrapCallback = unstable_wrapCallback;
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error);
      }
    })();
  }
});

// node_modules/scheduler/index.js
var require_scheduler = __commonJS((exports, module) => {
  var scheduler_development = __toESM(require_scheduler_development());
  if (false) {} else {
    module.exports = scheduler_development;
  }
});

// node_modules/react-dom/cjs/react-dom.development.js
var require_react_dom_development = __commonJS((exports) => {
  var React = __toESM(require_react());
  var Scheduler = __toESM(require_scheduler());
  if (true) {
    (function() {
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error);
      }
      var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      var suppressWarning = false;
      function setSuppressWarning(newSuppressWarning) {
        {
          suppressWarning = newSuppressWarning;
        }
      }
      function warn(format) {
        {
          if (!suppressWarning) {
            for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1;_key < _len; _key++) {
              args[_key - 1] = arguments[_key];
            }
            printWarning("warn", format, args);
          }
        }
      }
      function error(format) {
        {
          if (!suppressWarning) {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1;_key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame2.getStackAddendum();
          if (stack !== "") {
            format += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      var FunctionComponent = 0;
      var ClassComponent = 1;
      var IndeterminateComponent = 2;
      var HostRoot = 3;
      var HostPortal = 4;
      var HostComponent = 5;
      var HostText = 6;
      var Fragment = 7;
      var Mode = 8;
      var ContextConsumer = 9;
      var ContextProvider = 10;
      var ForwardRef = 11;
      var Profiler = 12;
      var SuspenseComponent = 13;
      var MemoComponent = 14;
      var SimpleMemoComponent = 15;
      var LazyComponent = 16;
      var IncompleteClassComponent = 17;
      var DehydratedFragment = 18;
      var SuspenseListComponent = 19;
      var ScopeComponent = 21;
      var OffscreenComponent = 22;
      var LegacyHiddenComponent = 23;
      var CacheComponent = 24;
      var TracingMarkerComponent = 25;
      var enableClientRenderFallbackOnTextMismatch = true;
      var enableNewReconciler = false;
      var enableLazyContextPropagation = false;
      var enableLegacyHidden = false;
      var enableSuspenseAvoidThisFallback = false;
      var disableCommentsAsDOMContainers = true;
      var enableCustomElementPropertySupport = false;
      var warnAboutStringRefs = true;
      var enableSchedulingProfiler = true;
      var enableProfilerTimer = true;
      var enableProfilerCommitHooks = true;
      var allNativeEvents = new Set;
      var registrationNameDependencies = {};
      var possibleRegistrationNames = {};
      function registerTwoPhaseEvent(registrationName, dependencies) {
        registerDirectEvent(registrationName, dependencies);
        registerDirectEvent(registrationName + "Capture", dependencies);
      }
      function registerDirectEvent(registrationName, dependencies) {
        {
          if (registrationNameDependencies[registrationName]) {
            error("EventRegistry: More than one plugin attempted to publish the same " + "registration name, `%s`.", registrationName);
          }
        }
        registrationNameDependencies[registrationName] = dependencies;
        {
          var lowerCasedName = registrationName.toLowerCase();
          possibleRegistrationNames[lowerCasedName] = registrationName;
          if (registrationName === "onDoubleClick") {
            possibleRegistrationNames.ondblclick = registrationName;
          }
        }
        for (var i = 0;i < dependencies.length; i++) {
          allNativeEvents.add(dependencies[i]);
        }
      }
      var canUseDOM = !!(typeof window !== "undefined" && typeof window.document !== "undefined" && typeof window.document.createElement !== "undefined");
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      function typeName(value) {
        {
          var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
          var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          return type;
        }
      }
      function willCoercionThrow(value) {
        {
          try {
            testStringCoercion(value);
            return false;
          } catch (e) {
            return true;
          }
        }
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkAttributeStringCoercion(value, attributeName) {
        {
          if (willCoercionThrow(value)) {
            error("The provided `%s` attribute is an unsupported type %s." + " This value must be coerced to a string before before using it here.", attributeName, typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      function checkKeyStringCoercion(value) {
        {
          if (willCoercionThrow(value)) {
            error("The provided key is an unsupported type %s." + " This value must be coerced to a string before before using it here.", typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      function checkPropStringCoercion(value, propName) {
        {
          if (willCoercionThrow(value)) {
            error("The provided `%s` prop is an unsupported type %s." + " This value must be coerced to a string before before using it here.", propName, typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      function checkCSSPropertyStringCoercion(value, propName) {
        {
          if (willCoercionThrow(value)) {
            error("The provided `%s` CSS property is an unsupported type %s." + " This value must be coerced to a string before before using it here.", propName, typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      function checkHtmlStringCoercion(value) {
        {
          if (willCoercionThrow(value)) {
            error("The provided HTML markup uses a value of unsupported type %s." + " This value must be coerced to a string before before using it here.", typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      function checkFormFieldValueStringCoercion(value) {
        {
          if (willCoercionThrow(value)) {
            error("Form field values (value, checked, defaultValue, or defaultChecked props)" + " must be strings, not %s." + " This value must be coerced to a string before before using it here.", typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      var RESERVED = 0;
      var STRING = 1;
      var BOOLEANISH_STRING = 2;
      var BOOLEAN = 3;
      var OVERLOADED_BOOLEAN = 4;
      var NUMERIC = 5;
      var POSITIVE_NUMERIC = 6;
      var ATTRIBUTE_NAME_START_CHAR = ":A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD";
      var ATTRIBUTE_NAME_CHAR = ATTRIBUTE_NAME_START_CHAR + "\\-.0-9\\u00B7\\u0300-\\u036F\\u203F-\\u2040";
      var VALID_ATTRIBUTE_NAME_REGEX = new RegExp("^[" + ATTRIBUTE_NAME_START_CHAR + "][" + ATTRIBUTE_NAME_CHAR + "]*$");
      var illegalAttributeNameCache = {};
      var validatedAttributeNameCache = {};
      function isAttributeNameSafe(attributeName) {
        if (hasOwnProperty.call(validatedAttributeNameCache, attributeName)) {
          return true;
        }
        if (hasOwnProperty.call(illegalAttributeNameCache, attributeName)) {
          return false;
        }
        if (VALID_ATTRIBUTE_NAME_REGEX.test(attributeName)) {
          validatedAttributeNameCache[attributeName] = true;
          return true;
        }
        illegalAttributeNameCache[attributeName] = true;
        {
          error("Invalid attribute name: `%s`", attributeName);
        }
        return false;
      }
      function shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag) {
        if (propertyInfo !== null) {
          return propertyInfo.type === RESERVED;
        }
        if (isCustomComponentTag) {
          return false;
        }
        if (name.length > 2 && (name[0] === "o" || name[0] === "O") && (name[1] === "n" || name[1] === "N")) {
          return true;
        }
        return false;
      }
      function shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag) {
        if (propertyInfo !== null && propertyInfo.type === RESERVED) {
          return false;
        }
        switch (typeof value) {
          case "function":
          case "symbol":
            return true;
          case "boolean": {
            if (isCustomComponentTag) {
              return false;
            }
            if (propertyInfo !== null) {
              return !propertyInfo.acceptsBooleans;
            } else {
              var prefix2 = name.toLowerCase().slice(0, 5);
              return prefix2 !== "data-" && prefix2 !== "aria-";
            }
          }
          default:
            return false;
        }
      }
      function shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag) {
        if (value === null || typeof value === "undefined") {
          return true;
        }
        if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, isCustomComponentTag)) {
          return true;
        }
        if (isCustomComponentTag) {
          return false;
        }
        if (propertyInfo !== null) {
          switch (propertyInfo.type) {
            case BOOLEAN:
              return !value;
            case OVERLOADED_BOOLEAN:
              return value === false;
            case NUMERIC:
              return isNaN(value);
            case POSITIVE_NUMERIC:
              return isNaN(value) || value < 1;
          }
        }
        return false;
      }
      function getPropertyInfo(name) {
        return properties.hasOwnProperty(name) ? properties[name] : null;
      }
      function PropertyInfoRecord(name, type, mustUseProperty, attributeName, attributeNamespace, sanitizeURL2, removeEmptyString) {
        this.acceptsBooleans = type === BOOLEANISH_STRING || type === BOOLEAN || type === OVERLOADED_BOOLEAN;
        this.attributeName = attributeName;
        this.attributeNamespace = attributeNamespace;
        this.mustUseProperty = mustUseProperty;
        this.propertyName = name;
        this.type = type;
        this.sanitizeURL = sanitizeURL2;
        this.removeEmptyString = removeEmptyString;
      }
      var properties = {};
      var reservedProps = [
        "children",
        "dangerouslySetInnerHTML",
        "defaultValue",
        "defaultChecked",
        "innerHTML",
        "suppressContentEditableWarning",
        "suppressHydrationWarning",
        "style"
      ];
      reservedProps.forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, RESERVED, false, name, null, false, false);
      });
      [["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function(_ref) {
        var name = _ref[0], attributeName = _ref[1];
        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
      });
      ["contentEditable", "draggable", "spellCheck", "value"].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name.toLowerCase(), null, false, false);
      });
      ["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, BOOLEANISH_STRING, false, name, null, false, false);
      });
      [
        "allowFullScreen",
        "async",
        "autoFocus",
        "autoPlay",
        "controls",
        "default",
        "defer",
        "disabled",
        "disablePictureInPicture",
        "disableRemotePlayback",
        "formNoValidate",
        "hidden",
        "loop",
        "noModule",
        "noValidate",
        "open",
        "playsInline",
        "readOnly",
        "required",
        "reversed",
        "scoped",
        "seamless",
        "itemScope"
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, BOOLEAN, false, name.toLowerCase(), null, false, false);
      });
      [
        "checked",
        "multiple",
        "muted",
        "selected"
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, BOOLEAN, true, name, null, false, false);
      });
      [
        "capture",
        "download"
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, OVERLOADED_BOOLEAN, false, name, null, false, false);
      });
      [
        "cols",
        "rows",
        "size",
        "span"
      ].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, POSITIVE_NUMERIC, false, name, null, false, false);
      });
      ["rowSpan", "start"].forEach(function(name) {
        properties[name] = new PropertyInfoRecord(name, NUMERIC, false, name.toLowerCase(), null, false, false);
      });
      var CAMELIZE = /[\-\:]([a-z])/g;
      var capitalize = function(token) {
        return token[1].toUpperCase();
      };
      [
        "accent-height",
        "alignment-baseline",
        "arabic-form",
        "baseline-shift",
        "cap-height",
        "clip-path",
        "clip-rule",
        "color-interpolation",
        "color-interpolation-filters",
        "color-profile",
        "color-rendering",
        "dominant-baseline",
        "enable-background",
        "fill-opacity",
        "fill-rule",
        "flood-color",
        "flood-opacity",
        "font-family",
        "font-size",
        "font-size-adjust",
        "font-stretch",
        "font-style",
        "font-variant",
        "font-weight",
        "glyph-name",
        "glyph-orientation-horizontal",
        "glyph-orientation-vertical",
        "horiz-adv-x",
        "horiz-origin-x",
        "image-rendering",
        "letter-spacing",
        "lighting-color",
        "marker-end",
        "marker-mid",
        "marker-start",
        "overline-position",
        "overline-thickness",
        "paint-order",
        "panose-1",
        "pointer-events",
        "rendering-intent",
        "shape-rendering",
        "stop-color",
        "stop-opacity",
        "strikethrough-position",
        "strikethrough-thickness",
        "stroke-dasharray",
        "stroke-dashoffset",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke-width",
        "text-anchor",
        "text-decoration",
        "text-rendering",
        "underline-position",
        "underline-thickness",
        "unicode-bidi",
        "unicode-range",
        "units-per-em",
        "v-alphabetic",
        "v-hanging",
        "v-ideographic",
        "v-mathematical",
        "vector-effect",
        "vert-adv-y",
        "vert-origin-x",
        "vert-origin-y",
        "word-spacing",
        "writing-mode",
        "xmlns:xlink",
        "x-height"
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize);
        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, null, false, false);
      });
      [
        "xlink:actuate",
        "xlink:arcrole",
        "xlink:role",
        "xlink:show",
        "xlink:title",
        "xlink:type"
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize);
        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, "http://www.w3.org/1999/xlink", false, false);
      });
      [
        "xml:base",
        "xml:lang",
        "xml:space"
      ].forEach(function(attributeName) {
        var name = attributeName.replace(CAMELIZE, capitalize);
        properties[name] = new PropertyInfoRecord(name, STRING, false, attributeName, "http://www.w3.org/XML/1998/namespace", false, false);
      });
      ["tabIndex", "crossOrigin"].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, false, false);
      });
      var xlinkHref = "xlinkHref";
      properties[xlinkHref] = new PropertyInfoRecord("xlinkHref", STRING, false, "xlink:href", "http://www.w3.org/1999/xlink", true, false);
      ["src", "href", "action", "formAction"].forEach(function(attributeName) {
        properties[attributeName] = new PropertyInfoRecord(attributeName, STRING, false, attributeName.toLowerCase(), null, true, true);
      });
      var isJavaScriptProtocol = /^[\u0000-\u001F ]*j[\r\n\t]*a[\r\n\t]*v[\r\n\t]*a[\r\n\t]*s[\r\n\t]*c[\r\n\t]*r[\r\n\t]*i[\r\n\t]*p[\r\n\t]*t[\r\n\t]*\:/i;
      var didWarn = false;
      function sanitizeURL(url) {
        {
          if (!didWarn && isJavaScriptProtocol.test(url)) {
            didWarn = true;
            error("A future version of React will block javascript: URLs as a security precaution. " + "Use event handlers instead if you can. If you need to generate unsafe HTML try " + "using dangerouslySetInnerHTML instead. React was passed %s.", JSON.stringify(url));
          }
        }
      }
      function getValueForProperty(node, name, expected, propertyInfo) {
        {
          if (propertyInfo.mustUseProperty) {
            var propertyName = propertyInfo.propertyName;
            return node[propertyName];
          } else {
            {
              checkAttributeStringCoercion(expected, name);
            }
            if (propertyInfo.sanitizeURL) {
              sanitizeURL("" + expected);
            }
            var attributeName = propertyInfo.attributeName;
            var stringValue = null;
            if (propertyInfo.type === OVERLOADED_BOOLEAN) {
              if (node.hasAttribute(attributeName)) {
                var value = node.getAttribute(attributeName);
                if (value === "") {
                  return true;
                }
                if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                  return value;
                }
                if (value === "" + expected) {
                  return expected;
                }
                return value;
              }
            } else if (node.hasAttribute(attributeName)) {
              if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
                return node.getAttribute(attributeName);
              }
              if (propertyInfo.type === BOOLEAN) {
                return expected;
              }
              stringValue = node.getAttribute(attributeName);
            }
            if (shouldRemoveAttribute(name, expected, propertyInfo, false)) {
              return stringValue === null ? expected : stringValue;
            } else if (stringValue === "" + expected) {
              return expected;
            } else {
              return stringValue;
            }
          }
        }
      }
      function getValueForAttribute(node, name, expected, isCustomComponentTag) {
        {
          if (!isAttributeNameSafe(name)) {
            return;
          }
          if (!node.hasAttribute(name)) {
            return expected === undefined ? undefined : null;
          }
          var value = node.getAttribute(name);
          {
            checkAttributeStringCoercion(expected, name);
          }
          if (value === "" + expected) {
            return expected;
          }
          return value;
        }
      }
      function setValueForProperty(node, name, value, isCustomComponentTag) {
        var propertyInfo = getPropertyInfo(name);
        if (shouldIgnoreAttribute(name, propertyInfo, isCustomComponentTag)) {
          return;
        }
        if (shouldRemoveAttribute(name, value, propertyInfo, isCustomComponentTag)) {
          value = null;
        }
        if (isCustomComponentTag || propertyInfo === null) {
          if (isAttributeNameSafe(name)) {
            var _attributeName = name;
            if (value === null) {
              node.removeAttribute(_attributeName);
            } else {
              {
                checkAttributeStringCoercion(value, name);
              }
              node.setAttribute(_attributeName, "" + value);
            }
          }
          return;
        }
        var mustUseProperty = propertyInfo.mustUseProperty;
        if (mustUseProperty) {
          var propertyName = propertyInfo.propertyName;
          if (value === null) {
            var type = propertyInfo.type;
            node[propertyName] = type === BOOLEAN ? false : "";
          } else {
            node[propertyName] = value;
          }
          return;
        }
        var { attributeName, attributeNamespace } = propertyInfo;
        if (value === null) {
          node.removeAttribute(attributeName);
        } else {
          var _type = propertyInfo.type;
          var attributeValue;
          if (_type === BOOLEAN || _type === OVERLOADED_BOOLEAN && value === true) {
            attributeValue = "";
          } else {
            {
              {
                checkAttributeStringCoercion(value, attributeName);
              }
              attributeValue = "" + value;
            }
            if (propertyInfo.sanitizeURL) {
              sanitizeURL(attributeValue.toString());
            }
          }
          if (attributeNamespace) {
            node.setAttributeNS(attributeNamespace, attributeName, attributeValue);
          } else {
            node.setAttribute(attributeName, attributeValue);
          }
        }
      }
      var REACT_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_SCOPE_TYPE = Symbol.for("react.scope");
      var REACT_DEBUG_TRACING_MODE_TYPE = Symbol.for("react.debug_trace_mode");
      var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
      var REACT_LEGACY_HIDDEN_TYPE = Symbol.for("react.legacy_hidden");
      var REACT_CACHE_TYPE = Symbol.for("react.cache");
      var REACT_TRACING_MARKER_TYPE = Symbol.for("react.tracing_marker");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }
        return null;
      }
      var assign = Object.assign;
      var disabledDepth = 0;
      var prevLog;
      var prevInfo;
      var prevWarn;
      var prevError;
      var prevGroup;
      var prevGroupCollapsed;
      var prevGroupEnd;
      function disabledLog() {}
      disabledLog.__reactDisabledLog = true;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          disabledDepth--;
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          if (disabledDepth < 0) {
            error("disabledDepth fell below zero. " + "This is a bug in React. Please file an issue.");
          }
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
      var prefix;
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix === undefined) {
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          }
          return `
` + prefix + name;
        }
      }
      var reentry = false;
      var componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap;
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) {
          return "";
        }
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== undefined) {
            return frame;
          }
        }
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = undefined;
        var previousDispatcher;
        {
          previousDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = null;
          disableLogs();
        }
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === "string") {
            var sampleLines = sample.stack.split(`
`);
            var controlLines = control.stack.split(`
`);
            var s = sampleLines.length - 1;
            var c = controlLines.length - 1;
            while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
              c--;
            }
            for (;s >= 1 && c >= 0; s--, c--) {
              if (sampleLines[s] !== controlLines[c]) {
                if (s !== 1 || c !== 1) {
                  do {
                    s--;
                    c--;
                    if (c < 0 || sampleLines[s] !== controlLines[c]) {
                      var _frame = `
` + sampleLines[s].replace(" at new ", " at ");
                      if (fn.displayName && _frame.includes("<anonymous>")) {
                        _frame = _frame.replace("<anonymous>", fn.displayName);
                      }
                      {
                        if (typeof fn === "function") {
                          componentFrameCache.set(fn, _frame);
                        }
                      }
                      return _frame;
                    }
                  } while (s >= 1 && c >= 0);
                }
                break;
              }
            }
          }
        } finally {
          reentry = false;
          {
            ReactCurrentDispatcher.current = previousDispatcher;
            reenableLogs();
          }
          Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "";
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        {
          if (typeof fn === "function") {
            componentFrameCache.set(fn, syntheticFrame);
          }
        }
        return syntheticFrame;
      }
      function describeClassComponentFrame(ctor, source, ownerFn) {
        {
          return describeNativeComponentFrame(ctor, true);
        }
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        {
          return describeNativeComponentFrame(fn, false);
        }
      }
      function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) {
          return "";
        }
        if (typeof type === "function") {
          {
            return describeNativeComponentFrame(type, shouldConstruct(type));
          }
        }
        if (typeof type === "string") {
          return describeBuiltInComponentFrame(type);
        }
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
              } catch (x) {}
            }
          }
        }
        return "";
      }
      function describeFiber(fiber) {
        var owner = fiber._debugOwner ? fiber._debugOwner.type : null;
        var source = fiber._debugSource;
        switch (fiber.tag) {
          case HostComponent:
            return describeBuiltInComponentFrame(fiber.type);
          case LazyComponent:
            return describeBuiltInComponentFrame("Lazy");
          case SuspenseComponent:
            return describeBuiltInComponentFrame("Suspense");
          case SuspenseListComponent:
            return describeBuiltInComponentFrame("SuspenseList");
          case FunctionComponent:
          case IndeterminateComponent:
          case SimpleMemoComponent:
            return describeFunctionComponentFrame(fiber.type);
          case ForwardRef:
            return describeFunctionComponentFrame(fiber.type.render);
          case ClassComponent:
            return describeClassComponentFrame(fiber.type);
          default:
            return "";
        }
      }
      function getStackByFiberInDevAndProd(workInProgress2) {
        try {
          var info = "";
          var node = workInProgress2;
          do {
            info += describeFiber(node);
            node = node.return;
          } while (node);
          return info;
        } catch (x) {
          return `
Error generating stack: ` + x.message + `
` + x.stack;
        }
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName) {
          return displayName;
        }
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromType(type) {
        if (type == null) {
          return null;
        }
        {
          if (typeof type.tag === "number") {
            error("Received an unexpected object in getComponentNameFromType(). " + "This is likely a bug in React. Please file an issue.");
          }
        }
        if (typeof type === "function") {
          return type.displayName || type.name || null;
        }
        if (typeof type === "string") {
          return type;
        }
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type.displayName || null;
              if (outerName !== null) {
                return outerName;
              }
              return getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return getComponentNameFromType(init(payload));
              } catch (x) {
                return null;
              }
            }
          }
        }
        return null;
      }
      function getWrappedName$1(outerType, innerType, wrapperName) {
        var functionName = innerType.displayName || innerType.name || "";
        return outerType.displayName || (functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName);
      }
      function getContextName$1(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromFiber(fiber) {
        var { tag, type } = fiber;
        switch (tag) {
          case CacheComponent:
            return "Cache";
          case ContextConsumer:
            var context = type;
            return getContextName$1(context) + ".Consumer";
          case ContextProvider:
            var provider = type;
            return getContextName$1(provider._context) + ".Provider";
          case DehydratedFragment:
            return "DehydratedFragment";
          case ForwardRef:
            return getWrappedName$1(type, type.render, "ForwardRef");
          case Fragment:
            return "Fragment";
          case HostComponent:
            return type;
          case HostPortal:
            return "Portal";
          case HostRoot:
            return "Root";
          case HostText:
            return "Text";
          case LazyComponent:
            return getComponentNameFromType(type);
          case Mode:
            if (type === REACT_STRICT_MODE_TYPE) {
              return "StrictMode";
            }
            return "Mode";
          case OffscreenComponent:
            return "Offscreen";
          case Profiler:
            return "Profiler";
          case ScopeComponent:
            return "Scope";
          case SuspenseComponent:
            return "Suspense";
          case SuspenseListComponent:
            return "SuspenseList";
          case TracingMarkerComponent:
            return "TracingMarker";
          case ClassComponent:
          case FunctionComponent:
          case IncompleteClassComponent:
          case IndeterminateComponent:
          case MemoComponent:
          case SimpleMemoComponent:
            if (typeof type === "function") {
              return type.displayName || type.name || null;
            }
            if (typeof type === "string") {
              return type;
            }
            break;
        }
        return null;
      }
      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      var current = null;
      var isRendering = false;
      function getCurrentFiberOwnerNameInDevOrNull() {
        {
          if (current === null) {
            return null;
          }
          var owner = current._debugOwner;
          if (owner !== null && typeof owner !== "undefined") {
            return getComponentNameFromFiber(owner);
          }
        }
        return null;
      }
      function getCurrentFiberStackInDev() {
        {
          if (current === null) {
            return "";
          }
          return getStackByFiberInDevAndProd(current);
        }
      }
      function resetCurrentFiber() {
        {
          ReactDebugCurrentFrame.getCurrentStack = null;
          current = null;
          isRendering = false;
        }
      }
      function setCurrentFiber(fiber) {
        {
          ReactDebugCurrentFrame.getCurrentStack = fiber === null ? null : getCurrentFiberStackInDev;
          current = fiber;
          isRendering = false;
        }
      }
      function getCurrentFiber() {
        {
          return current;
        }
      }
      function setIsRendering(rendering) {
        {
          isRendering = rendering;
        }
      }
      function toString(value) {
        return "" + value;
      }
      function getToStringValue(value) {
        switch (typeof value) {
          case "boolean":
          case "number":
          case "string":
          case "undefined":
            return value;
          case "object":
            {
              checkFormFieldValueStringCoercion(value);
            }
            return value;
          default:
            return "";
        }
      }
      var hasReadOnlyValue = {
        button: true,
        checkbox: true,
        image: true,
        hidden: true,
        radio: true,
        reset: true,
        submit: true
      };
      function checkControlledValueProps(tagName, props) {
        {
          if (!(hasReadOnlyValue[props.type] || props.onChange || props.onInput || props.readOnly || props.disabled || props.value == null)) {
            error("You provided a `value` prop to a form field without an " + "`onChange` handler. This will render a read-only field. If " + "the field should be mutable use `defaultValue`. Otherwise, " + "set either `onChange` or `readOnly`.");
          }
          if (!(props.onChange || props.readOnly || props.disabled || props.checked == null)) {
            error("You provided a `checked` prop to a form field without an " + "`onChange` handler. This will render a read-only field. If " + "the field should be mutable use `defaultChecked`. Otherwise, " + "set either `onChange` or `readOnly`.");
          }
        }
      }
      function isCheckable(elem) {
        var type = elem.type;
        var nodeName = elem.nodeName;
        return nodeName && nodeName.toLowerCase() === "input" && (type === "checkbox" || type === "radio");
      }
      function getTracker(node) {
        return node._valueTracker;
      }
      function detachTracker(node) {
        node._valueTracker = null;
      }
      function getValueFromNode(node) {
        var value = "";
        if (!node) {
          return value;
        }
        if (isCheckable(node)) {
          value = node.checked ? "true" : "false";
        } else {
          value = node.value;
        }
        return value;
      }
      function trackValueOnNode(node) {
        var valueField = isCheckable(node) ? "checked" : "value";
        var descriptor = Object.getOwnPropertyDescriptor(node.constructor.prototype, valueField);
        {
          checkFormFieldValueStringCoercion(node[valueField]);
        }
        var currentValue = "" + node[valueField];
        if (node.hasOwnProperty(valueField) || typeof descriptor === "undefined" || typeof descriptor.get !== "function" || typeof descriptor.set !== "function") {
          return;
        }
        var { get: get2, set: set2 } = descriptor;
        Object.defineProperty(node, valueField, {
          configurable: true,
          get: function() {
            return get2.call(this);
          },
          set: function(value) {
            {
              checkFormFieldValueStringCoercion(value);
            }
            currentValue = "" + value;
            set2.call(this, value);
          }
        });
        Object.defineProperty(node, valueField, {
          enumerable: descriptor.enumerable
        });
        var tracker = {
          getValue: function() {
            return currentValue;
          },
          setValue: function(value) {
            {
              checkFormFieldValueStringCoercion(value);
            }
            currentValue = "" + value;
          },
          stopTracking: function() {
            detachTracker(node);
            delete node[valueField];
          }
        };
        return tracker;
      }
      function track(node) {
        if (getTracker(node)) {
          return;
        }
        node._valueTracker = trackValueOnNode(node);
      }
      function updateValueIfChanged(node) {
        if (!node) {
          return false;
        }
        var tracker = getTracker(node);
        if (!tracker) {
          return true;
        }
        var lastValue = tracker.getValue();
        var nextValue = getValueFromNode(node);
        if (nextValue !== lastValue) {
          tracker.setValue(nextValue);
          return true;
        }
        return false;
      }
      function getActiveElement(doc) {
        doc = doc || (typeof document !== "undefined" ? document : undefined);
        if (typeof doc === "undefined") {
          return null;
        }
        try {
          return doc.activeElement || doc.body;
        } catch (e) {
          return doc.body;
        }
      }
      var didWarnValueDefaultValue = false;
      var didWarnCheckedDefaultChecked = false;
      var didWarnControlledToUncontrolled = false;
      var didWarnUncontrolledToControlled = false;
      function isControlled(props) {
        var usesChecked = props.type === "checkbox" || props.type === "radio";
        return usesChecked ? props.checked != null : props.value != null;
      }
      function getHostProps(element, props) {
        var node = element;
        var checked = props.checked;
        var hostProps = assign({}, props, {
          defaultChecked: undefined,
          defaultValue: undefined,
          value: undefined,
          checked: checked != null ? checked : node._wrapperState.initialChecked
        });
        return hostProps;
      }
      function initWrapperState(element, props) {
        {
          checkControlledValueProps("input", props);
          if (props.checked !== undefined && props.defaultChecked !== undefined && !didWarnCheckedDefaultChecked) {
            error("%s contains an input of type %s with both checked and defaultChecked props. " + "Input elements must be either controlled or uncontrolled " + "(specify either the checked prop, or the defaultChecked prop, but not " + "both). Decide between using a controlled or uncontrolled input " + "element and remove one of these props. More info: " + "https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
            didWarnCheckedDefaultChecked = true;
          }
          if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue) {
            error("%s contains an input of type %s with both value and defaultValue props. " + "Input elements must be either controlled or uncontrolled " + "(specify either the value prop, or the defaultValue prop, but not " + "both). Decide between using a controlled or uncontrolled input " + "element and remove one of these props. More info: " + "https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component", props.type);
            didWarnValueDefaultValue = true;
          }
        }
        var node = element;
        var defaultValue = props.defaultValue == null ? "" : props.defaultValue;
        node._wrapperState = {
          initialChecked: props.checked != null ? props.checked : props.defaultChecked,
          initialValue: getToStringValue(props.value != null ? props.value : defaultValue),
          controlled: isControlled(props)
        };
      }
      function updateChecked(element, props) {
        var node = element;
        var checked = props.checked;
        if (checked != null) {
          setValueForProperty(node, "checked", checked, false);
        }
      }
      function updateWrapper(element, props) {
        var node = element;
        {
          var controlled = isControlled(props);
          if (!node._wrapperState.controlled && controlled && !didWarnUncontrolledToControlled) {
            error("A component is changing an uncontrolled input to be controlled. " + "This is likely caused by the value changing from undefined to " + "a defined value, which should not happen. " + "Decide between using a controlled or uncontrolled input " + "element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
            didWarnUncontrolledToControlled = true;
          }
          if (node._wrapperState.controlled && !controlled && !didWarnControlledToUncontrolled) {
            error("A component is changing a controlled input to be uncontrolled. " + "This is likely caused by the value changing from a defined to " + "undefined, which should not happen. " + "Decide between using a controlled or uncontrolled input " + "element for the lifetime of the component. More info: https://reactjs.org/link/controlled-components");
            didWarnControlledToUncontrolled = true;
          }
        }
        updateChecked(element, props);
        var value = getToStringValue(props.value);
        var type = props.type;
        if (value != null) {
          if (type === "number") {
            if (value === 0 && node.value === "" || node.value != value) {
              node.value = toString(value);
            }
          } else if (node.value !== toString(value)) {
            node.value = toString(value);
          }
        } else if (type === "submit" || type === "reset") {
          node.removeAttribute("value");
          return;
        }
        {
          if (props.hasOwnProperty("value")) {
            setDefaultValue(node, props.type, value);
          } else if (props.hasOwnProperty("defaultValue")) {
            setDefaultValue(node, props.type, getToStringValue(props.defaultValue));
          }
        }
        {
          if (props.checked == null && props.defaultChecked != null) {
            node.defaultChecked = !!props.defaultChecked;
          }
        }
      }
      function postMountWrapper(element, props, isHydrating2) {
        var node = element;
        if (props.hasOwnProperty("value") || props.hasOwnProperty("defaultValue")) {
          var type = props.type;
          var isButton = type === "submit" || type === "reset";
          if (isButton && (props.value === undefined || props.value === null)) {
            return;
          }
          var initialValue = toString(node._wrapperState.initialValue);
          if (!isHydrating2) {
            {
              if (initialValue !== node.value) {
                node.value = initialValue;
              }
            }
          }
          {
            node.defaultValue = initialValue;
          }
        }
        var name = node.name;
        if (name !== "") {
          node.name = "";
        }
        {
          node.defaultChecked = !node.defaultChecked;
          node.defaultChecked = !!node._wrapperState.initialChecked;
        }
        if (name !== "") {
          node.name = name;
        }
      }
      function restoreControlledState(element, props) {
        var node = element;
        updateWrapper(node, props);
        updateNamedCousins(node, props);
      }
      function updateNamedCousins(rootNode, props) {
        var name = props.name;
        if (props.type === "radio" && name != null) {
          var queryRoot = rootNode;
          while (queryRoot.parentNode) {
            queryRoot = queryRoot.parentNode;
          }
          {
            checkAttributeStringCoercion(name, "name");
          }
          var group = queryRoot.querySelectorAll("input[name=" + JSON.stringify("" + name) + '][type="radio"]');
          for (var i = 0;i < group.length; i++) {
            var otherNode = group[i];
            if (otherNode === rootNode || otherNode.form !== rootNode.form) {
              continue;
            }
            var otherProps = getFiberCurrentPropsFromNode(otherNode);
            if (!otherProps) {
              throw new Error("ReactDOMInput: Mixing React and non-React radio inputs with the " + "same `name` is not supported.");
            }
            updateValueIfChanged(otherNode);
            updateWrapper(otherNode, otherProps);
          }
        }
      }
      function setDefaultValue(node, type, value) {
        if (type !== "number" || getActiveElement(node.ownerDocument) !== node) {
          if (value == null) {
            node.defaultValue = toString(node._wrapperState.initialValue);
          } else if (node.defaultValue !== toString(value)) {
            node.defaultValue = toString(value);
          }
        }
      }
      var didWarnSelectedSetOnOption = false;
      var didWarnInvalidChild = false;
      var didWarnInvalidInnerHTML = false;
      function validateProps(element, props) {
        {
          if (props.value == null) {
            if (typeof props.children === "object" && props.children !== null) {
              React.Children.forEach(props.children, function(child) {
                if (child == null) {
                  return;
                }
                if (typeof child === "string" || typeof child === "number") {
                  return;
                }
                if (!didWarnInvalidChild) {
                  didWarnInvalidChild = true;
                  error("Cannot infer the option value of complex children. " + "Pass a `value` prop or use a plain string as children to <option>.");
                }
              });
            } else if (props.dangerouslySetInnerHTML != null) {
              if (!didWarnInvalidInnerHTML) {
                didWarnInvalidInnerHTML = true;
                error("Pass a `value` prop if you set dangerouslyInnerHTML so React knows " + "which value should be selected.");
              }
            }
          }
          if (props.selected != null && !didWarnSelectedSetOnOption) {
            error("Use the `defaultValue` or `value` props on <select> instead of " + "setting `selected` on <option>.");
            didWarnSelectedSetOnOption = true;
          }
        }
      }
      function postMountWrapper$1(element, props) {
        if (props.value != null) {
          element.setAttribute("value", toString(getToStringValue(props.value)));
        }
      }
      var isArrayImpl = Array.isArray;
      function isArray(a) {
        return isArrayImpl(a);
      }
      var didWarnValueDefaultValue$1;
      {
        didWarnValueDefaultValue$1 = false;
      }
      function getDeclarationErrorAddendum() {
        var ownerName = getCurrentFiberOwnerNameInDevOrNull();
        if (ownerName) {
          return `

Check the render method of \`` + ownerName + "`.";
        }
        return "";
      }
      var valuePropNames = ["value", "defaultValue"];
      function checkSelectPropTypes(props) {
        {
          checkControlledValueProps("select", props);
          for (var i = 0;i < valuePropNames.length; i++) {
            var propName = valuePropNames[i];
            if (props[propName] == null) {
              continue;
            }
            var propNameIsArray = isArray(props[propName]);
            if (props.multiple && !propNameIsArray) {
              error("The `%s` prop supplied to <select> must be an array if " + "`multiple` is true.%s", propName, getDeclarationErrorAddendum());
            } else if (!props.multiple && propNameIsArray) {
              error("The `%s` prop supplied to <select> must be a scalar " + "value if `multiple` is false.%s", propName, getDeclarationErrorAddendum());
            }
          }
        }
      }
      function updateOptions(node, multiple, propValue, setDefaultSelected) {
        var options2 = node.options;
        if (multiple) {
          var selectedValues = propValue;
          var selectedValue = {};
          for (var i = 0;i < selectedValues.length; i++) {
            selectedValue["$" + selectedValues[i]] = true;
          }
          for (var _i = 0;_i < options2.length; _i++) {
            var selected = selectedValue.hasOwnProperty("$" + options2[_i].value);
            if (options2[_i].selected !== selected) {
              options2[_i].selected = selected;
            }
            if (selected && setDefaultSelected) {
              options2[_i].defaultSelected = true;
            }
          }
        } else {
          var _selectedValue = toString(getToStringValue(propValue));
          var defaultSelected = null;
          for (var _i2 = 0;_i2 < options2.length; _i2++) {
            if (options2[_i2].value === _selectedValue) {
              options2[_i2].selected = true;
              if (setDefaultSelected) {
                options2[_i2].defaultSelected = true;
              }
              return;
            }
            if (defaultSelected === null && !options2[_i2].disabled) {
              defaultSelected = options2[_i2];
            }
          }
          if (defaultSelected !== null) {
            defaultSelected.selected = true;
          }
        }
      }
      function getHostProps$1(element, props) {
        return assign({}, props, {
          value: undefined
        });
      }
      function initWrapperState$1(element, props) {
        var node = element;
        {
          checkSelectPropTypes(props);
        }
        node._wrapperState = {
          wasMultiple: !!props.multiple
        };
        {
          if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValueDefaultValue$1) {
            error("Select elements must be either controlled or uncontrolled " + "(specify either the value prop, or the defaultValue prop, but not " + "both). Decide between using a controlled or uncontrolled select " + "element and remove one of these props. More info: " + "https://reactjs.org/link/controlled-components");
            didWarnValueDefaultValue$1 = true;
          }
        }
      }
      function postMountWrapper$2(element, props) {
        var node = element;
        node.multiple = !!props.multiple;
        var value = props.value;
        if (value != null) {
          updateOptions(node, !!props.multiple, value, false);
        } else if (props.defaultValue != null) {
          updateOptions(node, !!props.multiple, props.defaultValue, true);
        }
      }
      function postUpdateWrapper(element, props) {
        var node = element;
        var wasMultiple = node._wrapperState.wasMultiple;
        node._wrapperState.wasMultiple = !!props.multiple;
        var value = props.value;
        if (value != null) {
          updateOptions(node, !!props.multiple, value, false);
        } else if (wasMultiple !== !!props.multiple) {
          if (props.defaultValue != null) {
            updateOptions(node, !!props.multiple, props.defaultValue, true);
          } else {
            updateOptions(node, !!props.multiple, props.multiple ? [] : "", false);
          }
        }
      }
      function restoreControlledState$1(element, props) {
        var node = element;
        var value = props.value;
        if (value != null) {
          updateOptions(node, !!props.multiple, value, false);
        }
      }
      var didWarnValDefaultVal = false;
      function getHostProps$2(element, props) {
        var node = element;
        if (props.dangerouslySetInnerHTML != null) {
          throw new Error("`dangerouslySetInnerHTML` does not make sense on <textarea>.");
        }
        var hostProps = assign({}, props, {
          value: undefined,
          defaultValue: undefined,
          children: toString(node._wrapperState.initialValue)
        });
        return hostProps;
      }
      function initWrapperState$2(element, props) {
        var node = element;
        {
          checkControlledValueProps("textarea", props);
          if (props.value !== undefined && props.defaultValue !== undefined && !didWarnValDefaultVal) {
            error("%s contains a textarea with both value and defaultValue props. " + "Textarea elements must be either controlled or uncontrolled " + "(specify either the value prop, or the defaultValue prop, but not " + "both). Decide between using a controlled or uncontrolled textarea " + "and remove one of these props. More info: " + "https://reactjs.org/link/controlled-components", getCurrentFiberOwnerNameInDevOrNull() || "A component");
            didWarnValDefaultVal = true;
          }
        }
        var initialValue = props.value;
        if (initialValue == null) {
          var { children, defaultValue } = props;
          if (children != null) {
            {
              error("Use the `defaultValue` or `value` props instead of setting " + "children on <textarea>.");
            }
            {
              if (defaultValue != null) {
                throw new Error("If you supply `defaultValue` on a <textarea>, do not pass children.");
              }
              if (isArray(children)) {
                if (children.length > 1) {
                  throw new Error("<textarea> can only have at most one child.");
                }
                children = children[0];
              }
              defaultValue = children;
            }
          }
          if (defaultValue == null) {
            defaultValue = "";
          }
          initialValue = defaultValue;
        }
        node._wrapperState = {
          initialValue: getToStringValue(initialValue)
        };
      }
      function updateWrapper$1(element, props) {
        var node = element;
        var value = getToStringValue(props.value);
        var defaultValue = getToStringValue(props.defaultValue);
        if (value != null) {
          var newValue = toString(value);
          if (newValue !== node.value) {
            node.value = newValue;
          }
          if (props.defaultValue == null && node.defaultValue !== newValue) {
            node.defaultValue = newValue;
          }
        }
        if (defaultValue != null) {
          node.defaultValue = toString(defaultValue);
        }
      }
      function postMountWrapper$3(element, props) {
        var node = element;
        var textContent = node.textContent;
        if (textContent === node._wrapperState.initialValue) {
          if (textContent !== "" && textContent !== null) {
            node.value = textContent;
          }
        }
      }
      function restoreControlledState$2(element, props) {
        updateWrapper$1(element, props);
      }
      var HTML_NAMESPACE = "http://www.w3.org/1999/xhtml";
      var MATH_NAMESPACE = "http://www.w3.org/1998/Math/MathML";
      var SVG_NAMESPACE = "http://www.w3.org/2000/svg";
      function getIntrinsicNamespace(type) {
        switch (type) {
          case "svg":
            return SVG_NAMESPACE;
          case "math":
            return MATH_NAMESPACE;
          default:
            return HTML_NAMESPACE;
        }
      }
      function getChildNamespace(parentNamespace, type) {
        if (parentNamespace == null || parentNamespace === HTML_NAMESPACE) {
          return getIntrinsicNamespace(type);
        }
        if (parentNamespace === SVG_NAMESPACE && type === "foreignObject") {
          return HTML_NAMESPACE;
        }
        return parentNamespace;
      }
      var createMicrosoftUnsafeLocalFunction = function(func) {
        if (typeof MSApp !== "undefined" && MSApp.execUnsafeLocalFunction) {
          return function(arg0, arg1, arg2, arg3) {
            MSApp.execUnsafeLocalFunction(function() {
              return func(arg0, arg1, arg2, arg3);
            });
          };
        } else {
          return func;
        }
      };
      var reusableSVGContainer;
      var setInnerHTML = createMicrosoftUnsafeLocalFunction(function(node, html) {
        if (node.namespaceURI === SVG_NAMESPACE) {
          if (!("innerHTML" in node)) {
            reusableSVGContainer = reusableSVGContainer || document.createElement("div");
            reusableSVGContainer.innerHTML = "<svg>" + html.valueOf().toString() + "</svg>";
            var svgNode = reusableSVGContainer.firstChild;
            while (node.firstChild) {
              node.removeChild(node.firstChild);
            }
            while (svgNode.firstChild) {
              node.appendChild(svgNode.firstChild);
            }
            return;
          }
        }
        node.innerHTML = html;
      });
      var ELEMENT_NODE = 1;
      var TEXT_NODE = 3;
      var COMMENT_NODE = 8;
      var DOCUMENT_NODE = 9;
      var DOCUMENT_FRAGMENT_NODE = 11;
      var setTextContent = function(node, text) {
        if (text) {
          var firstChild = node.firstChild;
          if (firstChild && firstChild === node.lastChild && firstChild.nodeType === TEXT_NODE) {
            firstChild.nodeValue = text;
            return;
          }
        }
        node.textContent = text;
      };
      var shorthandToLonghand = {
        animation: ["animationDelay", "animationDirection", "animationDuration", "animationFillMode", "animationIterationCount", "animationName", "animationPlayState", "animationTimingFunction"],
        background: ["backgroundAttachment", "backgroundClip", "backgroundColor", "backgroundImage", "backgroundOrigin", "backgroundPositionX", "backgroundPositionY", "backgroundRepeat", "backgroundSize"],
        backgroundPosition: ["backgroundPositionX", "backgroundPositionY"],
        border: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth", "borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth", "borderLeftColor", "borderLeftStyle", "borderLeftWidth", "borderRightColor", "borderRightStyle", "borderRightWidth", "borderTopColor", "borderTopStyle", "borderTopWidth"],
        borderBlockEnd: ["borderBlockEndColor", "borderBlockEndStyle", "borderBlockEndWidth"],
        borderBlockStart: ["borderBlockStartColor", "borderBlockStartStyle", "borderBlockStartWidth"],
        borderBottom: ["borderBottomColor", "borderBottomStyle", "borderBottomWidth"],
        borderColor: ["borderBottomColor", "borderLeftColor", "borderRightColor", "borderTopColor"],
        borderImage: ["borderImageOutset", "borderImageRepeat", "borderImageSlice", "borderImageSource", "borderImageWidth"],
        borderInlineEnd: ["borderInlineEndColor", "borderInlineEndStyle", "borderInlineEndWidth"],
        borderInlineStart: ["borderInlineStartColor", "borderInlineStartStyle", "borderInlineStartWidth"],
        borderLeft: ["borderLeftColor", "borderLeftStyle", "borderLeftWidth"],
        borderRadius: ["borderBottomLeftRadius", "borderBottomRightRadius", "borderTopLeftRadius", "borderTopRightRadius"],
        borderRight: ["borderRightColor", "borderRightStyle", "borderRightWidth"],
        borderStyle: ["borderBottomStyle", "borderLeftStyle", "borderRightStyle", "borderTopStyle"],
        borderTop: ["borderTopColor", "borderTopStyle", "borderTopWidth"],
        borderWidth: ["borderBottomWidth", "borderLeftWidth", "borderRightWidth", "borderTopWidth"],
        columnRule: ["columnRuleColor", "columnRuleStyle", "columnRuleWidth"],
        columns: ["columnCount", "columnWidth"],
        flex: ["flexBasis", "flexGrow", "flexShrink"],
        flexFlow: ["flexDirection", "flexWrap"],
        font: ["fontFamily", "fontFeatureSettings", "fontKerning", "fontLanguageOverride", "fontSize", "fontSizeAdjust", "fontStretch", "fontStyle", "fontVariant", "fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition", "fontWeight", "lineHeight"],
        fontVariant: ["fontVariantAlternates", "fontVariantCaps", "fontVariantEastAsian", "fontVariantLigatures", "fontVariantNumeric", "fontVariantPosition"],
        gap: ["columnGap", "rowGap"],
        grid: ["gridAutoColumns", "gridAutoFlow", "gridAutoRows", "gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
        gridArea: ["gridColumnEnd", "gridColumnStart", "gridRowEnd", "gridRowStart"],
        gridColumn: ["gridColumnEnd", "gridColumnStart"],
        gridColumnGap: ["columnGap"],
        gridGap: ["columnGap", "rowGap"],
        gridRow: ["gridRowEnd", "gridRowStart"],
        gridRowGap: ["rowGap"],
        gridTemplate: ["gridTemplateAreas", "gridTemplateColumns", "gridTemplateRows"],
        listStyle: ["listStyleImage", "listStylePosition", "listStyleType"],
        margin: ["marginBottom", "marginLeft", "marginRight", "marginTop"],
        marker: ["markerEnd", "markerMid", "markerStart"],
        mask: ["maskClip", "maskComposite", "maskImage", "maskMode", "maskOrigin", "maskPositionX", "maskPositionY", "maskRepeat", "maskSize"],
        maskPosition: ["maskPositionX", "maskPositionY"],
        outline: ["outlineColor", "outlineStyle", "outlineWidth"],
        overflow: ["overflowX", "overflowY"],
        padding: ["paddingBottom", "paddingLeft", "paddingRight", "paddingTop"],
        placeContent: ["alignContent", "justifyContent"],
        placeItems: ["alignItems", "justifyItems"],
        placeSelf: ["alignSelf", "justifySelf"],
        textDecoration: ["textDecorationColor", "textDecorationLine", "textDecorationStyle"],
        textEmphasis: ["textEmphasisColor", "textEmphasisStyle"],
        transition: ["transitionDelay", "transitionDuration", "transitionProperty", "transitionTimingFunction"],
        wordWrap: ["overflowWrap"]
      };
      var isUnitlessNumber = {
        animationIterationCount: true,
        aspectRatio: true,
        borderImageOutset: true,
        borderImageSlice: true,
        borderImageWidth: true,
        boxFlex: true,
        boxFlexGroup: true,
        boxOrdinalGroup: true,
        columnCount: true,
        columns: true,
        flex: true,
        flexGrow: true,
        flexPositive: true,
        flexShrink: true,
        flexNegative: true,
        flexOrder: true,
        gridArea: true,
        gridRow: true,
        gridRowEnd: true,
        gridRowSpan: true,
        gridRowStart: true,
        gridColumn: true,
        gridColumnEnd: true,
        gridColumnSpan: true,
        gridColumnStart: true,
        fontWeight: true,
        lineClamp: true,
        lineHeight: true,
        opacity: true,
        order: true,
        orphans: true,
        tabSize: true,
        widows: true,
        zIndex: true,
        zoom: true,
        fillOpacity: true,
        floodOpacity: true,
        stopOpacity: true,
        strokeDasharray: true,
        strokeDashoffset: true,
        strokeMiterlimit: true,
        strokeOpacity: true,
        strokeWidth: true
      };
      function prefixKey(prefix2, key) {
        return prefix2 + key.charAt(0).toUpperCase() + key.substring(1);
      }
      var prefixes = ["Webkit", "ms", "Moz", "O"];
      Object.keys(isUnitlessNumber).forEach(function(prop) {
        prefixes.forEach(function(prefix2) {
          isUnitlessNumber[prefixKey(prefix2, prop)] = isUnitlessNumber[prop];
        });
      });
      function dangerousStyleValue(name, value, isCustomProperty) {
        var isEmpty = value == null || typeof value === "boolean" || value === "";
        if (isEmpty) {
          return "";
        }
        if (!isCustomProperty && typeof value === "number" && value !== 0 && !(isUnitlessNumber.hasOwnProperty(name) && isUnitlessNumber[name])) {
          return value + "px";
        }
        {
          checkCSSPropertyStringCoercion(value, name);
        }
        return ("" + value).trim();
      }
      var uppercasePattern = /([A-Z])/g;
      var msPattern = /^ms-/;
      function hyphenateStyleName(name) {
        return name.replace(uppercasePattern, "-$1").toLowerCase().replace(msPattern, "-ms-");
      }
      var warnValidStyle = function() {};
      {
        var badVendoredStyleNamePattern = /^(?:webkit|moz|o)[A-Z]/;
        var msPattern$1 = /^-ms-/;
        var hyphenPattern = /-(.)/g;
        var badStyleValueWithSemicolonPattern = /;\s*$/;
        var warnedStyleNames = {};
        var warnedStyleValues = {};
        var warnedForNaNValue = false;
        var warnedForInfinityValue = false;
        var camelize = function(string) {
          return string.replace(hyphenPattern, function(_, character) {
            return character.toUpperCase();
          });
        };
        var warnHyphenatedStyleName = function(name) {
          if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
            return;
          }
          warnedStyleNames[name] = true;
          error("Unsupported style property %s. Did you mean %s?", name, camelize(name.replace(msPattern$1, "ms-")));
        };
        var warnBadVendoredStyleName = function(name) {
          if (warnedStyleNames.hasOwnProperty(name) && warnedStyleNames[name]) {
            return;
          }
          warnedStyleNames[name] = true;
          error("Unsupported vendor-prefixed style property %s. Did you mean %s?", name, name.charAt(0).toUpperCase() + name.slice(1));
        };
        var warnStyleValueWithSemicolon = function(name, value) {
          if (warnedStyleValues.hasOwnProperty(value) && warnedStyleValues[value]) {
            return;
          }
          warnedStyleValues[value] = true;
          error("Style property values shouldn't contain a semicolon. " + 'Try "%s: %s" instead.', name, value.replace(badStyleValueWithSemicolonPattern, ""));
        };
        var warnStyleValueIsNaN = function(name, value) {
          if (warnedForNaNValue) {
            return;
          }
          warnedForNaNValue = true;
          error("`NaN` is an invalid value for the `%s` css style property.", name);
        };
        var warnStyleValueIsInfinity = function(name, value) {
          if (warnedForInfinityValue) {
            return;
          }
          warnedForInfinityValue = true;
          error("`Infinity` is an invalid value for the `%s` css style property.", name);
        };
        warnValidStyle = function(name, value) {
          if (name.indexOf("-") > -1) {
            warnHyphenatedStyleName(name);
          } else if (badVendoredStyleNamePattern.test(name)) {
            warnBadVendoredStyleName(name);
          } else if (badStyleValueWithSemicolonPattern.test(value)) {
            warnStyleValueWithSemicolon(name, value);
          }
          if (typeof value === "number") {
            if (isNaN(value)) {
              warnStyleValueIsNaN(name, value);
            } else if (!isFinite(value)) {
              warnStyleValueIsInfinity(name, value);
            }
          }
        };
      }
      var warnValidStyle$1 = warnValidStyle;
      function createDangerousStringForStyles(styles) {
        {
          var serialized = "";
          var delimiter = "";
          for (var styleName in styles) {
            if (!styles.hasOwnProperty(styleName)) {
              continue;
            }
            var styleValue = styles[styleName];
            if (styleValue != null) {
              var isCustomProperty = styleName.indexOf("--") === 0;
              serialized += delimiter + (isCustomProperty ? styleName : hyphenateStyleName(styleName)) + ":";
              serialized += dangerousStyleValue(styleName, styleValue, isCustomProperty);
              delimiter = ";";
            }
          }
          return serialized || null;
        }
      }
      function setValueForStyles(node, styles) {
        var style2 = node.style;
        for (var styleName in styles) {
          if (!styles.hasOwnProperty(styleName)) {
            continue;
          }
          var isCustomProperty = styleName.indexOf("--") === 0;
          {
            if (!isCustomProperty) {
              warnValidStyle$1(styleName, styles[styleName]);
            }
          }
          var styleValue = dangerousStyleValue(styleName, styles[styleName], isCustomProperty);
          if (styleName === "float") {
            styleName = "cssFloat";
          }
          if (isCustomProperty) {
            style2.setProperty(styleName, styleValue);
          } else {
            style2[styleName] = styleValue;
          }
        }
      }
      function isValueEmpty(value) {
        return value == null || typeof value === "boolean" || value === "";
      }
      function expandShorthandMap(styles) {
        var expanded = {};
        for (var key in styles) {
          var longhands = shorthandToLonghand[key] || [key];
          for (var i = 0;i < longhands.length; i++) {
            expanded[longhands[i]] = key;
          }
        }
        return expanded;
      }
      function validateShorthandPropertyCollisionInDev(styleUpdates, nextStyles) {
        {
          if (!nextStyles) {
            return;
          }
          var expandedUpdates = expandShorthandMap(styleUpdates);
          var expandedStyles = expandShorthandMap(nextStyles);
          var warnedAbout = {};
          for (var key in expandedUpdates) {
            var originalKey = expandedUpdates[key];
            var correctOriginalKey = expandedStyles[key];
            if (correctOriginalKey && originalKey !== correctOriginalKey) {
              var warningKey = originalKey + "," + correctOriginalKey;
              if (warnedAbout[warningKey]) {
                continue;
              }
              warnedAbout[warningKey] = true;
              error("%s a style property during rerender (%s) when a " + "conflicting property is set (%s) can lead to styling bugs. To " + "avoid this, don't mix shorthand and non-shorthand properties " + "for the same value; instead, replace the shorthand with " + "separate values.", isValueEmpty(styleUpdates[originalKey]) ? "Removing" : "Updating", originalKey, correctOriginalKey);
            }
          }
        }
      }
      var omittedCloseTags = {
        area: true,
        base: true,
        br: true,
        col: true,
        embed: true,
        hr: true,
        img: true,
        input: true,
        keygen: true,
        link: true,
        meta: true,
        param: true,
        source: true,
        track: true,
        wbr: true
      };
      var voidElementTags = assign({
        menuitem: true
      }, omittedCloseTags);
      var HTML = "__html";
      function assertValidProps(tag, props) {
        if (!props) {
          return;
        }
        if (voidElementTags[tag]) {
          if (props.children != null || props.dangerouslySetInnerHTML != null) {
            throw new Error(tag + " is a void element tag and must neither have `children` nor " + "use `dangerouslySetInnerHTML`.");
          }
        }
        if (props.dangerouslySetInnerHTML != null) {
          if (props.children != null) {
            throw new Error("Can only set one of `children` or `props.dangerouslySetInnerHTML`.");
          }
          if (typeof props.dangerouslySetInnerHTML !== "object" || !(HTML in props.dangerouslySetInnerHTML)) {
            throw new Error("`props.dangerouslySetInnerHTML` must be in the form `{__html: ...}`. " + "Please visit https://reactjs.org/link/dangerously-set-inner-html " + "for more information.");
          }
        }
        {
          if (!props.suppressContentEditableWarning && props.contentEditable && props.children != null) {
            error("A component is `contentEditable` and contains `children` managed by " + "React. It is now your responsibility to guarantee that none of " + "those nodes are unexpectedly modified or duplicated. This is " + "probably not intentional.");
          }
        }
        if (props.style != null && typeof props.style !== "object") {
          throw new Error("The `style` prop expects a mapping from style properties to values, " + "not a string. For example, style={{marginRight: spacing + 'em'}} when " + "using JSX.");
        }
      }
      function isCustomComponent(tagName, props) {
        if (tagName.indexOf("-") === -1) {
          return typeof props.is === "string";
        }
        switch (tagName) {
          case "annotation-xml":
          case "color-profile":
          case "font-face":
          case "font-face-src":
          case "font-face-uri":
          case "font-face-format":
          case "font-face-name":
          case "missing-glyph":
            return false;
          default:
            return true;
        }
      }
      var possibleStandardNames = {
        accept: "accept",
        acceptcharset: "acceptCharset",
        "accept-charset": "acceptCharset",
        accesskey: "accessKey",
        action: "action",
        allowfullscreen: "allowFullScreen",
        alt: "alt",
        as: "as",
        async: "async",
        autocapitalize: "autoCapitalize",
        autocomplete: "autoComplete",
        autocorrect: "autoCorrect",
        autofocus: "autoFocus",
        autoplay: "autoPlay",
        autosave: "autoSave",
        capture: "capture",
        cellpadding: "cellPadding",
        cellspacing: "cellSpacing",
        challenge: "challenge",
        charset: "charSet",
        checked: "checked",
        children: "children",
        cite: "cite",
        class: "className",
        classid: "classID",
        classname: "className",
        cols: "cols",
        colspan: "colSpan",
        content: "content",
        contenteditable: "contentEditable",
        contextmenu: "contextMenu",
        controls: "controls",
        controlslist: "controlsList",
        coords: "coords",
        crossorigin: "crossOrigin",
        dangerouslysetinnerhtml: "dangerouslySetInnerHTML",
        data: "data",
        datetime: "dateTime",
        default: "default",
        defaultchecked: "defaultChecked",
        defaultvalue: "defaultValue",
        defer: "defer",
        dir: "dir",
        disabled: "disabled",
        disablepictureinpicture: "disablePictureInPicture",
        disableremoteplayback: "disableRemotePlayback",
        download: "download",
        draggable: "draggable",
        enctype: "encType",
        enterkeyhint: "enterKeyHint",
        for: "htmlFor",
        form: "form",
        formmethod: "formMethod",
        formaction: "formAction",
        formenctype: "formEncType",
        formnovalidate: "formNoValidate",
        formtarget: "formTarget",
        frameborder: "frameBorder",
        headers: "headers",
        height: "height",
        hidden: "hidden",
        high: "high",
        href: "href",
        hreflang: "hrefLang",
        htmlfor: "htmlFor",
        httpequiv: "httpEquiv",
        "http-equiv": "httpEquiv",
        icon: "icon",
        id: "id",
        imagesizes: "imageSizes",
        imagesrcset: "imageSrcSet",
        innerhtml: "innerHTML",
        inputmode: "inputMode",
        integrity: "integrity",
        is: "is",
        itemid: "itemID",
        itemprop: "itemProp",
        itemref: "itemRef",
        itemscope: "itemScope",
        itemtype: "itemType",
        keyparams: "keyParams",
        keytype: "keyType",
        kind: "kind",
        label: "label",
        lang: "lang",
        list: "list",
        loop: "loop",
        low: "low",
        manifest: "manifest",
        marginwidth: "marginWidth",
        marginheight: "marginHeight",
        max: "max",
        maxlength: "maxLength",
        media: "media",
        mediagroup: "mediaGroup",
        method: "method",
        min: "min",
        minlength: "minLength",
        multiple: "multiple",
        muted: "muted",
        name: "name",
        nomodule: "noModule",
        nonce: "nonce",
        novalidate: "noValidate",
        open: "open",
        optimum: "optimum",
        pattern: "pattern",
        placeholder: "placeholder",
        playsinline: "playsInline",
        poster: "poster",
        preload: "preload",
        profile: "profile",
        radiogroup: "radioGroup",
        readonly: "readOnly",
        referrerpolicy: "referrerPolicy",
        rel: "rel",
        required: "required",
        reversed: "reversed",
        role: "role",
        rows: "rows",
        rowspan: "rowSpan",
        sandbox: "sandbox",
        scope: "scope",
        scoped: "scoped",
        scrolling: "scrolling",
        seamless: "seamless",
        selected: "selected",
        shape: "shape",
        size: "size",
        sizes: "sizes",
        span: "span",
        spellcheck: "spellCheck",
        src: "src",
        srcdoc: "srcDoc",
        srclang: "srcLang",
        srcset: "srcSet",
        start: "start",
        step: "step",
        style: "style",
        summary: "summary",
        tabindex: "tabIndex",
        target: "target",
        title: "title",
        type: "type",
        usemap: "useMap",
        value: "value",
        width: "width",
        wmode: "wmode",
        wrap: "wrap",
        about: "about",
        accentheight: "accentHeight",
        "accent-height": "accentHeight",
        accumulate: "accumulate",
        additive: "additive",
        alignmentbaseline: "alignmentBaseline",
        "alignment-baseline": "alignmentBaseline",
        allowreorder: "allowReorder",
        alphabetic: "alphabetic",
        amplitude: "amplitude",
        arabicform: "arabicForm",
        "arabic-form": "arabicForm",
        ascent: "ascent",
        attributename: "attributeName",
        attributetype: "attributeType",
        autoreverse: "autoReverse",
        azimuth: "azimuth",
        basefrequency: "baseFrequency",
        baselineshift: "baselineShift",
        "baseline-shift": "baselineShift",
        baseprofile: "baseProfile",
        bbox: "bbox",
        begin: "begin",
        bias: "bias",
        by: "by",
        calcmode: "calcMode",
        capheight: "capHeight",
        "cap-height": "capHeight",
        clip: "clip",
        clippath: "clipPath",
        "clip-path": "clipPath",
        clippathunits: "clipPathUnits",
        cliprule: "clipRule",
        "clip-rule": "clipRule",
        color: "color",
        colorinterpolation: "colorInterpolation",
        "color-interpolation": "colorInterpolation",
        colorinterpolationfilters: "colorInterpolationFilters",
        "color-interpolation-filters": "colorInterpolationFilters",
        colorprofile: "colorProfile",
        "color-profile": "colorProfile",
        colorrendering: "colorRendering",
        "color-rendering": "colorRendering",
        contentscripttype: "contentScriptType",
        contentstyletype: "contentStyleType",
        cursor: "cursor",
        cx: "cx",
        cy: "cy",
        d: "d",
        datatype: "datatype",
        decelerate: "decelerate",
        descent: "descent",
        diffuseconstant: "diffuseConstant",
        direction: "direction",
        display: "display",
        divisor: "divisor",
        dominantbaseline: "dominantBaseline",
        "dominant-baseline": "dominantBaseline",
        dur: "dur",
        dx: "dx",
        dy: "dy",
        edgemode: "edgeMode",
        elevation: "elevation",
        enablebackground: "enableBackground",
        "enable-background": "enableBackground",
        end: "end",
        exponent: "exponent",
        externalresourcesrequired: "externalResourcesRequired",
        fill: "fill",
        fillopacity: "fillOpacity",
        "fill-opacity": "fillOpacity",
        fillrule: "fillRule",
        "fill-rule": "fillRule",
        filter: "filter",
        filterres: "filterRes",
        filterunits: "filterUnits",
        floodopacity: "floodOpacity",
        "flood-opacity": "floodOpacity",
        floodcolor: "floodColor",
        "flood-color": "floodColor",
        focusable: "focusable",
        fontfamily: "fontFamily",
        "font-family": "fontFamily",
        fontsize: "fontSize",
        "font-size": "fontSize",
        fontsizeadjust: "fontSizeAdjust",
        "font-size-adjust": "fontSizeAdjust",
        fontstretch: "fontStretch",
        "font-stretch": "fontStretch",
        fontstyle: "fontStyle",
        "font-style": "fontStyle",
        fontvariant: "fontVariant",
        "font-variant": "fontVariant",
        fontweight: "fontWeight",
        "font-weight": "fontWeight",
        format: "format",
        from: "from",
        fx: "fx",
        fy: "fy",
        g1: "g1",
        g2: "g2",
        glyphname: "glyphName",
        "glyph-name": "glyphName",
        glyphorientationhorizontal: "glyphOrientationHorizontal",
        "glyph-orientation-horizontal": "glyphOrientationHorizontal",
        glyphorientationvertical: "glyphOrientationVertical",
        "glyph-orientation-vertical": "glyphOrientationVertical",
        glyphref: "glyphRef",
        gradienttransform: "gradientTransform",
        gradientunits: "gradientUnits",
        hanging: "hanging",
        horizadvx: "horizAdvX",
        "horiz-adv-x": "horizAdvX",
        horizoriginx: "horizOriginX",
        "horiz-origin-x": "horizOriginX",
        ideographic: "ideographic",
        imagerendering: "imageRendering",
        "image-rendering": "imageRendering",
        in2: "in2",
        in: "in",
        inlist: "inlist",
        intercept: "intercept",
        k1: "k1",
        k2: "k2",
        k3: "k3",
        k4: "k4",
        k: "k",
        kernelmatrix: "kernelMatrix",
        kernelunitlength: "kernelUnitLength",
        kerning: "kerning",
        keypoints: "keyPoints",
        keysplines: "keySplines",
        keytimes: "keyTimes",
        lengthadjust: "lengthAdjust",
        letterspacing: "letterSpacing",
        "letter-spacing": "letterSpacing",
        lightingcolor: "lightingColor",
        "lighting-color": "lightingColor",
        limitingconeangle: "limitingConeAngle",
        local: "local",
        markerend: "markerEnd",
        "marker-end": "markerEnd",
        markerheight: "markerHeight",
        markermid: "markerMid",
        "marker-mid": "markerMid",
        markerstart: "markerStart",
        "marker-start": "markerStart",
        markerunits: "markerUnits",
        markerwidth: "markerWidth",
        mask: "mask",
        maskcontentunits: "maskContentUnits",
        maskunits: "maskUnits",
        mathematical: "mathematical",
        mode: "mode",
        numoctaves: "numOctaves",
        offset: "offset",
        opacity: "opacity",
        operator: "operator",
        order: "order",
        orient: "orient",
        orientation: "orientation",
        origin: "origin",
        overflow: "overflow",
        overlineposition: "overlinePosition",
        "overline-position": "overlinePosition",
        overlinethickness: "overlineThickness",
        "overline-thickness": "overlineThickness",
        paintorder: "paintOrder",
        "paint-order": "paintOrder",
        panose1: "panose1",
        "panose-1": "panose1",
        pathlength: "pathLength",
        patterncontentunits: "patternContentUnits",
        patterntransform: "patternTransform",
        patternunits: "patternUnits",
        pointerevents: "pointerEvents",
        "pointer-events": "pointerEvents",
        points: "points",
        pointsatx: "pointsAtX",
        pointsaty: "pointsAtY",
        pointsatz: "pointsAtZ",
        prefix: "prefix",
        preservealpha: "preserveAlpha",
        preserveaspectratio: "preserveAspectRatio",
        primitiveunits: "primitiveUnits",
        property: "property",
        r: "r",
        radius: "radius",
        refx: "refX",
        refy: "refY",
        renderingintent: "renderingIntent",
        "rendering-intent": "renderingIntent",
        repeatcount: "repeatCount",
        repeatdur: "repeatDur",
        requiredextensions: "requiredExtensions",
        requiredfeatures: "requiredFeatures",
        resource: "resource",
        restart: "restart",
        result: "result",
        results: "results",
        rotate: "rotate",
        rx: "rx",
        ry: "ry",
        scale: "scale",
        security: "security",
        seed: "seed",
        shaperendering: "shapeRendering",
        "shape-rendering": "shapeRendering",
        slope: "slope",
        spacing: "spacing",
        specularconstant: "specularConstant",
        specularexponent: "specularExponent",
        speed: "speed",
        spreadmethod: "spreadMethod",
        startoffset: "startOffset",
        stddeviation: "stdDeviation",
        stemh: "stemh",
        stemv: "stemv",
        stitchtiles: "stitchTiles",
        stopcolor: "stopColor",
        "stop-color": "stopColor",
        stopopacity: "stopOpacity",
        "stop-opacity": "stopOpacity",
        strikethroughposition: "strikethroughPosition",
        "strikethrough-position": "strikethroughPosition",
        strikethroughthickness: "strikethroughThickness",
        "strikethrough-thickness": "strikethroughThickness",
        string: "string",
        stroke: "stroke",
        strokedasharray: "strokeDasharray",
        "stroke-dasharray": "strokeDasharray",
        strokedashoffset: "strokeDashoffset",
        "stroke-dashoffset": "strokeDashoffset",
        strokelinecap: "strokeLinecap",
        "stroke-linecap": "strokeLinecap",
        strokelinejoin: "strokeLinejoin",
        "stroke-linejoin": "strokeLinejoin",
        strokemiterlimit: "strokeMiterlimit",
        "stroke-miterlimit": "strokeMiterlimit",
        strokewidth: "strokeWidth",
        "stroke-width": "strokeWidth",
        strokeopacity: "strokeOpacity",
        "stroke-opacity": "strokeOpacity",
        suppresscontenteditablewarning: "suppressContentEditableWarning",
        suppresshydrationwarning: "suppressHydrationWarning",
        surfacescale: "surfaceScale",
        systemlanguage: "systemLanguage",
        tablevalues: "tableValues",
        targetx: "targetX",
        targety: "targetY",
        textanchor: "textAnchor",
        "text-anchor": "textAnchor",
        textdecoration: "textDecoration",
        "text-decoration": "textDecoration",
        textlength: "textLength",
        textrendering: "textRendering",
        "text-rendering": "textRendering",
        to: "to",
        transform: "transform",
        typeof: "typeof",
        u1: "u1",
        u2: "u2",
        underlineposition: "underlinePosition",
        "underline-position": "underlinePosition",
        underlinethickness: "underlineThickness",
        "underline-thickness": "underlineThickness",
        unicode: "unicode",
        unicodebidi: "unicodeBidi",
        "unicode-bidi": "unicodeBidi",
        unicoderange: "unicodeRange",
        "unicode-range": "unicodeRange",
        unitsperem: "unitsPerEm",
        "units-per-em": "unitsPerEm",
        unselectable: "unselectable",
        valphabetic: "vAlphabetic",
        "v-alphabetic": "vAlphabetic",
        values: "values",
        vectoreffect: "vectorEffect",
        "vector-effect": "vectorEffect",
        version: "version",
        vertadvy: "vertAdvY",
        "vert-adv-y": "vertAdvY",
        vertoriginx: "vertOriginX",
        "vert-origin-x": "vertOriginX",
        vertoriginy: "vertOriginY",
        "vert-origin-y": "vertOriginY",
        vhanging: "vHanging",
        "v-hanging": "vHanging",
        videographic: "vIdeographic",
        "v-ideographic": "vIdeographic",
        viewbox: "viewBox",
        viewtarget: "viewTarget",
        visibility: "visibility",
        vmathematical: "vMathematical",
        "v-mathematical": "vMathematical",
        vocab: "vocab",
        widths: "widths",
        wordspacing: "wordSpacing",
        "word-spacing": "wordSpacing",
        writingmode: "writingMode",
        "writing-mode": "writingMode",
        x1: "x1",
        x2: "x2",
        x: "x",
        xchannelselector: "xChannelSelector",
        xheight: "xHeight",
        "x-height": "xHeight",
        xlinkactuate: "xlinkActuate",
        "xlink:actuate": "xlinkActuate",
        xlinkarcrole: "xlinkArcrole",
        "xlink:arcrole": "xlinkArcrole",
        xlinkhref: "xlinkHref",
        "xlink:href": "xlinkHref",
        xlinkrole: "xlinkRole",
        "xlink:role": "xlinkRole",
        xlinkshow: "xlinkShow",
        "xlink:show": "xlinkShow",
        xlinktitle: "xlinkTitle",
        "xlink:title": "xlinkTitle",
        xlinktype: "xlinkType",
        "xlink:type": "xlinkType",
        xmlbase: "xmlBase",
        "xml:base": "xmlBase",
        xmllang: "xmlLang",
        "xml:lang": "xmlLang",
        xmlns: "xmlns",
        "xml:space": "xmlSpace",
        xmlnsxlink: "xmlnsXlink",
        "xmlns:xlink": "xmlnsXlink",
        xmlspace: "xmlSpace",
        y1: "y1",
        y2: "y2",
        y: "y",
        ychannelselector: "yChannelSelector",
        z: "z",
        zoomandpan: "zoomAndPan"
      };
      var ariaProperties = {
        "aria-current": 0,
        "aria-description": 0,
        "aria-details": 0,
        "aria-disabled": 0,
        "aria-hidden": 0,
        "aria-invalid": 0,
        "aria-keyshortcuts": 0,
        "aria-label": 0,
        "aria-roledescription": 0,
        "aria-autocomplete": 0,
        "aria-checked": 0,
        "aria-expanded": 0,
        "aria-haspopup": 0,
        "aria-level": 0,
        "aria-modal": 0,
        "aria-multiline": 0,
        "aria-multiselectable": 0,
        "aria-orientation": 0,
        "aria-placeholder": 0,
        "aria-pressed": 0,
        "aria-readonly": 0,
        "aria-required": 0,
        "aria-selected": 0,
        "aria-sort": 0,
        "aria-valuemax": 0,
        "aria-valuemin": 0,
        "aria-valuenow": 0,
        "aria-valuetext": 0,
        "aria-atomic": 0,
        "aria-busy": 0,
        "aria-live": 0,
        "aria-relevant": 0,
        "aria-dropeffect": 0,
        "aria-grabbed": 0,
        "aria-activedescendant": 0,
        "aria-colcount": 0,
        "aria-colindex": 0,
        "aria-colspan": 0,
        "aria-controls": 0,
        "aria-describedby": 0,
        "aria-errormessage": 0,
        "aria-flowto": 0,
        "aria-labelledby": 0,
        "aria-owns": 0,
        "aria-posinset": 0,
        "aria-rowcount": 0,
        "aria-rowindex": 0,
        "aria-rowspan": 0,
        "aria-setsize": 0
      };
      var warnedProperties = {};
      var rARIA = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
      var rARIACamel = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
      function validateProperty(tagName, name) {
        {
          if (hasOwnProperty.call(warnedProperties, name) && warnedProperties[name]) {
            return true;
          }
          if (rARIACamel.test(name)) {
            var ariaName = "aria-" + name.slice(4).toLowerCase();
            var correctName = ariaProperties.hasOwnProperty(ariaName) ? ariaName : null;
            if (correctName == null) {
              error("Invalid ARIA attribute `%s`. ARIA attributes follow the pattern aria-* and must be lowercase.", name);
              warnedProperties[name] = true;
              return true;
            }
            if (name !== correctName) {
              error("Invalid ARIA attribute `%s`. Did you mean `%s`?", name, correctName);
              warnedProperties[name] = true;
              return true;
            }
          }
          if (rARIA.test(name)) {
            var lowerCasedName = name.toLowerCase();
            var standardName = ariaProperties.hasOwnProperty(lowerCasedName) ? lowerCasedName : null;
            if (standardName == null) {
              warnedProperties[name] = true;
              return false;
            }
            if (name !== standardName) {
              error("Unknown ARIA attribute `%s`. Did you mean `%s`?", name, standardName);
              warnedProperties[name] = true;
              return true;
            }
          }
        }
        return true;
      }
      function warnInvalidARIAProps(type, props) {
        {
          var invalidProps = [];
          for (var key in props) {
            var isValid = validateProperty(type, key);
            if (!isValid) {
              invalidProps.push(key);
            }
          }
          var unknownPropString = invalidProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          if (invalidProps.length === 1) {
            error("Invalid aria prop %s on <%s> tag. " + "For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
          } else if (invalidProps.length > 1) {
            error("Invalid aria props %s on <%s> tag. " + "For details, see https://reactjs.org/link/invalid-aria-props", unknownPropString, type);
          }
        }
      }
      function validateProperties(type, props) {
        if (isCustomComponent(type, props)) {
          return;
        }
        warnInvalidARIAProps(type, props);
      }
      var didWarnValueNull = false;
      function validateProperties$1(type, props) {
        {
          if (type !== "input" && type !== "textarea" && type !== "select") {
            return;
          }
          if (props != null && props.value === null && !didWarnValueNull) {
            didWarnValueNull = true;
            if (type === "select" && props.multiple) {
              error("`value` prop on `%s` should not be null. " + "Consider using an empty array when `multiple` is set to `true` " + "to clear the component or `undefined` for uncontrolled components.", type);
            } else {
              error("`value` prop on `%s` should not be null. " + "Consider using an empty string to clear the component or `undefined` " + "for uncontrolled components.", type);
            }
          }
        }
      }
      var validateProperty$1 = function() {};
      {
        var warnedProperties$1 = {};
        var EVENT_NAME_REGEX = /^on./;
        var INVALID_EVENT_NAME_REGEX = /^on[^A-Z]/;
        var rARIA$1 = new RegExp("^(aria)-[" + ATTRIBUTE_NAME_CHAR + "]*$");
        var rARIACamel$1 = new RegExp("^(aria)[A-Z][" + ATTRIBUTE_NAME_CHAR + "]*$");
        validateProperty$1 = function(tagName, name, value, eventRegistry) {
          if (hasOwnProperty.call(warnedProperties$1, name) && warnedProperties$1[name]) {
            return true;
          }
          var lowerCasedName = name.toLowerCase();
          if (lowerCasedName === "onfocusin" || lowerCasedName === "onfocusout") {
            error("React uses onFocus and onBlur instead of onFocusIn and onFocusOut. " + "All React events are normalized to bubble, so onFocusIn and onFocusOut " + "are not needed/supported by React.");
            warnedProperties$1[name] = true;
            return true;
          }
          if (eventRegistry != null) {
            var { registrationNameDependencies: registrationNameDependencies2, possibleRegistrationNames: possibleRegistrationNames2 } = eventRegistry;
            if (registrationNameDependencies2.hasOwnProperty(name)) {
              return true;
            }
            var registrationName = possibleRegistrationNames2.hasOwnProperty(lowerCasedName) ? possibleRegistrationNames2[lowerCasedName] : null;
            if (registrationName != null) {
              error("Invalid event handler property `%s`. Did you mean `%s`?", name, registrationName);
              warnedProperties$1[name] = true;
              return true;
            }
            if (EVENT_NAME_REGEX.test(name)) {
              error("Unknown event handler property `%s`. It will be ignored.", name);
              warnedProperties$1[name] = true;
              return true;
            }
          } else if (EVENT_NAME_REGEX.test(name)) {
            if (INVALID_EVENT_NAME_REGEX.test(name)) {
              error("Invalid event handler property `%s`. " + "React events use the camelCase naming convention, for example `onClick`.", name);
            }
            warnedProperties$1[name] = true;
            return true;
          }
          if (rARIA$1.test(name) || rARIACamel$1.test(name)) {
            return true;
          }
          if (lowerCasedName === "innerhtml") {
            error("Directly setting property `innerHTML` is not permitted. " + "For more information, lookup documentation on `dangerouslySetInnerHTML`.");
            warnedProperties$1[name] = true;
            return true;
          }
          if (lowerCasedName === "aria") {
            error("The `aria` attribute is reserved for future use in React. " + "Pass individual `aria-` attributes instead.");
            warnedProperties$1[name] = true;
            return true;
          }
          if (lowerCasedName === "is" && value !== null && value !== undefined && typeof value !== "string") {
            error("Received a `%s` for a string attribute `is`. If this is expected, cast " + "the value to a string.", typeof value);
            warnedProperties$1[name] = true;
            return true;
          }
          if (typeof value === "number" && isNaN(value)) {
            error("Received NaN for the `%s` attribute. If this is expected, cast " + "the value to a string.", name);
            warnedProperties$1[name] = true;
            return true;
          }
          var propertyInfo = getPropertyInfo(name);
          var isReserved = propertyInfo !== null && propertyInfo.type === RESERVED;
          if (possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            var standardName = possibleStandardNames[lowerCasedName];
            if (standardName !== name) {
              error("Invalid DOM property `%s`. Did you mean `%s`?", name, standardName);
              warnedProperties$1[name] = true;
              return true;
            }
          } else if (!isReserved && name !== lowerCasedName) {
            error("React does not recognize the `%s` prop on a DOM element. If you " + "intentionally want it to appear in the DOM as a custom " + "attribute, spell it as lowercase `%s` instead. " + "If you accidentally passed it from a parent component, remove " + "it from the DOM element.", name, lowerCasedName);
            warnedProperties$1[name] = true;
            return true;
          }
          if (typeof value === "boolean" && shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
            if (value) {
              error("Received `%s` for a non-boolean attribute `%s`.\n\n" + "If you want to write it to the DOM, pass a string instead: " + '%s="%s" or %s={value.toString()}.', value, name, name, value, name);
            } else {
              error("Received `%s` for a non-boolean attribute `%s`.\n\n" + "If you want to write it to the DOM, pass a string instead: " + `%s="%s" or %s={value.toString()}.

` + "If you used to conditionally omit it with %s={condition && value}, " + "pass %s={condition ? value : undefined} instead.", value, name, name, value, name, name, name);
            }
            warnedProperties$1[name] = true;
            return true;
          }
          if (isReserved) {
            return true;
          }
          if (shouldRemoveAttributeWithWarning(name, value, propertyInfo, false)) {
            warnedProperties$1[name] = true;
            return false;
          }
          if ((value === "false" || value === "true") && propertyInfo !== null && propertyInfo.type === BOOLEAN) {
            error("Received the string `%s` for the boolean attribute `%s`. " + "%s " + "Did you mean %s={%s}?", value, name, value === "false" ? "The browser will interpret it as a truthy value." : 'Although this works, it will not work as expected if you pass the string "false".', name, value);
            warnedProperties$1[name] = true;
            return true;
          }
          return true;
        };
      }
      var warnUnknownProperties = function(type, props, eventRegistry) {
        {
          var unknownProps = [];
          for (var key in props) {
            var isValid = validateProperty$1(type, key, props[key], eventRegistry);
            if (!isValid) {
              unknownProps.push(key);
            }
          }
          var unknownPropString = unknownProps.map(function(prop) {
            return "`" + prop + "`";
          }).join(", ");
          if (unknownProps.length === 1) {
            error("Invalid value for prop %s on <%s> tag. Either remove it from the element, " + "or pass a string or number value to keep it in the DOM. " + "For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
          } else if (unknownProps.length > 1) {
            error("Invalid values for props %s on <%s> tag. Either remove them from the element, " + "or pass a string or number value to keep them in the DOM. " + "For details, see https://reactjs.org/link/attribute-behavior ", unknownPropString, type);
          }
        }
      };
      function validateProperties$2(type, props, eventRegistry) {
        if (isCustomComponent(type, props)) {
          return;
        }
        warnUnknownProperties(type, props, eventRegistry);
      }
      var IS_EVENT_HANDLE_NON_MANAGED_NODE = 1;
      var IS_NON_DELEGATED = 1 << 1;
      var IS_CAPTURE_PHASE = 1 << 2;
      var SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS = IS_EVENT_HANDLE_NON_MANAGED_NODE | IS_NON_DELEGATED | IS_CAPTURE_PHASE;
      var currentReplayingEvent = null;
      function setReplayingEvent(event) {
        {
          if (currentReplayingEvent !== null) {
            error("Expected currently replaying event to be null. This error " + "is likely caused by a bug in React. Please file an issue.");
          }
        }
        currentReplayingEvent = event;
      }
      function resetReplayingEvent() {
        {
          if (currentReplayingEvent === null) {
            error("Expected currently replaying event to not be null. This error " + "is likely caused by a bug in React. Please file an issue.");
          }
        }
        currentReplayingEvent = null;
      }
      function isReplayingEvent(event) {
        return event === currentReplayingEvent;
      }
      function getEventTarget(nativeEvent) {
        var target = nativeEvent.target || nativeEvent.srcElement || window;
        if (target.correspondingUseElement) {
          target = target.correspondingUseElement;
        }
        return target.nodeType === TEXT_NODE ? target.parentNode : target;
      }
      var restoreImpl = null;
      var restoreTarget = null;
      var restoreQueue = null;
      function restoreStateOfTarget(target) {
        var internalInstance = getInstanceFromNode(target);
        if (!internalInstance) {
          return;
        }
        if (typeof restoreImpl !== "function") {
          throw new Error("setRestoreImplementation() needs to be called to handle a target for controlled " + "events. This error is likely caused by a bug in React. Please file an issue.");
        }
        var stateNode = internalInstance.stateNode;
        if (stateNode) {
          var _props = getFiberCurrentPropsFromNode(stateNode);
          restoreImpl(internalInstance.stateNode, internalInstance.type, _props);
        }
      }
      function setRestoreImplementation(impl) {
        restoreImpl = impl;
      }
      function enqueueStateRestore(target) {
        if (restoreTarget) {
          if (restoreQueue) {
            restoreQueue.push(target);
          } else {
            restoreQueue = [target];
          }
        } else {
          restoreTarget = target;
        }
      }
      function needsStateRestore() {
        return restoreTarget !== null || restoreQueue !== null;
      }
      function restoreStateIfNeeded() {
        if (!restoreTarget) {
          return;
        }
        var target = restoreTarget;
        var queuedTargets = restoreQueue;
        restoreTarget = null;
        restoreQueue = null;
        restoreStateOfTarget(target);
        if (queuedTargets) {
          for (var i = 0;i < queuedTargets.length; i++) {
            restoreStateOfTarget(queuedTargets[i]);
          }
        }
      }
      var batchedUpdatesImpl = function(fn, bookkeeping) {
        return fn(bookkeeping);
      };
      var flushSyncImpl = function() {};
      var isInsideEventHandler = false;
      function finishEventHandler() {
        var controlledComponentsHavePendingUpdates = needsStateRestore();
        if (controlledComponentsHavePendingUpdates) {
          flushSyncImpl();
          restoreStateIfNeeded();
        }
      }
      function batchedUpdates(fn, a, b) {
        if (isInsideEventHandler) {
          return fn(a, b);
        }
        isInsideEventHandler = true;
        try {
          return batchedUpdatesImpl(fn, a, b);
        } finally {
          isInsideEventHandler = false;
          finishEventHandler();
        }
      }
      function setBatchingImplementation(_batchedUpdatesImpl, _discreteUpdatesImpl, _flushSyncImpl) {
        batchedUpdatesImpl = _batchedUpdatesImpl;
        flushSyncImpl = _flushSyncImpl;
      }
      function isInteractive(tag) {
        return tag === "button" || tag === "input" || tag === "select" || tag === "textarea";
      }
      function shouldPreventMouseEvent(name, type, props) {
        switch (name) {
          case "onClick":
          case "onClickCapture":
          case "onDoubleClick":
          case "onDoubleClickCapture":
          case "onMouseDown":
          case "onMouseDownCapture":
          case "onMouseMove":
          case "onMouseMoveCapture":
          case "onMouseUp":
          case "onMouseUpCapture":
          case "onMouseEnter":
            return !!(props.disabled && isInteractive(type));
          default:
            return false;
        }
      }
      function getListener(inst, registrationName) {
        var stateNode = inst.stateNode;
        if (stateNode === null) {
          return null;
        }
        var props = getFiberCurrentPropsFromNode(stateNode);
        if (props === null) {
          return null;
        }
        var listener = props[registrationName];
        if (shouldPreventMouseEvent(registrationName, inst.type, props)) {
          return null;
        }
        if (listener && typeof listener !== "function") {
          throw new Error("Expected `" + registrationName + "` listener to be a function, instead got a value of `" + typeof listener + "` type.");
        }
        return listener;
      }
      var passiveBrowserEventsSupported = false;
      if (canUseDOM) {
        try {
          var options = {};
          Object.defineProperty(options, "passive", {
            get: function() {
              passiveBrowserEventsSupported = true;
            }
          });
          window.addEventListener("test", options, options);
          window.removeEventListener("test", options, options);
        } catch (e) {
          passiveBrowserEventsSupported = false;
        }
      }
      function invokeGuardedCallbackProd(name, func, context, a, b, c, d, e, f) {
        var funcArgs = Array.prototype.slice.call(arguments, 3);
        try {
          func.apply(context, funcArgs);
        } catch (error2) {
          this.onError(error2);
        }
      }
      var invokeGuardedCallbackImpl = invokeGuardedCallbackProd;
      {
        if (typeof window !== "undefined" && typeof window.dispatchEvent === "function" && typeof document !== "undefined" && typeof document.createEvent === "function") {
          var fakeNode = document.createElement("react");
          invokeGuardedCallbackImpl = function invokeGuardedCallbackDev(name, func, context, a, b, c, d, e, f) {
            if (typeof document === "undefined" || document === null) {
              throw new Error("The `document` global was defined when React was initialized, but is not " + "defined anymore. This can happen in a test environment if a component " + "schedules an update from an asynchronous callback, but the test has already " + "finished running. To solve this, you can either unmount the component at " + "the end of your test (and ensure that any asynchronous operations get " + "canceled in `componentWillUnmount`), or you can change the test itself " + "to be asynchronous.");
            }
            var evt = document.createEvent("Event");
            var didCall = false;
            var didError = true;
            var windowEvent = window.event;
            var windowEventDescriptor = Object.getOwnPropertyDescriptor(window, "event");
            function restoreAfterDispatch() {
              fakeNode.removeEventListener(evtType, callCallback2, false);
              if (typeof window.event !== "undefined" && window.hasOwnProperty("event")) {
                window.event = windowEvent;
              }
            }
            var funcArgs = Array.prototype.slice.call(arguments, 3);
            function callCallback2() {
              didCall = true;
              restoreAfterDispatch();
              func.apply(context, funcArgs);
              didError = false;
            }
            var error2;
            var didSetError = false;
            var isCrossOriginError = false;
            function handleWindowError(event) {
              error2 = event.error;
              didSetError = true;
              if (error2 === null && event.colno === 0 && event.lineno === 0) {
                isCrossOriginError = true;
              }
              if (event.defaultPrevented) {
                if (error2 != null && typeof error2 === "object") {
                  try {
                    error2._suppressLogging = true;
                  } catch (inner) {}
                }
              }
            }
            var evtType = "react-" + (name ? name : "invokeguardedcallback");
            window.addEventListener("error", handleWindowError);
            fakeNode.addEventListener(evtType, callCallback2, false);
            evt.initEvent(evtType, false, false);
            fakeNode.dispatchEvent(evt);
            if (windowEventDescriptor) {
              Object.defineProperty(window, "event", windowEventDescriptor);
            }
            if (didCall && didError) {
              if (!didSetError) {
                error2 = new Error("An error was thrown inside one of your components, but React " + "doesn't know what it was. This is likely due to browser " + 'flakiness. React does its best to preserve the "Pause on ' + 'exceptions" behavior of the DevTools, which requires some ' + "DEV-mode only tricks. It's possible that these don't work in " + "your browser. Try triggering the error in production mode, " + "or switching to a modern browser. If you suspect that this is " + "actually an issue with React, please file an issue.");
              } else if (isCrossOriginError) {
                error2 = new Error("A cross-origin error was thrown. React doesn't have access to " + "the actual error object in development. " + "See https://reactjs.org/link/crossorigin-error for more information.");
              }
              this.onError(error2);
            }
            window.removeEventListener("error", handleWindowError);
            if (!didCall) {
              restoreAfterDispatch();
              return invokeGuardedCallbackProd.apply(this, arguments);
            }
          };
        }
      }
      var invokeGuardedCallbackImpl$1 = invokeGuardedCallbackImpl;
      var hasError = false;
      var caughtError = null;
      var hasRethrowError = false;
      var rethrowError = null;
      var reporter = {
        onError: function(error2) {
          hasError = true;
          caughtError = error2;
        }
      };
      function invokeGuardedCallback(name, func, context, a, b, c, d, e, f) {
        hasError = false;
        caughtError = null;
        invokeGuardedCallbackImpl$1.apply(reporter, arguments);
      }
      function invokeGuardedCallbackAndCatchFirstError(name, func, context, a, b, c, d, e, f) {
        invokeGuardedCallback.apply(this, arguments);
        if (hasError) {
          var error2 = clearCaughtError();
          if (!hasRethrowError) {
            hasRethrowError = true;
            rethrowError = error2;
          }
        }
      }
      function rethrowCaughtError() {
        if (hasRethrowError) {
          var error2 = rethrowError;
          hasRethrowError = false;
          rethrowError = null;
          throw error2;
        }
      }
      function hasCaughtError() {
        return hasError;
      }
      function clearCaughtError() {
        if (hasError) {
          var error2 = caughtError;
          hasError = false;
          caughtError = null;
          return error2;
        } else {
          throw new Error("clearCaughtError was called but no error was captured. This error " + "is likely caused by a bug in React. Please file an issue.");
        }
      }
      function get(key) {
        return key._reactInternals;
      }
      function has(key) {
        return key._reactInternals !== undefined;
      }
      function set(key, value) {
        key._reactInternals = value;
      }
      var NoFlags = 0;
      var PerformedWork = 1;
      var Placement = 2;
      var Update = 4;
      var ChildDeletion = 16;
      var ContentReset = 32;
      var Callback = 64;
      var DidCapture = 128;
      var ForceClientRender = 256;
      var Ref = 512;
      var Snapshot = 1024;
      var Passive = 2048;
      var Hydrating = 4096;
      var Visibility = 8192;
      var StoreConsistency = 16384;
      var LifecycleEffectMask = Passive | Update | Callback | Ref | Snapshot | StoreConsistency;
      var HostEffectMask = 32767;
      var Incomplete = 32768;
      var ShouldCapture = 65536;
      var ForceUpdateForLegacySuspense = 131072;
      var Forked = 1048576;
      var RefStatic = 2097152;
      var LayoutStatic = 4194304;
      var PassiveStatic = 8388608;
      var MountLayoutDev = 16777216;
      var MountPassiveDev = 33554432;
      var BeforeMutationMask = Update | Snapshot | 0;
      var MutationMask = Placement | Update | ChildDeletion | ContentReset | Ref | Hydrating | Visibility;
      var LayoutMask = Update | Callback | Ref | Visibility;
      var PassiveMask = Passive | ChildDeletion;
      var StaticMask = LayoutStatic | PassiveStatic | RefStatic;
      var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
      function getNearestMountedFiber(fiber) {
        var node = fiber;
        var nearestMounted = fiber;
        if (!fiber.alternate) {
          var nextNode = node;
          do {
            node = nextNode;
            if ((node.flags & (Placement | Hydrating)) !== NoFlags) {
              nearestMounted = node.return;
            }
            nextNode = node.return;
          } while (nextNode);
        } else {
          while (node.return) {
            node = node.return;
          }
        }
        if (node.tag === HostRoot) {
          return nearestMounted;
        }
        return null;
      }
      function getSuspenseInstanceFromFiber(fiber) {
        if (fiber.tag === SuspenseComponent) {
          var suspenseState = fiber.memoizedState;
          if (suspenseState === null) {
            var current2 = fiber.alternate;
            if (current2 !== null) {
              suspenseState = current2.memoizedState;
            }
          }
          if (suspenseState !== null) {
            return suspenseState.dehydrated;
          }
        }
        return null;
      }
      function getContainerFromFiber(fiber) {
        return fiber.tag === HostRoot ? fiber.stateNode.containerInfo : null;
      }
      function isFiberMounted(fiber) {
        return getNearestMountedFiber(fiber) === fiber;
      }
      function isMounted(component) {
        {
          var owner = ReactCurrentOwner.current;
          if (owner !== null && owner.tag === ClassComponent) {
            var ownerFiber = owner;
            var instance = ownerFiber.stateNode;
            if (!instance._warnedAboutRefsInRender) {
              error("%s is accessing isMounted inside its render() function. " + "render() should be a pure function of props and state. It should " + "never access something that requires stale data from the previous " + "render, such as refs. Move this logic to componentDidMount and " + "componentDidUpdate instead.", getComponentNameFromFiber(ownerFiber) || "A component");
            }
            instance._warnedAboutRefsInRender = true;
          }
        }
        var fiber = get(component);
        if (!fiber) {
          return false;
        }
        return getNearestMountedFiber(fiber) === fiber;
      }
      function assertIsMounted(fiber) {
        if (getNearestMountedFiber(fiber) !== fiber) {
          throw new Error("Unable to find node on an unmounted component.");
        }
      }
      function findCurrentFiberUsingSlowPath(fiber) {
        var alternate = fiber.alternate;
        if (!alternate) {
          var nearestMounted = getNearestMountedFiber(fiber);
          if (nearestMounted === null) {
            throw new Error("Unable to find node on an unmounted component.");
          }
          if (nearestMounted !== fiber) {
            return null;
          }
          return fiber;
        }
        var a = fiber;
        var b = alternate;
        while (true) {
          var parentA = a.return;
          if (parentA === null) {
            break;
          }
          var parentB = parentA.alternate;
          if (parentB === null) {
            var nextParent = parentA.return;
            if (nextParent !== null) {
              a = b = nextParent;
              continue;
            }
            break;
          }
          if (parentA.child === parentB.child) {
            var child = parentA.child;
            while (child) {
              if (child === a) {
                assertIsMounted(parentA);
                return fiber;
              }
              if (child === b) {
                assertIsMounted(parentA);
                return alternate;
              }
              child = child.sibling;
            }
            throw new Error("Unable to find node on an unmounted component.");
          }
          if (a.return !== b.return) {
            a = parentA;
            b = parentB;
          } else {
            var didFindChild = false;
            var _child = parentA.child;
            while (_child) {
              if (_child === a) {
                didFindChild = true;
                a = parentA;
                b = parentB;
                break;
              }
              if (_child === b) {
                didFindChild = true;
                b = parentA;
                a = parentB;
                break;
              }
              _child = _child.sibling;
            }
            if (!didFindChild) {
              _child = parentB.child;
              while (_child) {
                if (_child === a) {
                  didFindChild = true;
                  a = parentB;
                  b = parentA;
                  break;
                }
                if (_child === b) {
                  didFindChild = true;
                  b = parentB;
                  a = parentA;
                  break;
                }
                _child = _child.sibling;
              }
              if (!didFindChild) {
                throw new Error("Child was not found in either parent set. This indicates a bug " + "in React related to the return pointer. Please file an issue.");
              }
            }
          }
          if (a.alternate !== b) {
            throw new Error("Return fibers should always be each others' alternates. " + "This error is likely caused by a bug in React. Please file an issue.");
          }
        }
        if (a.tag !== HostRoot) {
          throw new Error("Unable to find node on an unmounted component.");
        }
        if (a.stateNode.current === a) {
          return fiber;
        }
        return alternate;
      }
      function findCurrentHostFiber(parent) {
        var currentParent = findCurrentFiberUsingSlowPath(parent);
        return currentParent !== null ? findCurrentHostFiberImpl(currentParent) : null;
      }
      function findCurrentHostFiberImpl(node) {
        if (node.tag === HostComponent || node.tag === HostText) {
          return node;
        }
        var child = node.child;
        while (child !== null) {
          var match = findCurrentHostFiberImpl(child);
          if (match !== null) {
            return match;
          }
          child = child.sibling;
        }
        return null;
      }
      function findCurrentHostFiberWithNoPortals(parent) {
        var currentParent = findCurrentFiberUsingSlowPath(parent);
        return currentParent !== null ? findCurrentHostFiberWithNoPortalsImpl(currentParent) : null;
      }
      function findCurrentHostFiberWithNoPortalsImpl(node) {
        if (node.tag === HostComponent || node.tag === HostText) {
          return node;
        }
        var child = node.child;
        while (child !== null) {
          if (child.tag !== HostPortal) {
            var match = findCurrentHostFiberWithNoPortalsImpl(child);
            if (match !== null) {
              return match;
            }
          }
          child = child.sibling;
        }
        return null;
      }
      var scheduleCallback = Scheduler.unstable_scheduleCallback;
      var cancelCallback = Scheduler.unstable_cancelCallback;
      var shouldYield = Scheduler.unstable_shouldYield;
      var requestPaint = Scheduler.unstable_requestPaint;
      var now = Scheduler.unstable_now;
      var getCurrentPriorityLevel = Scheduler.unstable_getCurrentPriorityLevel;
      var ImmediatePriority = Scheduler.unstable_ImmediatePriority;
      var UserBlockingPriority = Scheduler.unstable_UserBlockingPriority;
      var NormalPriority = Scheduler.unstable_NormalPriority;
      var LowPriority = Scheduler.unstable_LowPriority;
      var IdlePriority = Scheduler.unstable_IdlePriority;
      var unstable_yieldValue2 = Scheduler.unstable_yieldValue;
      var unstable_setDisableYieldValue2 = Scheduler.unstable_setDisableYieldValue;
      var rendererID = null;
      var injectedHook = null;
      var injectedProfilingHooks = null;
      var hasLoggedError = false;
      var isDevToolsPresent = typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined";
      function injectInternals(internals) {
        if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ === "undefined") {
          return false;
        }
        var hook = __REACT_DEVTOOLS_GLOBAL_HOOK__;
        if (hook.isDisabled) {
          return true;
        }
        if (!hook.supportsFiber) {
          {
            error("The installed version of React DevTools is too old and will not work " + "with the current version of React. Please update React DevTools. " + "https://reactjs.org/link/react-devtools");
          }
          return true;
        }
        try {
          if (enableSchedulingProfiler) {
            internals = assign({}, internals, {
              getLaneLabelMap,
              injectProfilingHooks
            });
          }
          rendererID = hook.inject(internals);
          injectedHook = hook;
        } catch (err) {
          {
            error("React instrumentation encountered an error: %s.", err);
          }
        }
        if (hook.checkDCE) {
          return true;
        } else {
          return false;
        }
      }
      function onScheduleRoot(root2, children) {
        {
          if (injectedHook && typeof injectedHook.onScheduleFiberRoot === "function") {
            try {
              injectedHook.onScheduleFiberRoot(rendererID, root2, children);
            } catch (err) {
              if (!hasLoggedError) {
                hasLoggedError = true;
                error("React instrumentation encountered an error: %s", err);
              }
            }
          }
        }
      }
      function onCommitRoot(root2, eventPriority) {
        if (injectedHook && typeof injectedHook.onCommitFiberRoot === "function") {
          try {
            var didError = (root2.current.flags & DidCapture) === DidCapture;
            if (enableProfilerTimer) {
              var schedulerPriority;
              switch (eventPriority) {
                case DiscreteEventPriority:
                  schedulerPriority = ImmediatePriority;
                  break;
                case ContinuousEventPriority:
                  schedulerPriority = UserBlockingPriority;
                  break;
                case DefaultEventPriority:
                  schedulerPriority = NormalPriority;
                  break;
                case IdleEventPriority:
                  schedulerPriority = IdlePriority;
                  break;
                default:
                  schedulerPriority = NormalPriority;
                  break;
              }
              injectedHook.onCommitFiberRoot(rendererID, root2, schedulerPriority, didError);
            } else {
              injectedHook.onCommitFiberRoot(rendererID, root2, undefined, didError);
            }
          } catch (err) {
            {
              if (!hasLoggedError) {
                hasLoggedError = true;
                error("React instrumentation encountered an error: %s", err);
              }
            }
          }
        }
      }
      function onPostCommitRoot(root2) {
        if (injectedHook && typeof injectedHook.onPostCommitFiberRoot === "function") {
          try {
            injectedHook.onPostCommitFiberRoot(rendererID, root2);
          } catch (err) {
            {
              if (!hasLoggedError) {
                hasLoggedError = true;
                error("React instrumentation encountered an error: %s", err);
              }
            }
          }
        }
      }
      function onCommitUnmount(fiber) {
        if (injectedHook && typeof injectedHook.onCommitFiberUnmount === "function") {
          try {
            injectedHook.onCommitFiberUnmount(rendererID, fiber);
          } catch (err) {
            {
              if (!hasLoggedError) {
                hasLoggedError = true;
                error("React instrumentation encountered an error: %s", err);
              }
            }
          }
        }
      }
      function setIsStrictModeForDevtools(newIsStrictMode) {
        {
          if (typeof unstable_yieldValue2 === "function") {
            unstable_setDisableYieldValue2(newIsStrictMode);
            setSuppressWarning(newIsStrictMode);
          }
          if (injectedHook && typeof injectedHook.setStrictMode === "function") {
            try {
              injectedHook.setStrictMode(rendererID, newIsStrictMode);
            } catch (err) {
              {
                if (!hasLoggedError) {
                  hasLoggedError = true;
                  error("React instrumentation encountered an error: %s", err);
                }
              }
            }
          }
        }
      }
      function injectProfilingHooks(profilingHooks) {
        injectedProfilingHooks = profilingHooks;
      }
      function getLaneLabelMap() {
        {
          var map = new Map;
          var lane = 1;
          for (var index2 = 0;index2 < TotalLanes; index2++) {
            var label = getLabelForLane(lane);
            map.set(lane, label);
            lane *= 2;
          }
          return map;
        }
      }
      function markCommitStarted(lanes) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStarted === "function") {
            injectedProfilingHooks.markCommitStarted(lanes);
          }
        }
      }
      function markCommitStopped() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markCommitStopped === "function") {
            injectedProfilingHooks.markCommitStopped();
          }
        }
      }
      function markComponentRenderStarted(fiber) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStarted === "function") {
            injectedProfilingHooks.markComponentRenderStarted(fiber);
          }
        }
      }
      function markComponentRenderStopped() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentRenderStopped === "function") {
            injectedProfilingHooks.markComponentRenderStopped();
          }
        }
      }
      function markComponentPassiveEffectMountStarted(fiber) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStarted === "function") {
            injectedProfilingHooks.markComponentPassiveEffectMountStarted(fiber);
          }
        }
      }
      function markComponentPassiveEffectMountStopped() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectMountStopped === "function") {
            injectedProfilingHooks.markComponentPassiveEffectMountStopped();
          }
        }
      }
      function markComponentPassiveEffectUnmountStarted(fiber) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStarted === "function") {
            injectedProfilingHooks.markComponentPassiveEffectUnmountStarted(fiber);
          }
        }
      }
      function markComponentPassiveEffectUnmountStopped() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentPassiveEffectUnmountStopped === "function") {
            injectedProfilingHooks.markComponentPassiveEffectUnmountStopped();
          }
        }
      }
      function markComponentLayoutEffectMountStarted(fiber) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStarted === "function") {
            injectedProfilingHooks.markComponentLayoutEffectMountStarted(fiber);
          }
        }
      }
      function markComponentLayoutEffectMountStopped() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectMountStopped === "function") {
            injectedProfilingHooks.markComponentLayoutEffectMountStopped();
          }
        }
      }
      function markComponentLayoutEffectUnmountStarted(fiber) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStarted === "function") {
            injectedProfilingHooks.markComponentLayoutEffectUnmountStarted(fiber);
          }
        }
      }
      function markComponentLayoutEffectUnmountStopped() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentLayoutEffectUnmountStopped === "function") {
            injectedProfilingHooks.markComponentLayoutEffectUnmountStopped();
          }
        }
      }
      function markComponentErrored(fiber, thrownValue, lanes) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentErrored === "function") {
            injectedProfilingHooks.markComponentErrored(fiber, thrownValue, lanes);
          }
        }
      }
      function markComponentSuspended(fiber, wakeable, lanes) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markComponentSuspended === "function") {
            injectedProfilingHooks.markComponentSuspended(fiber, wakeable, lanes);
          }
        }
      }
      function markLayoutEffectsStarted(lanes) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStarted === "function") {
            injectedProfilingHooks.markLayoutEffectsStarted(lanes);
          }
        }
      }
      function markLayoutEffectsStopped() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markLayoutEffectsStopped === "function") {
            injectedProfilingHooks.markLayoutEffectsStopped();
          }
        }
      }
      function markPassiveEffectsStarted(lanes) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStarted === "function") {
            injectedProfilingHooks.markPassiveEffectsStarted(lanes);
          }
        }
      }
      function markPassiveEffectsStopped() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markPassiveEffectsStopped === "function") {
            injectedProfilingHooks.markPassiveEffectsStopped();
          }
        }
      }
      function markRenderStarted(lanes) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStarted === "function") {
            injectedProfilingHooks.markRenderStarted(lanes);
          }
        }
      }
      function markRenderYielded() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderYielded === "function") {
            injectedProfilingHooks.markRenderYielded();
          }
        }
      }
      function markRenderStopped() {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderStopped === "function") {
            injectedProfilingHooks.markRenderStopped();
          }
        }
      }
      function markRenderScheduled(lane) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markRenderScheduled === "function") {
            injectedProfilingHooks.markRenderScheduled(lane);
          }
        }
      }
      function markForceUpdateScheduled(fiber, lane) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markForceUpdateScheduled === "function") {
            injectedProfilingHooks.markForceUpdateScheduled(fiber, lane);
          }
        }
      }
      function markStateUpdateScheduled(fiber, lane) {
        {
          if (injectedProfilingHooks !== null && typeof injectedProfilingHooks.markStateUpdateScheduled === "function") {
            injectedProfilingHooks.markStateUpdateScheduled(fiber, lane);
          }
        }
      }
      var NoMode = 0;
      var ConcurrentMode = 1;
      var ProfileMode = 2;
      var StrictLegacyMode = 8;
      var StrictEffectsMode = 16;
      var clz32 = Math.clz32 ? Math.clz32 : clz32Fallback;
      var log = Math.log;
      var LN2 = Math.LN2;
      function clz32Fallback(x) {
        var asUint = x >>> 0;
        if (asUint === 0) {
          return 32;
        }
        return 31 - (log(asUint) / LN2 | 0) | 0;
      }
      var TotalLanes = 31;
      var NoLanes = 0;
      var NoLane = 0;
      var SyncLane = 1;
      var InputContinuousHydrationLane = 2;
      var InputContinuousLane = 4;
      var DefaultHydrationLane = 8;
      var DefaultLane = 16;
      var TransitionHydrationLane = 32;
      var TransitionLanes = 4194240;
      var TransitionLane1 = 64;
      var TransitionLane2 = 128;
      var TransitionLane3 = 256;
      var TransitionLane4 = 512;
      var TransitionLane5 = 1024;
      var TransitionLane6 = 2048;
      var TransitionLane7 = 4096;
      var TransitionLane8 = 8192;
      var TransitionLane9 = 16384;
      var TransitionLane10 = 32768;
      var TransitionLane11 = 65536;
      var TransitionLane12 = 131072;
      var TransitionLane13 = 262144;
      var TransitionLane14 = 524288;
      var TransitionLane15 = 1048576;
      var TransitionLane16 = 2097152;
      var RetryLanes = 130023424;
      var RetryLane1 = 4194304;
      var RetryLane2 = 8388608;
      var RetryLane3 = 16777216;
      var RetryLane4 = 33554432;
      var RetryLane5 = 67108864;
      var SomeRetryLane = RetryLane1;
      var SelectiveHydrationLane = 134217728;
      var NonIdleLanes = 268435455;
      var IdleHydrationLane = 268435456;
      var IdleLane = 536870912;
      var OffscreenLane = 1073741824;
      function getLabelForLane(lane) {
        {
          if (lane & SyncLane) {
            return "Sync";
          }
          if (lane & InputContinuousHydrationLane) {
            return "InputContinuousHydration";
          }
          if (lane & InputContinuousLane) {
            return "InputContinuous";
          }
          if (lane & DefaultHydrationLane) {
            return "DefaultHydration";
          }
          if (lane & DefaultLane) {
            return "Default";
          }
          if (lane & TransitionHydrationLane) {
            return "TransitionHydration";
          }
          if (lane & TransitionLanes) {
            return "Transition";
          }
          if (lane & RetryLanes) {
            return "Retry";
          }
          if (lane & SelectiveHydrationLane) {
            return "SelectiveHydration";
          }
          if (lane & IdleHydrationLane) {
            return "IdleHydration";
          }
          if (lane & IdleLane) {
            return "Idle";
          }
          if (lane & OffscreenLane) {
            return "Offscreen";
          }
        }
      }
      var NoTimestamp = -1;
      var nextTransitionLane = TransitionLane1;
      var nextRetryLane = RetryLane1;
      function getHighestPriorityLanes(lanes) {
        switch (getHighestPriorityLane(lanes)) {
          case SyncLane:
            return SyncLane;
          case InputContinuousHydrationLane:
            return InputContinuousHydrationLane;
          case InputContinuousLane:
            return InputContinuousLane;
          case DefaultHydrationLane:
            return DefaultHydrationLane;
          case DefaultLane:
            return DefaultLane;
          case TransitionHydrationLane:
            return TransitionHydrationLane;
          case TransitionLane1:
          case TransitionLane2:
          case TransitionLane3:
          case TransitionLane4:
          case TransitionLane5:
          case TransitionLane6:
          case TransitionLane7:
          case TransitionLane8:
          case TransitionLane9:
          case TransitionLane10:
          case TransitionLane11:
          case TransitionLane12:
          case TransitionLane13:
          case TransitionLane14:
          case TransitionLane15:
          case TransitionLane16:
            return lanes & TransitionLanes;
          case RetryLane1:
          case RetryLane2:
          case RetryLane3:
          case RetryLane4:
          case RetryLane5:
            return lanes & RetryLanes;
          case SelectiveHydrationLane:
            return SelectiveHydrationLane;
          case IdleHydrationLane:
            return IdleHydrationLane;
          case IdleLane:
            return IdleLane;
          case OffscreenLane:
            return OffscreenLane;
          default:
            {
              error("Should have found matching lanes. This is a bug in React.");
            }
            return lanes;
        }
      }
      function getNextLanes(root2, wipLanes) {
        var pendingLanes = root2.pendingLanes;
        if (pendingLanes === NoLanes) {
          return NoLanes;
        }
        var nextLanes = NoLanes;
        var suspendedLanes = root2.suspendedLanes;
        var pingedLanes = root2.pingedLanes;
        var nonIdlePendingLanes = pendingLanes & NonIdleLanes;
        if (nonIdlePendingLanes !== NoLanes) {
          var nonIdleUnblockedLanes = nonIdlePendingLanes & ~suspendedLanes;
          if (nonIdleUnblockedLanes !== NoLanes) {
            nextLanes = getHighestPriorityLanes(nonIdleUnblockedLanes);
          } else {
            var nonIdlePingedLanes = nonIdlePendingLanes & pingedLanes;
            if (nonIdlePingedLanes !== NoLanes) {
              nextLanes = getHighestPriorityLanes(nonIdlePingedLanes);
            }
          }
        } else {
          var unblockedLanes = pendingLanes & ~suspendedLanes;
          if (unblockedLanes !== NoLanes) {
            nextLanes = getHighestPriorityLanes(unblockedLanes);
          } else {
            if (pingedLanes !== NoLanes) {
              nextLanes = getHighestPriorityLanes(pingedLanes);
            }
          }
        }
        if (nextLanes === NoLanes) {
          return NoLanes;
        }
        if (wipLanes !== NoLanes && wipLanes !== nextLanes && (wipLanes & suspendedLanes) === NoLanes) {
          var nextLane = getHighestPriorityLane(nextLanes);
          var wipLane = getHighestPriorityLane(wipLanes);
          if (nextLane >= wipLane || nextLane === DefaultLane && (wipLane & TransitionLanes) !== NoLanes) {
            return wipLanes;
          }
        }
        if ((nextLanes & InputContinuousLane) !== NoLanes) {
          nextLanes |= pendingLanes & DefaultLane;
        }
        var entangledLanes = root2.entangledLanes;
        if (entangledLanes !== NoLanes) {
          var entanglements = root2.entanglements;
          var lanes = nextLanes & entangledLanes;
          while (lanes > 0) {
            var index2 = pickArbitraryLaneIndex(lanes);
            var lane = 1 << index2;
            nextLanes |= entanglements[index2];
            lanes &= ~lane;
          }
        }
        return nextLanes;
      }
      function getMostRecentEventTime(root2, lanes) {
        var eventTimes = root2.eventTimes;
        var mostRecentEventTime = NoTimestamp;
        while (lanes > 0) {
          var index2 = pickArbitraryLaneIndex(lanes);
          var lane = 1 << index2;
          var eventTime = eventTimes[index2];
          if (eventTime > mostRecentEventTime) {
            mostRecentEventTime = eventTime;
          }
          lanes &= ~lane;
        }
        return mostRecentEventTime;
      }
      function computeExpirationTime(lane, currentTime) {
        switch (lane) {
          case SyncLane:
          case InputContinuousHydrationLane:
          case InputContinuousLane:
            return currentTime + 250;
          case DefaultHydrationLane:
          case DefaultLane:
          case TransitionHydrationLane:
          case TransitionLane1:
          case TransitionLane2:
          case TransitionLane3:
          case TransitionLane4:
          case TransitionLane5:
          case TransitionLane6:
          case TransitionLane7:
          case TransitionLane8:
          case TransitionLane9:
          case TransitionLane10:
          case TransitionLane11:
          case TransitionLane12:
          case TransitionLane13:
          case TransitionLane14:
          case TransitionLane15:
          case TransitionLane16:
            return currentTime + 5000;
          case RetryLane1:
          case RetryLane2:
          case RetryLane3:
          case RetryLane4:
          case RetryLane5:
            return NoTimestamp;
          case SelectiveHydrationLane:
          case IdleHydrationLane:
          case IdleLane:
          case OffscreenLane:
            return NoTimestamp;
          default:
            {
              error("Should have found matching lanes. This is a bug in React.");
            }
            return NoTimestamp;
        }
      }
      function markStarvedLanesAsExpired(root2, currentTime) {
        var pendingLanes = root2.pendingLanes;
        var suspendedLanes = root2.suspendedLanes;
        var pingedLanes = root2.pingedLanes;
        var expirationTimes = root2.expirationTimes;
        var lanes = pendingLanes;
        while (lanes > 0) {
          var index2 = pickArbitraryLaneIndex(lanes);
          var lane = 1 << index2;
          var expirationTime = expirationTimes[index2];
          if (expirationTime === NoTimestamp) {
            if ((lane & suspendedLanes) === NoLanes || (lane & pingedLanes) !== NoLanes) {
              expirationTimes[index2] = computeExpirationTime(lane, currentTime);
            }
          } else if (expirationTime <= currentTime) {
            root2.expiredLanes |= lane;
          }
          lanes &= ~lane;
        }
      }
      function getHighestPriorityPendingLanes(root2) {
        return getHighestPriorityLanes(root2.pendingLanes);
      }
      function getLanesToRetrySynchronouslyOnError(root2) {
        var everythingButOffscreen = root2.pendingLanes & ~OffscreenLane;
        if (everythingButOffscreen !== NoLanes) {
          return everythingButOffscreen;
        }
        if (everythingButOffscreen & OffscreenLane) {
          return OffscreenLane;
        }
        return NoLanes;
      }
      function includesSyncLane(lanes) {
        return (lanes & SyncLane) !== NoLanes;
      }
      function includesNonIdleWork(lanes) {
        return (lanes & NonIdleLanes) !== NoLanes;
      }
      function includesOnlyRetries(lanes) {
        return (lanes & RetryLanes) === lanes;
      }
      function includesOnlyNonUrgentLanes(lanes) {
        var UrgentLanes = SyncLane | InputContinuousLane | DefaultLane;
        return (lanes & UrgentLanes) === NoLanes;
      }
      function includesOnlyTransitions(lanes) {
        return (lanes & TransitionLanes) === lanes;
      }
      function includesBlockingLane(root2, lanes) {
        var SyncDefaultLanes = InputContinuousHydrationLane | InputContinuousLane | DefaultHydrationLane | DefaultLane;
        return (lanes & SyncDefaultLanes) !== NoLanes;
      }
      function includesExpiredLane(root2, lanes) {
        return (lanes & root2.expiredLanes) !== NoLanes;
      }
      function isTransitionLane(lane) {
        return (lane & TransitionLanes) !== NoLanes;
      }
      function claimNextTransitionLane() {
        var lane = nextTransitionLane;
        nextTransitionLane <<= 1;
        if ((nextTransitionLane & TransitionLanes) === NoLanes) {
          nextTransitionLane = TransitionLane1;
        }
        return lane;
      }
      function claimNextRetryLane() {
        var lane = nextRetryLane;
        nextRetryLane <<= 1;
        if ((nextRetryLane & RetryLanes) === NoLanes) {
          nextRetryLane = RetryLane1;
        }
        return lane;
      }
      function getHighestPriorityLane(lanes) {
        return lanes & -lanes;
      }
      function pickArbitraryLane(lanes) {
        return getHighestPriorityLane(lanes);
      }
      function pickArbitraryLaneIndex(lanes) {
        return 31 - clz32(lanes);
      }
      function laneToIndex(lane) {
        return pickArbitraryLaneIndex(lane);
      }
      function includesSomeLane(a, b) {
        return (a & b) !== NoLanes;
      }
      function isSubsetOfLanes(set2, subset) {
        return (set2 & subset) === subset;
      }
      function mergeLanes(a, b) {
        return a | b;
      }
      function removeLanes(set2, subset) {
        return set2 & ~subset;
      }
      function intersectLanes(a, b) {
        return a & b;
      }
      function laneToLanes(lane) {
        return lane;
      }
      function higherPriorityLane(a, b) {
        return a !== NoLane && a < b ? a : b;
      }
      function createLaneMap(initial) {
        var laneMap = [];
        for (var i = 0;i < TotalLanes; i++) {
          laneMap.push(initial);
        }
        return laneMap;
      }
      function markRootUpdated(root2, updateLane, eventTime) {
        root2.pendingLanes |= updateLane;
        if (updateLane !== IdleLane) {
          root2.suspendedLanes = NoLanes;
          root2.pingedLanes = NoLanes;
        }
        var eventTimes = root2.eventTimes;
        var index2 = laneToIndex(updateLane);
        eventTimes[index2] = eventTime;
      }
      function markRootSuspended(root2, suspendedLanes) {
        root2.suspendedLanes |= suspendedLanes;
        root2.pingedLanes &= ~suspendedLanes;
        var expirationTimes = root2.expirationTimes;
        var lanes = suspendedLanes;
        while (lanes > 0) {
          var index2 = pickArbitraryLaneIndex(lanes);
          var lane = 1 << index2;
          expirationTimes[index2] = NoTimestamp;
          lanes &= ~lane;
        }
      }
      function markRootPinged(root2, pingedLanes, eventTime) {
        root2.pingedLanes |= root2.suspendedLanes & pingedLanes;
      }
      function markRootFinished(root2, remainingLanes) {
        var noLongerPendingLanes = root2.pendingLanes & ~remainingLanes;
        root2.pendingLanes = remainingLanes;
        root2.suspendedLanes = NoLanes;
        root2.pingedLanes = NoLanes;
        root2.expiredLanes &= remainingLanes;
        root2.mutableReadLanes &= remainingLanes;
        root2.entangledLanes &= remainingLanes;
        var entanglements = root2.entanglements;
        var eventTimes = root2.eventTimes;
        var expirationTimes = root2.expirationTimes;
        var lanes = noLongerPendingLanes;
        while (lanes > 0) {
          var index2 = pickArbitraryLaneIndex(lanes);
          var lane = 1 << index2;
          entanglements[index2] = NoLanes;
          eventTimes[index2] = NoTimestamp;
          expirationTimes[index2] = NoTimestamp;
          lanes &= ~lane;
        }
      }
      function markRootEntangled(root2, entangledLanes) {
        var rootEntangledLanes = root2.entangledLanes |= entangledLanes;
        var entanglements = root2.entanglements;
        var lanes = rootEntangledLanes;
        while (lanes) {
          var index2 = pickArbitraryLaneIndex(lanes);
          var lane = 1 << index2;
          if (lane & entangledLanes | entanglements[index2] & entangledLanes) {
            entanglements[index2] |= entangledLanes;
          }
          lanes &= ~lane;
        }
      }
      function getBumpedLaneForHydration(root2, renderLanes2) {
        var renderLane = getHighestPriorityLane(renderLanes2);
        var lane;
        switch (renderLane) {
          case InputContinuousLane:
            lane = InputContinuousHydrationLane;
            break;
          case DefaultLane:
            lane = DefaultHydrationLane;
            break;
          case TransitionLane1:
          case TransitionLane2:
          case TransitionLane3:
          case TransitionLane4:
          case TransitionLane5:
          case TransitionLane6:
          case TransitionLane7:
          case TransitionLane8:
          case TransitionLane9:
          case TransitionLane10:
          case TransitionLane11:
          case TransitionLane12:
          case TransitionLane13:
          case TransitionLane14:
          case TransitionLane15:
          case TransitionLane16:
          case RetryLane1:
          case RetryLane2:
          case RetryLane3:
          case RetryLane4:
          case RetryLane5:
            lane = TransitionHydrationLane;
            break;
          case IdleLane:
            lane = IdleHydrationLane;
            break;
          default:
            lane = NoLane;
            break;
        }
        if ((lane & (root2.suspendedLanes | renderLanes2)) !== NoLane) {
          return NoLane;
        }
        return lane;
      }
      function addFiberToLanesMap(root2, fiber, lanes) {
        if (!isDevToolsPresent) {
          return;
        }
        var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap;
        while (lanes > 0) {
          var index2 = laneToIndex(lanes);
          var lane = 1 << index2;
          var updaters = pendingUpdatersLaneMap[index2];
          updaters.add(fiber);
          lanes &= ~lane;
        }
      }
      function movePendingFibersToMemoized(root2, lanes) {
        if (!isDevToolsPresent) {
          return;
        }
        var pendingUpdatersLaneMap = root2.pendingUpdatersLaneMap;
        var memoizedUpdaters = root2.memoizedUpdaters;
        while (lanes > 0) {
          var index2 = laneToIndex(lanes);
          var lane = 1 << index2;
          var updaters = pendingUpdatersLaneMap[index2];
          if (updaters.size > 0) {
            updaters.forEach(function(fiber) {
              var alternate = fiber.alternate;
              if (alternate === null || !memoizedUpdaters.has(alternate)) {
                memoizedUpdaters.add(fiber);
              }
            });
            updaters.clear();
          }
          lanes &= ~lane;
        }
      }
      function getTransitionsForLanes(root2, lanes) {
        {
          return null;
        }
      }
      var DiscreteEventPriority = SyncLane;
      var ContinuousEventPriority = InputContinuousLane;
      var DefaultEventPriority = DefaultLane;
      var IdleEventPriority = IdleLane;
      var currentUpdatePriority = NoLane;
      function getCurrentUpdatePriority() {
        return currentUpdatePriority;
      }
      function setCurrentUpdatePriority(newPriority) {
        currentUpdatePriority = newPriority;
      }
      function runWithPriority(priority, fn) {
        var previousPriority = currentUpdatePriority;
        try {
          currentUpdatePriority = priority;
          return fn();
        } finally {
          currentUpdatePriority = previousPriority;
        }
      }
      function higherEventPriority(a, b) {
        return a !== 0 && a < b ? a : b;
      }
      function lowerEventPriority(a, b) {
        return a === 0 || a > b ? a : b;
      }
      function isHigherEventPriority(a, b) {
        return a !== 0 && a < b;
      }
      function lanesToEventPriority(lanes) {
        var lane = getHighestPriorityLane(lanes);
        if (!isHigherEventPriority(DiscreteEventPriority, lane)) {
          return DiscreteEventPriority;
        }
        if (!isHigherEventPriority(ContinuousEventPriority, lane)) {
          return ContinuousEventPriority;
        }
        if (includesNonIdleWork(lane)) {
          return DefaultEventPriority;
        }
        return IdleEventPriority;
      }
      function isRootDehydrated(root2) {
        var currentState = root2.current.memoizedState;
        return currentState.isDehydrated;
      }
      var _attemptSynchronousHydration;
      function setAttemptSynchronousHydration(fn) {
        _attemptSynchronousHydration = fn;
      }
      function attemptSynchronousHydration(fiber) {
        _attemptSynchronousHydration(fiber);
      }
      var attemptContinuousHydration;
      function setAttemptContinuousHydration(fn) {
        attemptContinuousHydration = fn;
      }
      var attemptHydrationAtCurrentPriority;
      function setAttemptHydrationAtCurrentPriority(fn) {
        attemptHydrationAtCurrentPriority = fn;
      }
      var getCurrentUpdatePriority$1;
      function setGetCurrentUpdatePriority(fn) {
        getCurrentUpdatePriority$1 = fn;
      }
      var attemptHydrationAtPriority;
      function setAttemptHydrationAtPriority(fn) {
        attemptHydrationAtPriority = fn;
      }
      var hasScheduledReplayAttempt = false;
      var queuedDiscreteEvents = [];
      var queuedFocus = null;
      var queuedDrag = null;
      var queuedMouse = null;
      var queuedPointers = new Map;
      var queuedPointerCaptures = new Map;
      var queuedExplicitHydrationTargets = [];
      var discreteReplayableEvents = [
        "mousedown",
        "mouseup",
        "touchcancel",
        "touchend",
        "touchstart",
        "auxclick",
        "dblclick",
        "pointercancel",
        "pointerdown",
        "pointerup",
        "dragend",
        "dragstart",
        "drop",
        "compositionend",
        "compositionstart",
        "keydown",
        "keypress",
        "keyup",
        "input",
        "textInput",
        "copy",
        "cut",
        "paste",
        "click",
        "change",
        "contextmenu",
        "reset",
        "submit"
      ];
      function isDiscreteEventThatRequiresHydration(eventType) {
        return discreteReplayableEvents.indexOf(eventType) > -1;
      }
      function createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        return {
          blockedOn,
          domEventName,
          eventSystemFlags,
          nativeEvent,
          targetContainers: [targetContainer]
        };
      }
      function clearIfContinuousEvent(domEventName, nativeEvent) {
        switch (domEventName) {
          case "focusin":
          case "focusout":
            queuedFocus = null;
            break;
          case "dragenter":
          case "dragleave":
            queuedDrag = null;
            break;
          case "mouseover":
          case "mouseout":
            queuedMouse = null;
            break;
          case "pointerover":
          case "pointerout": {
            var pointerId = nativeEvent.pointerId;
            queuedPointers.delete(pointerId);
            break;
          }
          case "gotpointercapture":
          case "lostpointercapture": {
            var _pointerId = nativeEvent.pointerId;
            queuedPointerCaptures.delete(_pointerId);
            break;
          }
        }
      }
      function accumulateOrCreateContinuousQueuedReplayableEvent(existingQueuedEvent, blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (existingQueuedEvent === null || existingQueuedEvent.nativeEvent !== nativeEvent) {
          var queuedEvent = createQueuedReplayableEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent);
          if (blockedOn !== null) {
            var _fiber2 = getInstanceFromNode(blockedOn);
            if (_fiber2 !== null) {
              attemptContinuousHydration(_fiber2);
            }
          }
          return queuedEvent;
        }
        existingQueuedEvent.eventSystemFlags |= eventSystemFlags;
        var targetContainers = existingQueuedEvent.targetContainers;
        if (targetContainer !== null && targetContainers.indexOf(targetContainer) === -1) {
          targetContainers.push(targetContainer);
        }
        return existingQueuedEvent;
      }
      function queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        switch (domEventName) {
          case "focusin": {
            var focusEvent = nativeEvent;
            queuedFocus = accumulateOrCreateContinuousQueuedReplayableEvent(queuedFocus, blockedOn, domEventName, eventSystemFlags, targetContainer, focusEvent);
            return true;
          }
          case "dragenter": {
            var dragEvent = nativeEvent;
            queuedDrag = accumulateOrCreateContinuousQueuedReplayableEvent(queuedDrag, blockedOn, domEventName, eventSystemFlags, targetContainer, dragEvent);
            return true;
          }
          case "mouseover": {
            var mouseEvent = nativeEvent;
            queuedMouse = accumulateOrCreateContinuousQueuedReplayableEvent(queuedMouse, blockedOn, domEventName, eventSystemFlags, targetContainer, mouseEvent);
            return true;
          }
          case "pointerover": {
            var pointerEvent = nativeEvent;
            var pointerId = pointerEvent.pointerId;
            queuedPointers.set(pointerId, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointers.get(pointerId) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, pointerEvent));
            return true;
          }
          case "gotpointercapture": {
            var _pointerEvent = nativeEvent;
            var _pointerId2 = _pointerEvent.pointerId;
            queuedPointerCaptures.set(_pointerId2, accumulateOrCreateContinuousQueuedReplayableEvent(queuedPointerCaptures.get(_pointerId2) || null, blockedOn, domEventName, eventSystemFlags, targetContainer, _pointerEvent));
            return true;
          }
        }
        return false;
      }
      function attemptExplicitHydrationTarget(queuedTarget) {
        var targetInst = getClosestInstanceFromNode(queuedTarget.target);
        if (targetInst !== null) {
          var nearestMounted = getNearestMountedFiber(targetInst);
          if (nearestMounted !== null) {
            var tag = nearestMounted.tag;
            if (tag === SuspenseComponent) {
              var instance = getSuspenseInstanceFromFiber(nearestMounted);
              if (instance !== null) {
                queuedTarget.blockedOn = instance;
                attemptHydrationAtPriority(queuedTarget.priority, function() {
                  attemptHydrationAtCurrentPriority(nearestMounted);
                });
                return;
              }
            } else if (tag === HostRoot) {
              var root2 = nearestMounted.stateNode;
              if (isRootDehydrated(root2)) {
                queuedTarget.blockedOn = getContainerFromFiber(nearestMounted);
                return;
              }
            }
          }
        }
        queuedTarget.blockedOn = null;
      }
      function queueExplicitHydrationTarget(target) {
        var updatePriority = getCurrentUpdatePriority$1();
        var queuedTarget = {
          blockedOn: null,
          target,
          priority: updatePriority
        };
        var i = 0;
        for (;i < queuedExplicitHydrationTargets.length; i++) {
          if (!isHigherEventPriority(updatePriority, queuedExplicitHydrationTargets[i].priority)) {
            break;
          }
        }
        queuedExplicitHydrationTargets.splice(i, 0, queuedTarget);
        if (i === 0) {
          attemptExplicitHydrationTarget(queuedTarget);
        }
      }
      function attemptReplayContinuousQueuedEvent(queuedEvent) {
        if (queuedEvent.blockedOn !== null) {
          return false;
        }
        var targetContainers = queuedEvent.targetContainers;
        while (targetContainers.length > 0) {
          var targetContainer = targetContainers[0];
          var nextBlockedOn = findInstanceBlockingEvent(queuedEvent.domEventName, queuedEvent.eventSystemFlags, targetContainer, queuedEvent.nativeEvent);
          if (nextBlockedOn === null) {
            {
              var nativeEvent = queuedEvent.nativeEvent;
              var nativeEventClone = new nativeEvent.constructor(nativeEvent.type, nativeEvent);
              setReplayingEvent(nativeEventClone);
              nativeEvent.target.dispatchEvent(nativeEventClone);
              resetReplayingEvent();
            }
          } else {
            var _fiber3 = getInstanceFromNode(nextBlockedOn);
            if (_fiber3 !== null) {
              attemptContinuousHydration(_fiber3);
            }
            queuedEvent.blockedOn = nextBlockedOn;
            return false;
          }
          targetContainers.shift();
        }
        return true;
      }
      function attemptReplayContinuousQueuedEventInMap(queuedEvent, key, map) {
        if (attemptReplayContinuousQueuedEvent(queuedEvent)) {
          map.delete(key);
        }
      }
      function replayUnblockedEvents() {
        hasScheduledReplayAttempt = false;
        if (queuedFocus !== null && attemptReplayContinuousQueuedEvent(queuedFocus)) {
          queuedFocus = null;
        }
        if (queuedDrag !== null && attemptReplayContinuousQueuedEvent(queuedDrag)) {
          queuedDrag = null;
        }
        if (queuedMouse !== null && attemptReplayContinuousQueuedEvent(queuedMouse)) {
          queuedMouse = null;
        }
        queuedPointers.forEach(attemptReplayContinuousQueuedEventInMap);
        queuedPointerCaptures.forEach(attemptReplayContinuousQueuedEventInMap);
      }
      function scheduleCallbackIfUnblocked(queuedEvent, unblocked) {
        if (queuedEvent.blockedOn === unblocked) {
          queuedEvent.blockedOn = null;
          if (!hasScheduledReplayAttempt) {
            hasScheduledReplayAttempt = true;
            Scheduler.unstable_scheduleCallback(Scheduler.unstable_NormalPriority, replayUnblockedEvents);
          }
        }
      }
      function retryIfBlockedOn(unblocked) {
        if (queuedDiscreteEvents.length > 0) {
          scheduleCallbackIfUnblocked(queuedDiscreteEvents[0], unblocked);
          for (var i = 1;i < queuedDiscreteEvents.length; i++) {
            var queuedEvent = queuedDiscreteEvents[i];
            if (queuedEvent.blockedOn === unblocked) {
              queuedEvent.blockedOn = null;
            }
          }
        }
        if (queuedFocus !== null) {
          scheduleCallbackIfUnblocked(queuedFocus, unblocked);
        }
        if (queuedDrag !== null) {
          scheduleCallbackIfUnblocked(queuedDrag, unblocked);
        }
        if (queuedMouse !== null) {
          scheduleCallbackIfUnblocked(queuedMouse, unblocked);
        }
        var unblock = function(queuedEvent2) {
          return scheduleCallbackIfUnblocked(queuedEvent2, unblocked);
        };
        queuedPointers.forEach(unblock);
        queuedPointerCaptures.forEach(unblock);
        for (var _i = 0;_i < queuedExplicitHydrationTargets.length; _i++) {
          var queuedTarget = queuedExplicitHydrationTargets[_i];
          if (queuedTarget.blockedOn === unblocked) {
            queuedTarget.blockedOn = null;
          }
        }
        while (queuedExplicitHydrationTargets.length > 0) {
          var nextExplicitTarget = queuedExplicitHydrationTargets[0];
          if (nextExplicitTarget.blockedOn !== null) {
            break;
          } else {
            attemptExplicitHydrationTarget(nextExplicitTarget);
            if (nextExplicitTarget.blockedOn === null) {
              queuedExplicitHydrationTargets.shift();
            }
          }
        }
      }
      var ReactCurrentBatchConfig = ReactSharedInternals.ReactCurrentBatchConfig;
      var _enabled = true;
      function setEnabled(enabled) {
        _enabled = !!enabled;
      }
      function isEnabled() {
        return _enabled;
      }
      function createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags) {
        var eventPriority = getEventPriority(domEventName);
        var listenerWrapper;
        switch (eventPriority) {
          case DiscreteEventPriority:
            listenerWrapper = dispatchDiscreteEvent;
            break;
          case ContinuousEventPriority:
            listenerWrapper = dispatchContinuousEvent;
            break;
          case DefaultEventPriority:
          default:
            listenerWrapper = dispatchEvent;
            break;
        }
        return listenerWrapper.bind(null, domEventName, eventSystemFlags, targetContainer);
      }
      function dispatchDiscreteEvent(domEventName, eventSystemFlags, container, nativeEvent) {
        var previousPriority = getCurrentUpdatePriority();
        var prevTransition = ReactCurrentBatchConfig.transition;
        ReactCurrentBatchConfig.transition = null;
        try {
          setCurrentUpdatePriority(DiscreteEventPriority);
          dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
        } finally {
          setCurrentUpdatePriority(previousPriority);
          ReactCurrentBatchConfig.transition = prevTransition;
        }
      }
      function dispatchContinuousEvent(domEventName, eventSystemFlags, container, nativeEvent) {
        var previousPriority = getCurrentUpdatePriority();
        var prevTransition = ReactCurrentBatchConfig.transition;
        ReactCurrentBatchConfig.transition = null;
        try {
          setCurrentUpdatePriority(ContinuousEventPriority);
          dispatchEvent(domEventName, eventSystemFlags, container, nativeEvent);
        } finally {
          setCurrentUpdatePriority(previousPriority);
          ReactCurrentBatchConfig.transition = prevTransition;
        }
      }
      function dispatchEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        if (!_enabled) {
          return;
        }
        {
          dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent);
        }
      }
      function dispatchEventWithEnableCapturePhaseSelectiveHydrationWithoutDiscreteEventReplay(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        var blockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
        if (blockedOn === null) {
          dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
          clearIfContinuousEvent(domEventName, nativeEvent);
          return;
        }
        if (queueIfContinuousEvent(blockedOn, domEventName, eventSystemFlags, targetContainer, nativeEvent)) {
          nativeEvent.stopPropagation();
          return;
        }
        clearIfContinuousEvent(domEventName, nativeEvent);
        if (eventSystemFlags & IS_CAPTURE_PHASE && isDiscreteEventThatRequiresHydration(domEventName)) {
          while (blockedOn !== null) {
            var fiber = getInstanceFromNode(blockedOn);
            if (fiber !== null) {
              attemptSynchronousHydration(fiber);
            }
            var nextBlockedOn = findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent);
            if (nextBlockedOn === null) {
              dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, return_targetInst, targetContainer);
            }
            if (nextBlockedOn === blockedOn) {
              break;
            }
            blockedOn = nextBlockedOn;
          }
          if (blockedOn !== null) {
            nativeEvent.stopPropagation();
          }
          return;
        }
        dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, null, targetContainer);
      }
      var return_targetInst = null;
      function findInstanceBlockingEvent(domEventName, eventSystemFlags, targetContainer, nativeEvent) {
        return_targetInst = null;
        var nativeEventTarget = getEventTarget(nativeEvent);
        var targetInst = getClosestInstanceFromNode(nativeEventTarget);
        if (targetInst !== null) {
          var nearestMounted = getNearestMountedFiber(targetInst);
          if (nearestMounted === null) {
            targetInst = null;
          } else {
            var tag = nearestMounted.tag;
            if (tag === SuspenseComponent) {
              var instance = getSuspenseInstanceFromFiber(nearestMounted);
              if (instance !== null) {
                return instance;
              }
              targetInst = null;
            } else if (tag === HostRoot) {
              var root2 = nearestMounted.stateNode;
              if (isRootDehydrated(root2)) {
                return getContainerFromFiber(nearestMounted);
              }
              targetInst = null;
            } else if (nearestMounted !== targetInst) {
              targetInst = null;
            }
          }
        }
        return_targetInst = targetInst;
        return null;
      }
      function getEventPriority(domEventName) {
        switch (domEventName) {
          case "cancel":
          case "click":
          case "close":
          case "contextmenu":
          case "copy":
          case "cut":
          case "auxclick":
          case "dblclick":
          case "dragend":
          case "dragstart":
          case "drop":
          case "focusin":
          case "focusout":
          case "input":
          case "invalid":
          case "keydown":
          case "keypress":
          case "keyup":
          case "mousedown":
          case "mouseup":
          case "paste":
          case "pause":
          case "play":
          case "pointercancel":
          case "pointerdown":
          case "pointerup":
          case "ratechange":
          case "reset":
          case "resize":
          case "seeked":
          case "submit":
          case "touchcancel":
          case "touchend":
          case "touchstart":
          case "volumechange":
          case "change":
          case "selectionchange":
          case "textInput":
          case "compositionstart":
          case "compositionend":
          case "compositionupdate":
          case "beforeblur":
          case "afterblur":
          case "beforeinput":
          case "blur":
          case "fullscreenchange":
          case "focus":
          case "hashchange":
          case "popstate":
          case "select":
          case "selectstart":
            return DiscreteEventPriority;
          case "drag":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "mousemove":
          case "mouseout":
          case "mouseover":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "scroll":
          case "toggle":
          case "touchmove":
          case "wheel":
          case "mouseenter":
          case "mouseleave":
          case "pointerenter":
          case "pointerleave":
            return ContinuousEventPriority;
          case "message": {
            var schedulerPriority = getCurrentPriorityLevel();
            switch (schedulerPriority) {
              case ImmediatePriority:
                return DiscreteEventPriority;
              case UserBlockingPriority:
                return ContinuousEventPriority;
              case NormalPriority:
              case LowPriority:
                return DefaultEventPriority;
              case IdlePriority:
                return IdleEventPriority;
              default:
                return DefaultEventPriority;
            }
          }
          default:
            return DefaultEventPriority;
        }
      }
      function addEventBubbleListener(target, eventType, listener) {
        target.addEventListener(eventType, listener, false);
        return listener;
      }
      function addEventCaptureListener(target, eventType, listener) {
        target.addEventListener(eventType, listener, true);
        return listener;
      }
      function addEventCaptureListenerWithPassiveFlag(target, eventType, listener, passive) {
        target.addEventListener(eventType, listener, {
          capture: true,
          passive
        });
        return listener;
      }
      function addEventBubbleListenerWithPassiveFlag(target, eventType, listener, passive) {
        target.addEventListener(eventType, listener, {
          passive
        });
        return listener;
      }
      var root = null;
      var startText = null;
      var fallbackText = null;
      function initialize(nativeEventTarget) {
        root = nativeEventTarget;
        startText = getText();
        return true;
      }
      function reset() {
        root = null;
        startText = null;
        fallbackText = null;
      }
      function getData() {
        if (fallbackText) {
          return fallbackText;
        }
        var start;
        var startValue = startText;
        var startLength = startValue.length;
        var end;
        var endValue = getText();
        var endLength = endValue.length;
        for (start = 0;start < startLength; start++) {
          if (startValue[start] !== endValue[start]) {
            break;
          }
        }
        var minEnd = startLength - start;
        for (end = 1;end <= minEnd; end++) {
          if (startValue[startLength - end] !== endValue[endLength - end]) {
            break;
          }
        }
        var sliceTail = end > 1 ? 1 - end : undefined;
        fallbackText = endValue.slice(start, sliceTail);
        return fallbackText;
      }
      function getText() {
        if ("value" in root) {
          return root.value;
        }
        return root.textContent;
      }
      function getEventCharCode(nativeEvent) {
        var charCode;
        var keyCode = nativeEvent.keyCode;
        if ("charCode" in nativeEvent) {
          charCode = nativeEvent.charCode;
          if (charCode === 0 && keyCode === 13) {
            charCode = 13;
          }
        } else {
          charCode = keyCode;
        }
        if (charCode === 10) {
          charCode = 13;
        }
        if (charCode >= 32 || charCode === 13) {
          return charCode;
        }
        return 0;
      }
      function functionThatReturnsTrue() {
        return true;
      }
      function functionThatReturnsFalse() {
        return false;
      }
      function createSyntheticEvent(Interface) {
        function SyntheticBaseEvent(reactName, reactEventType, targetInst, nativeEvent, nativeEventTarget) {
          this._reactName = reactName;
          this._targetInst = targetInst;
          this.type = reactEventType;
          this.nativeEvent = nativeEvent;
          this.target = nativeEventTarget;
          this.currentTarget = null;
          for (var _propName in Interface) {
            if (!Interface.hasOwnProperty(_propName)) {
              continue;
            }
            var normalize = Interface[_propName];
            if (normalize) {
              this[_propName] = normalize(nativeEvent);
            } else {
              this[_propName] = nativeEvent[_propName];
            }
          }
          var defaultPrevented = nativeEvent.defaultPrevented != null ? nativeEvent.defaultPrevented : nativeEvent.returnValue === false;
          if (defaultPrevented) {
            this.isDefaultPrevented = functionThatReturnsTrue;
          } else {
            this.isDefaultPrevented = functionThatReturnsFalse;
          }
          this.isPropagationStopped = functionThatReturnsFalse;
          return this;
        }
        assign(SyntheticBaseEvent.prototype, {
          preventDefault: function() {
            this.defaultPrevented = true;
            var event = this.nativeEvent;
            if (!event) {
              return;
            }
            if (event.preventDefault) {
              event.preventDefault();
            } else if (typeof event.returnValue !== "unknown") {
              event.returnValue = false;
            }
            this.isDefaultPrevented = functionThatReturnsTrue;
          },
          stopPropagation: function() {
            var event = this.nativeEvent;
            if (!event) {
              return;
            }
            if (event.stopPropagation) {
              event.stopPropagation();
            } else if (typeof event.cancelBubble !== "unknown") {
              event.cancelBubble = true;
            }
            this.isPropagationStopped = functionThatReturnsTrue;
          },
          persist: function() {},
          isPersistent: functionThatReturnsTrue
        });
        return SyntheticBaseEvent;
      }
      var EventInterface = {
        eventPhase: 0,
        bubbles: 0,
        cancelable: 0,
        timeStamp: function(event) {
          return event.timeStamp || Date.now();
        },
        defaultPrevented: 0,
        isTrusted: 0
      };
      var SyntheticEvent = createSyntheticEvent(EventInterface);
      var UIEventInterface = assign({}, EventInterface, {
        view: 0,
        detail: 0
      });
      var SyntheticUIEvent = createSyntheticEvent(UIEventInterface);
      var lastMovementX;
      var lastMovementY;
      var lastMouseEvent;
      function updateMouseMovementPolyfillState(event) {
        if (event !== lastMouseEvent) {
          if (lastMouseEvent && event.type === "mousemove") {
            lastMovementX = event.screenX - lastMouseEvent.screenX;
            lastMovementY = event.screenY - lastMouseEvent.screenY;
          } else {
            lastMovementX = 0;
            lastMovementY = 0;
          }
          lastMouseEvent = event;
        }
      }
      var MouseEventInterface = assign({}, UIEventInterface, {
        screenX: 0,
        screenY: 0,
        clientX: 0,
        clientY: 0,
        pageX: 0,
        pageY: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        getModifierState: getEventModifierState,
        button: 0,
        buttons: 0,
        relatedTarget: function(event) {
          if (event.relatedTarget === undefined)
            return event.fromElement === event.srcElement ? event.toElement : event.fromElement;
          return event.relatedTarget;
        },
        movementX: function(event) {
          if ("movementX" in event) {
            return event.movementX;
          }
          updateMouseMovementPolyfillState(event);
          return lastMovementX;
        },
        movementY: function(event) {
          if ("movementY" in event) {
            return event.movementY;
          }
          return lastMovementY;
        }
      });
      var SyntheticMouseEvent = createSyntheticEvent(MouseEventInterface);
      var DragEventInterface = assign({}, MouseEventInterface, {
        dataTransfer: 0
      });
      var SyntheticDragEvent = createSyntheticEvent(DragEventInterface);
      var FocusEventInterface = assign({}, UIEventInterface, {
        relatedTarget: 0
      });
      var SyntheticFocusEvent = createSyntheticEvent(FocusEventInterface);
      var AnimationEventInterface = assign({}, EventInterface, {
        animationName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      });
      var SyntheticAnimationEvent = createSyntheticEvent(AnimationEventInterface);
      var ClipboardEventInterface = assign({}, EventInterface, {
        clipboardData: function(event) {
          return "clipboardData" in event ? event.clipboardData : window.clipboardData;
        }
      });
      var SyntheticClipboardEvent = createSyntheticEvent(ClipboardEventInterface);
      var CompositionEventInterface = assign({}, EventInterface, {
        data: 0
      });
      var SyntheticCompositionEvent = createSyntheticEvent(CompositionEventInterface);
      var SyntheticInputEvent = SyntheticCompositionEvent;
      var normalizeKey = {
        Esc: "Escape",
        Spacebar: " ",
        Left: "ArrowLeft",
        Up: "ArrowUp",
        Right: "ArrowRight",
        Down: "ArrowDown",
        Del: "Delete",
        Win: "OS",
        Menu: "ContextMenu",
        Apps: "ContextMenu",
        Scroll: "ScrollLock",
        MozPrintableKey: "Unidentified"
      };
      var translateToKey = {
        "8": "Backspace",
        "9": "Tab",
        "12": "Clear",
        "13": "Enter",
        "16": "Shift",
        "17": "Control",
        "18": "Alt",
        "19": "Pause",
        "20": "CapsLock",
        "27": "Escape",
        "32": " ",
        "33": "PageUp",
        "34": "PageDown",
        "35": "End",
        "36": "Home",
        "37": "ArrowLeft",
        "38": "ArrowUp",
        "39": "ArrowRight",
        "40": "ArrowDown",
        "45": "Insert",
        "46": "Delete",
        "112": "F1",
        "113": "F2",
        "114": "F3",
        "115": "F4",
        "116": "F5",
        "117": "F6",
        "118": "F7",
        "119": "F8",
        "120": "F9",
        "121": "F10",
        "122": "F11",
        "123": "F12",
        "144": "NumLock",
        "145": "ScrollLock",
        "224": "Meta"
      };
      function getEventKey(nativeEvent) {
        if (nativeEvent.key) {
          var key = normalizeKey[nativeEvent.key] || nativeEvent.key;
          if (key !== "Unidentified") {
            return key;
          }
        }
        if (nativeEvent.type === "keypress") {
          var charCode = getEventCharCode(nativeEvent);
          return charCode === 13 ? "Enter" : String.fromCharCode(charCode);
        }
        if (nativeEvent.type === "keydown" || nativeEvent.type === "keyup") {
          return translateToKey[nativeEvent.keyCode] || "Unidentified";
        }
        return "";
      }
      var modifierKeyToProp = {
        Alt: "altKey",
        Control: "ctrlKey",
        Meta: "metaKey",
        Shift: "shiftKey"
      };
      function modifierStateGetter(keyArg) {
        var syntheticEvent = this;
        var nativeEvent = syntheticEvent.nativeEvent;
        if (nativeEvent.getModifierState) {
          return nativeEvent.getModifierState(keyArg);
        }
        var keyProp = modifierKeyToProp[keyArg];
        return keyProp ? !!nativeEvent[keyProp] : false;
      }
      function getEventModifierState(nativeEvent) {
        return modifierStateGetter;
      }
      var KeyboardEventInterface = assign({}, UIEventInterface, {
        key: getEventKey,
        code: 0,
        location: 0,
        ctrlKey: 0,
        shiftKey: 0,
        altKey: 0,
        metaKey: 0,
        repeat: 0,
        locale: 0,
        getModifierState: getEventModifierState,
        charCode: function(event) {
          if (event.type === "keypress") {
            return getEventCharCode(event);
          }
          return 0;
        },
        keyCode: function(event) {
          if (event.type === "keydown" || event.type === "keyup") {
            return event.keyCode;
          }
          return 0;
        },
        which: function(event) {
          if (event.type === "keypress") {
            return getEventCharCode(event);
          }
          if (event.type === "keydown" || event.type === "keyup") {
            return event.keyCode;
          }
          return 0;
        }
      });
      var SyntheticKeyboardEvent = createSyntheticEvent(KeyboardEventInterface);
      var PointerEventInterface = assign({}, MouseEventInterface, {
        pointerId: 0,
        width: 0,
        height: 0,
        pressure: 0,
        tangentialPressure: 0,
        tiltX: 0,
        tiltY: 0,
        twist: 0,
        pointerType: 0,
        isPrimary: 0
      });
      var SyntheticPointerEvent = createSyntheticEvent(PointerEventInterface);
      var TouchEventInterface = assign({}, UIEventInterface, {
        touches: 0,
        targetTouches: 0,
        changedTouches: 0,
        altKey: 0,
        metaKey: 0,
        ctrlKey: 0,
        shiftKey: 0,
        getModifierState: getEventModifierState
      });
      var SyntheticTouchEvent = createSyntheticEvent(TouchEventInterface);
      var TransitionEventInterface = assign({}, EventInterface, {
        propertyName: 0,
        elapsedTime: 0,
        pseudoElement: 0
      });
      var SyntheticTransitionEvent = createSyntheticEvent(TransitionEventInterface);
      var WheelEventInterface = assign({}, MouseEventInterface, {
        deltaX: function(event) {
          return "deltaX" in event ? event.deltaX : ("wheelDeltaX" in event) ? -event.wheelDeltaX : 0;
        },
        deltaY: function(event) {
          return "deltaY" in event ? event.deltaY : ("wheelDeltaY" in event) ? -event.wheelDeltaY : ("wheelDelta" in event) ? -event.wheelDelta : 0;
        },
        deltaZ: 0,
        deltaMode: 0
      });
      var SyntheticWheelEvent = createSyntheticEvent(WheelEventInterface);
      var END_KEYCODES = [9, 13, 27, 32];
      var START_KEYCODE = 229;
      var canUseCompositionEvent = canUseDOM && "CompositionEvent" in window;
      var documentMode = null;
      if (canUseDOM && "documentMode" in document) {
        documentMode = document.documentMode;
      }
      var canUseTextInputEvent = canUseDOM && "TextEvent" in window && !documentMode;
      var useFallbackCompositionData = canUseDOM && (!canUseCompositionEvent || documentMode && documentMode > 8 && documentMode <= 11);
      var SPACEBAR_CODE = 32;
      var SPACEBAR_CHAR = String.fromCharCode(SPACEBAR_CODE);
      function registerEvents() {
        registerTwoPhaseEvent("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]);
        registerTwoPhaseEvent("onCompositionEnd", ["compositionend", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
        registerTwoPhaseEvent("onCompositionStart", ["compositionstart", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
        registerTwoPhaseEvent("onCompositionUpdate", ["compositionupdate", "focusout", "keydown", "keypress", "keyup", "mousedown"]);
      }
      var hasSpaceKeypress = false;
      function isKeypressCommand(nativeEvent) {
        return (nativeEvent.ctrlKey || nativeEvent.altKey || nativeEvent.metaKey) && !(nativeEvent.ctrlKey && nativeEvent.altKey);
      }
      function getCompositionEventType(domEventName) {
        switch (domEventName) {
          case "compositionstart":
            return "onCompositionStart";
          case "compositionend":
            return "onCompositionEnd";
          case "compositionupdate":
            return "onCompositionUpdate";
        }
      }
      function isFallbackCompositionStart(domEventName, nativeEvent) {
        return domEventName === "keydown" && nativeEvent.keyCode === START_KEYCODE;
      }
      function isFallbackCompositionEnd(domEventName, nativeEvent) {
        switch (domEventName) {
          case "keyup":
            return END_KEYCODES.indexOf(nativeEvent.keyCode) !== -1;
          case "keydown":
            return nativeEvent.keyCode !== START_KEYCODE;
          case "keypress":
          case "mousedown":
          case "focusout":
            return true;
          default:
            return false;
        }
      }
      function getDataFromCustomEvent(nativeEvent) {
        var detail = nativeEvent.detail;
        if (typeof detail === "object" && "data" in detail) {
          return detail.data;
        }
        return null;
      }
      function isUsingKoreanIME(nativeEvent) {
        return nativeEvent.locale === "ko";
      }
      var isComposing = false;
      function extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
        var eventType;
        var fallbackData;
        if (canUseCompositionEvent) {
          eventType = getCompositionEventType(domEventName);
        } else if (!isComposing) {
          if (isFallbackCompositionStart(domEventName, nativeEvent)) {
            eventType = "onCompositionStart";
          }
        } else if (isFallbackCompositionEnd(domEventName, nativeEvent)) {
          eventType = "onCompositionEnd";
        }
        if (!eventType) {
          return null;
        }
        if (useFallbackCompositionData && !isUsingKoreanIME(nativeEvent)) {
          if (!isComposing && eventType === "onCompositionStart") {
            isComposing = initialize(nativeEventTarget);
          } else if (eventType === "onCompositionEnd") {
            if (isComposing) {
              fallbackData = getData();
            }
          }
        }
        var listeners = accumulateTwoPhaseListeners(targetInst, eventType);
        if (listeners.length > 0) {
          var event = new SyntheticCompositionEvent(eventType, domEventName, null, nativeEvent, nativeEventTarget);
          dispatchQueue.push({
            event,
            listeners
          });
          if (fallbackData) {
            event.data = fallbackData;
          } else {
            var customData = getDataFromCustomEvent(nativeEvent);
            if (customData !== null) {
              event.data = customData;
            }
          }
        }
      }
      function getNativeBeforeInputChars(domEventName, nativeEvent) {
        switch (domEventName) {
          case "compositionend":
            return getDataFromCustomEvent(nativeEvent);
          case "keypress":
            var which = nativeEvent.which;
            if (which !== SPACEBAR_CODE) {
              return null;
            }
            hasSpaceKeypress = true;
            return SPACEBAR_CHAR;
          case "textInput":
            var chars = nativeEvent.data;
            if (chars === SPACEBAR_CHAR && hasSpaceKeypress) {
              return null;
            }
            return chars;
          default:
            return null;
        }
      }
      function getFallbackBeforeInputChars(domEventName, nativeEvent) {
        if (isComposing) {
          if (domEventName === "compositionend" || !canUseCompositionEvent && isFallbackCompositionEnd(domEventName, nativeEvent)) {
            var chars = getData();
            reset();
            isComposing = false;
            return chars;
          }
          return null;
        }
        switch (domEventName) {
          case "paste":
            return null;
          case "keypress":
            if (!isKeypressCommand(nativeEvent)) {
              if (nativeEvent.char && nativeEvent.char.length > 1) {
                return nativeEvent.char;
              } else if (nativeEvent.which) {
                return String.fromCharCode(nativeEvent.which);
              }
            }
            return null;
          case "compositionend":
            return useFallbackCompositionData && !isUsingKoreanIME(nativeEvent) ? null : nativeEvent.data;
          default:
            return null;
        }
      }
      function extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget) {
        var chars;
        if (canUseTextInputEvent) {
          chars = getNativeBeforeInputChars(domEventName, nativeEvent);
        } else {
          chars = getFallbackBeforeInputChars(domEventName, nativeEvent);
        }
        if (!chars) {
          return null;
        }
        var listeners = accumulateTwoPhaseListeners(targetInst, "onBeforeInput");
        if (listeners.length > 0) {
          var event = new SyntheticInputEvent("onBeforeInput", "beforeinput", null, nativeEvent, nativeEventTarget);
          dispatchQueue.push({
            event,
            listeners
          });
          event.data = chars;
        }
      }
      function extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        extractCompositionEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
        extractBeforeInputEvent(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
      }
      var supportedInputTypes = {
        color: true,
        date: true,
        datetime: true,
        "datetime-local": true,
        email: true,
        month: true,
        number: true,
        password: true,
        range: true,
        search: true,
        tel: true,
        text: true,
        time: true,
        url: true,
        week: true
      };
      function isTextInputElement(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        if (nodeName === "input") {
          return !!supportedInputTypes[elem.type];
        }
        if (nodeName === "textarea") {
          return true;
        }
        return false;
      }
      function isEventSupported(eventNameSuffix) {
        if (!canUseDOM) {
          return false;
        }
        var eventName = "on" + eventNameSuffix;
        var isSupported = eventName in document;
        if (!isSupported) {
          var element = document.createElement("div");
          element.setAttribute(eventName, "return;");
          isSupported = typeof element[eventName] === "function";
        }
        return isSupported;
      }
      function registerEvents$1() {
        registerTwoPhaseEvent("onChange", ["change", "click", "focusin", "focusout", "input", "keydown", "keyup", "selectionchange"]);
      }
      function createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, target) {
        enqueueStateRestore(target);
        var listeners = accumulateTwoPhaseListeners(inst, "onChange");
        if (listeners.length > 0) {
          var event = new SyntheticEvent("onChange", "change", null, nativeEvent, target);
          dispatchQueue.push({
            event,
            listeners
          });
        }
      }
      var activeElement = null;
      var activeElementInst = null;
      function shouldUseChangeEvent(elem) {
        var nodeName = elem.nodeName && elem.nodeName.toLowerCase();
        return nodeName === "select" || nodeName === "input" && elem.type === "file";
      }
      function manualDispatchChangeEvent(nativeEvent) {
        var dispatchQueue = [];
        createAndAccumulateChangeEvent(dispatchQueue, activeElementInst, nativeEvent, getEventTarget(nativeEvent));
        batchedUpdates(runEventInBatch, dispatchQueue);
      }
      function runEventInBatch(dispatchQueue) {
        processDispatchQueue(dispatchQueue, 0);
      }
      function getInstIfValueChanged(targetInst) {
        var targetNode = getNodeFromInstance(targetInst);
        if (updateValueIfChanged(targetNode)) {
          return targetInst;
        }
      }
      function getTargetInstForChangeEvent(domEventName, targetInst) {
        if (domEventName === "change") {
          return targetInst;
        }
      }
      var isInputEventSupported = false;
      if (canUseDOM) {
        isInputEventSupported = isEventSupported("input") && (!document.documentMode || document.documentMode > 9);
      }
      function startWatchingForValueChange(target, targetInst) {
        activeElement = target;
        activeElementInst = targetInst;
        activeElement.attachEvent("onpropertychange", handlePropertyChange);
      }
      function stopWatchingForValueChange() {
        if (!activeElement) {
          return;
        }
        activeElement.detachEvent("onpropertychange", handlePropertyChange);
        activeElement = null;
        activeElementInst = null;
      }
      function handlePropertyChange(nativeEvent) {
        if (nativeEvent.propertyName !== "value") {
          return;
        }
        if (getInstIfValueChanged(activeElementInst)) {
          manualDispatchChangeEvent(nativeEvent);
        }
      }
      function handleEventsForInputEventPolyfill(domEventName, target, targetInst) {
        if (domEventName === "focusin") {
          stopWatchingForValueChange();
          startWatchingForValueChange(target, targetInst);
        } else if (domEventName === "focusout") {
          stopWatchingForValueChange();
        }
      }
      function getTargetInstForInputEventPolyfill(domEventName, targetInst) {
        if (domEventName === "selectionchange" || domEventName === "keyup" || domEventName === "keydown") {
          return getInstIfValueChanged(activeElementInst);
        }
      }
      function shouldUseClickEvent(elem) {
        var nodeName = elem.nodeName;
        return nodeName && nodeName.toLowerCase() === "input" && (elem.type === "checkbox" || elem.type === "radio");
      }
      function getTargetInstForClickEvent(domEventName, targetInst) {
        if (domEventName === "click") {
          return getInstIfValueChanged(targetInst);
        }
      }
      function getTargetInstForInputOrChangeEvent(domEventName, targetInst) {
        if (domEventName === "input" || domEventName === "change") {
          return getInstIfValueChanged(targetInst);
        }
      }
      function handleControlledInputBlur(node) {
        var state = node._wrapperState;
        if (!state || !state.controlled || node.type !== "number") {
          return;
        }
        {
          setDefaultValue(node, "number", node.value);
        }
      }
      function extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
        var getTargetInstFunc, handleEventFunc;
        if (shouldUseChangeEvent(targetNode)) {
          getTargetInstFunc = getTargetInstForChangeEvent;
        } else if (isTextInputElement(targetNode)) {
          if (isInputEventSupported) {
            getTargetInstFunc = getTargetInstForInputOrChangeEvent;
          } else {
            getTargetInstFunc = getTargetInstForInputEventPolyfill;
            handleEventFunc = handleEventsForInputEventPolyfill;
          }
        } else if (shouldUseClickEvent(targetNode)) {
          getTargetInstFunc = getTargetInstForClickEvent;
        }
        if (getTargetInstFunc) {
          var inst = getTargetInstFunc(domEventName, targetInst);
          if (inst) {
            createAndAccumulateChangeEvent(dispatchQueue, inst, nativeEvent, nativeEventTarget);
            return;
          }
        }
        if (handleEventFunc) {
          handleEventFunc(domEventName, targetNode, targetInst);
        }
        if (domEventName === "focusout") {
          handleControlledInputBlur(targetNode);
        }
      }
      function registerEvents$2() {
        registerDirectEvent("onMouseEnter", ["mouseout", "mouseover"]);
        registerDirectEvent("onMouseLeave", ["mouseout", "mouseover"]);
        registerDirectEvent("onPointerEnter", ["pointerout", "pointerover"]);
        registerDirectEvent("onPointerLeave", ["pointerout", "pointerover"]);
      }
      function extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        var isOverEvent = domEventName === "mouseover" || domEventName === "pointerover";
        var isOutEvent = domEventName === "mouseout" || domEventName === "pointerout";
        if (isOverEvent && !isReplayingEvent(nativeEvent)) {
          var related = nativeEvent.relatedTarget || nativeEvent.fromElement;
          if (related) {
            if (getClosestInstanceFromNode(related) || isContainerMarkedAsRoot(related)) {
              return;
            }
          }
        }
        if (!isOutEvent && !isOverEvent) {
          return;
        }
        var win;
        if (nativeEventTarget.window === nativeEventTarget) {
          win = nativeEventTarget;
        } else {
          var doc = nativeEventTarget.ownerDocument;
          if (doc) {
            win = doc.defaultView || doc.parentWindow;
          } else {
            win = window;
          }
        }
        var from;
        var to;
        if (isOutEvent) {
          var _related = nativeEvent.relatedTarget || nativeEvent.toElement;
          from = targetInst;
          to = _related ? getClosestInstanceFromNode(_related) : null;
          if (to !== null) {
            var nearestMounted = getNearestMountedFiber(to);
            if (to !== nearestMounted || to.tag !== HostComponent && to.tag !== HostText) {
              to = null;
            }
          }
        } else {
          from = null;
          to = targetInst;
        }
        if (from === to) {
          return;
        }
        var SyntheticEventCtor = SyntheticMouseEvent;
        var leaveEventType = "onMouseLeave";
        var enterEventType = "onMouseEnter";
        var eventTypePrefix = "mouse";
        if (domEventName === "pointerout" || domEventName === "pointerover") {
          SyntheticEventCtor = SyntheticPointerEvent;
          leaveEventType = "onPointerLeave";
          enterEventType = "onPointerEnter";
          eventTypePrefix = "pointer";
        }
        var fromNode = from == null ? win : getNodeFromInstance(from);
        var toNode = to == null ? win : getNodeFromInstance(to);
        var leave = new SyntheticEventCtor(leaveEventType, eventTypePrefix + "leave", from, nativeEvent, nativeEventTarget);
        leave.target = fromNode;
        leave.relatedTarget = toNode;
        var enter = null;
        var nativeTargetInst = getClosestInstanceFromNode(nativeEventTarget);
        if (nativeTargetInst === targetInst) {
          var enterEvent = new SyntheticEventCtor(enterEventType, eventTypePrefix + "enter", to, nativeEvent, nativeEventTarget);
          enterEvent.target = toNode;
          enterEvent.relatedTarget = fromNode;
          enter = enterEvent;
        }
        accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leave, enter, from, to);
      }
      function is(x, y) {
        return x === y && (x !== 0 || 1 / x === 1 / y) || x !== x && y !== y;
      }
      var objectIs = typeof Object.is === "function" ? Object.is : is;
      function shallowEqual(objA, objB) {
        if (objectIs(objA, objB)) {
          return true;
        }
        if (typeof objA !== "object" || objA === null || typeof objB !== "object" || objB === null) {
          return false;
        }
        var keysA = Object.keys(objA);
        var keysB = Object.keys(objB);
        if (keysA.length !== keysB.length) {
          return false;
        }
        for (var i = 0;i < keysA.length; i++) {
          var currentKey = keysA[i];
          if (!hasOwnProperty.call(objB, currentKey) || !objectIs(objA[currentKey], objB[currentKey])) {
            return false;
          }
        }
        return true;
      }
      function getLeafNode(node) {
        while (node && node.firstChild) {
          node = node.firstChild;
        }
        return node;
      }
      function getSiblingNode(node) {
        while (node) {
          if (node.nextSibling) {
            return node.nextSibling;
          }
          node = node.parentNode;
        }
      }
      function getNodeForCharacterOffset(root2, offset) {
        var node = getLeafNode(root2);
        var nodeStart = 0;
        var nodeEnd = 0;
        while (node) {
          if (node.nodeType === TEXT_NODE) {
            nodeEnd = nodeStart + node.textContent.length;
            if (nodeStart <= offset && nodeEnd >= offset) {
              return {
                node,
                offset: offset - nodeStart
              };
            }
            nodeStart = nodeEnd;
          }
          node = getLeafNode(getSiblingNode(node));
        }
      }
      function getOffsets(outerNode) {
        var ownerDocument = outerNode.ownerDocument;
        var win = ownerDocument && ownerDocument.defaultView || window;
        var selection = win.getSelection && win.getSelection();
        if (!selection || selection.rangeCount === 0) {
          return null;
        }
        var { anchorNode, anchorOffset, focusNode, focusOffset } = selection;
        try {
          anchorNode.nodeType;
          focusNode.nodeType;
        } catch (e) {
          return null;
        }
        return getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset);
      }
      function getModernOffsetsFromPoints(outerNode, anchorNode, anchorOffset, focusNode, focusOffset) {
        var length = 0;
        var start = -1;
        var end = -1;
        var indexWithinAnchor = 0;
        var indexWithinFocus = 0;
        var node = outerNode;
        var parentNode = null;
        outer:
          while (true) {
            var next = null;
            while (true) {
              if (node === anchorNode && (anchorOffset === 0 || node.nodeType === TEXT_NODE)) {
                start = length + anchorOffset;
              }
              if (node === focusNode && (focusOffset === 0 || node.nodeType === TEXT_NODE)) {
                end = length + focusOffset;
              }
              if (node.nodeType === TEXT_NODE) {
                length += node.nodeValue.length;
              }
              if ((next = node.firstChild) === null) {
                break;
              }
              parentNode = node;
              node = next;
            }
            while (true) {
              if (node === outerNode) {
                break outer;
              }
              if (parentNode === anchorNode && ++indexWithinAnchor === anchorOffset) {
                start = length;
              }
              if (parentNode === focusNode && ++indexWithinFocus === focusOffset) {
                end = length;
              }
              if ((next = node.nextSibling) !== null) {
                break;
              }
              node = parentNode;
              parentNode = node.parentNode;
            }
            node = next;
          }
        if (start === -1 || end === -1) {
          return null;
        }
        return {
          start,
          end
        };
      }
      function setOffsets(node, offsets) {
        var doc = node.ownerDocument || document;
        var win = doc && doc.defaultView || window;
        if (!win.getSelection) {
          return;
        }
        var selection = win.getSelection();
        var length = node.textContent.length;
        var start = Math.min(offsets.start, length);
        var end = offsets.end === undefined ? start : Math.min(offsets.end, length);
        if (!selection.extend && start > end) {
          var temp = end;
          end = start;
          start = temp;
        }
        var startMarker = getNodeForCharacterOffset(node, start);
        var endMarker = getNodeForCharacterOffset(node, end);
        if (startMarker && endMarker) {
          if (selection.rangeCount === 1 && selection.anchorNode === startMarker.node && selection.anchorOffset === startMarker.offset && selection.focusNode === endMarker.node && selection.focusOffset === endMarker.offset) {
            return;
          }
          var range = doc.createRange();
          range.setStart(startMarker.node, startMarker.offset);
          selection.removeAllRanges();
          if (start > end) {
            selection.addRange(range);
            selection.extend(endMarker.node, endMarker.offset);
          } else {
            range.setEnd(endMarker.node, endMarker.offset);
            selection.addRange(range);
          }
        }
      }
      function isTextNode(node) {
        return node && node.nodeType === TEXT_NODE;
      }
      function containsNode(outerNode, innerNode) {
        if (!outerNode || !innerNode) {
          return false;
        } else if (outerNode === innerNode) {
          return true;
        } else if (isTextNode(outerNode)) {
          return false;
        } else if (isTextNode(innerNode)) {
          return containsNode(outerNode, innerNode.parentNode);
        } else if ("contains" in outerNode) {
          return outerNode.contains(innerNode);
        } else if (outerNode.compareDocumentPosition) {
          return !!(outerNode.compareDocumentPosition(innerNode) & 16);
        } else {
          return false;
        }
      }
      function isInDocument(node) {
        return node && node.ownerDocument && containsNode(node.ownerDocument.documentElement, node);
      }
      function isSameOriginFrame(iframe) {
        try {
          return typeof iframe.contentWindow.location.href === "string";
        } catch (err) {
          return false;
        }
      }
      function getActiveElementDeep() {
        var win = window;
        var element = getActiveElement();
        while (element instanceof win.HTMLIFrameElement) {
          if (isSameOriginFrame(element)) {
            win = element.contentWindow;
          } else {
            return element;
          }
          element = getActiveElement(win.document);
        }
        return element;
      }
      function hasSelectionCapabilities(elem) {
        var nodeName = elem && elem.nodeName && elem.nodeName.toLowerCase();
        return nodeName && (nodeName === "input" && (elem.type === "text" || elem.type === "search" || elem.type === "tel" || elem.type === "url" || elem.type === "password") || nodeName === "textarea" || elem.contentEditable === "true");
      }
      function getSelectionInformation() {
        var focusedElem = getActiveElementDeep();
        return {
          focusedElem,
          selectionRange: hasSelectionCapabilities(focusedElem) ? getSelection(focusedElem) : null
        };
      }
      function restoreSelection(priorSelectionInformation) {
        var curFocusedElem = getActiveElementDeep();
        var priorFocusedElem = priorSelectionInformation.focusedElem;
        var priorSelectionRange = priorSelectionInformation.selectionRange;
        if (curFocusedElem !== priorFocusedElem && isInDocument(priorFocusedElem)) {
          if (priorSelectionRange !== null && hasSelectionCapabilities(priorFocusedElem)) {
            setSelection(priorFocusedElem, priorSelectionRange);
          }
          var ancestors = [];
          var ancestor = priorFocusedElem;
          while (ancestor = ancestor.parentNode) {
            if (ancestor.nodeType === ELEMENT_NODE) {
              ancestors.push({
                element: ancestor,
                left: ancestor.scrollLeft,
                top: ancestor.scrollTop
              });
            }
          }
          if (typeof priorFocusedElem.focus === "function") {
            priorFocusedElem.focus();
          }
          for (var i = 0;i < ancestors.length; i++) {
            var info = ancestors[i];
            info.element.scrollLeft = info.left;
            info.element.scrollTop = info.top;
          }
        }
      }
      function getSelection(input) {
        var selection;
        if ("selectionStart" in input) {
          selection = {
            start: input.selectionStart,
            end: input.selectionEnd
          };
        } else {
          selection = getOffsets(input);
        }
        return selection || {
          start: 0,
          end: 0
        };
      }
      function setSelection(input, offsets) {
        var start = offsets.start;
        var end = offsets.end;
        if (end === undefined) {
          end = start;
        }
        if ("selectionStart" in input) {
          input.selectionStart = start;
          input.selectionEnd = Math.min(end, input.value.length);
        } else {
          setOffsets(input, offsets);
        }
      }
      var skipSelectionChangeEvent = canUseDOM && "documentMode" in document && document.documentMode <= 11;
      function registerEvents$3() {
        registerTwoPhaseEvent("onSelect", ["focusout", "contextmenu", "dragend", "focusin", "keydown", "keyup", "mousedown", "mouseup", "selectionchange"]);
      }
      var activeElement$1 = null;
      var activeElementInst$1 = null;
      var lastSelection = null;
      var mouseDown = false;
      function getSelection$1(node) {
        if ("selectionStart" in node && hasSelectionCapabilities(node)) {
          return {
            start: node.selectionStart,
            end: node.selectionEnd
          };
        } else {
          var win = node.ownerDocument && node.ownerDocument.defaultView || window;
          var selection = win.getSelection();
          return {
            anchorNode: selection.anchorNode,
            anchorOffset: selection.anchorOffset,
            focusNode: selection.focusNode,
            focusOffset: selection.focusOffset
          };
        }
      }
      function getEventTargetDocument(eventTarget) {
        return eventTarget.window === eventTarget ? eventTarget.document : eventTarget.nodeType === DOCUMENT_NODE ? eventTarget : eventTarget.ownerDocument;
      }
      function constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget) {
        var doc = getEventTargetDocument(nativeEventTarget);
        if (mouseDown || activeElement$1 == null || activeElement$1 !== getActiveElement(doc)) {
          return;
        }
        var currentSelection = getSelection$1(activeElement$1);
        if (!lastSelection || !shallowEqual(lastSelection, currentSelection)) {
          lastSelection = currentSelection;
          var listeners = accumulateTwoPhaseListeners(activeElementInst$1, "onSelect");
          if (listeners.length > 0) {
            var event = new SyntheticEvent("onSelect", "select", null, nativeEvent, nativeEventTarget);
            dispatchQueue.push({
              event,
              listeners
            });
            event.target = activeElement$1;
          }
        }
      }
      function extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        var targetNode = targetInst ? getNodeFromInstance(targetInst) : window;
        switch (domEventName) {
          case "focusin":
            if (isTextInputElement(targetNode) || targetNode.contentEditable === "true") {
              activeElement$1 = targetNode;
              activeElementInst$1 = targetInst;
              lastSelection = null;
            }
            break;
          case "focusout":
            activeElement$1 = null;
            activeElementInst$1 = null;
            lastSelection = null;
            break;
          case "mousedown":
            mouseDown = true;
            break;
          case "contextmenu":
          case "mouseup":
          case "dragend":
            mouseDown = false;
            constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
            break;
          case "selectionchange":
            if (skipSelectionChangeEvent) {
              break;
            }
          case "keydown":
          case "keyup":
            constructSelectEvent(dispatchQueue, nativeEvent, nativeEventTarget);
        }
      }
      function makePrefixMap(styleProp, eventName) {
        var prefixes2 = {};
        prefixes2[styleProp.toLowerCase()] = eventName.toLowerCase();
        prefixes2["Webkit" + styleProp] = "webkit" + eventName;
        prefixes2["Moz" + styleProp] = "moz" + eventName;
        return prefixes2;
      }
      var vendorPrefixes = {
        animationend: makePrefixMap("Animation", "AnimationEnd"),
        animationiteration: makePrefixMap("Animation", "AnimationIteration"),
        animationstart: makePrefixMap("Animation", "AnimationStart"),
        transitionend: makePrefixMap("Transition", "TransitionEnd")
      };
      var prefixedEventNames = {};
      var style = {};
      if (canUseDOM) {
        style = document.createElement("div").style;
        if (!("AnimationEvent" in window)) {
          delete vendorPrefixes.animationend.animation;
          delete vendorPrefixes.animationiteration.animation;
          delete vendorPrefixes.animationstart.animation;
        }
        if (!("TransitionEvent" in window)) {
          delete vendorPrefixes.transitionend.transition;
        }
      }
      function getVendorPrefixedEventName(eventName) {
        if (prefixedEventNames[eventName]) {
          return prefixedEventNames[eventName];
        } else if (!vendorPrefixes[eventName]) {
          return eventName;
        }
        var prefixMap = vendorPrefixes[eventName];
        for (var styleProp in prefixMap) {
          if (prefixMap.hasOwnProperty(styleProp) && styleProp in style) {
            return prefixedEventNames[eventName] = prefixMap[styleProp];
          }
        }
        return eventName;
      }
      var ANIMATION_END = getVendorPrefixedEventName("animationend");
      var ANIMATION_ITERATION = getVendorPrefixedEventName("animationiteration");
      var ANIMATION_START = getVendorPrefixedEventName("animationstart");
      var TRANSITION_END = getVendorPrefixedEventName("transitionend");
      var topLevelEventsToReactNames = new Map;
      var simpleEventPluginEvents = ["abort", "auxClick", "cancel", "canPlay", "canPlayThrough", "click", "close", "contextMenu", "copy", "cut", "drag", "dragEnd", "dragEnter", "dragExit", "dragLeave", "dragOver", "dragStart", "drop", "durationChange", "emptied", "encrypted", "ended", "error", "gotPointerCapture", "input", "invalid", "keyDown", "keyPress", "keyUp", "load", "loadedData", "loadedMetadata", "loadStart", "lostPointerCapture", "mouseDown", "mouseMove", "mouseOut", "mouseOver", "mouseUp", "paste", "pause", "play", "playing", "pointerCancel", "pointerDown", "pointerMove", "pointerOut", "pointerOver", "pointerUp", "progress", "rateChange", "reset", "resize", "seeked", "seeking", "stalled", "submit", "suspend", "timeUpdate", "touchCancel", "touchEnd", "touchStart", "volumeChange", "scroll", "toggle", "touchMove", "waiting", "wheel"];
      function registerSimpleEvent(domEventName, reactName) {
        topLevelEventsToReactNames.set(domEventName, reactName);
        registerTwoPhaseEvent(reactName, [domEventName]);
      }
      function registerSimpleEvents() {
        for (var i = 0;i < simpleEventPluginEvents.length; i++) {
          var eventName = simpleEventPluginEvents[i];
          var domEventName = eventName.toLowerCase();
          var capitalizedEvent = eventName[0].toUpperCase() + eventName.slice(1);
          registerSimpleEvent(domEventName, "on" + capitalizedEvent);
        }
        registerSimpleEvent(ANIMATION_END, "onAnimationEnd");
        registerSimpleEvent(ANIMATION_ITERATION, "onAnimationIteration");
        registerSimpleEvent(ANIMATION_START, "onAnimationStart");
        registerSimpleEvent("dblclick", "onDoubleClick");
        registerSimpleEvent("focusin", "onFocus");
        registerSimpleEvent("focusout", "onBlur");
        registerSimpleEvent(TRANSITION_END, "onTransitionEnd");
      }
      function extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        var reactName = topLevelEventsToReactNames.get(domEventName);
        if (reactName === undefined) {
          return;
        }
        var SyntheticEventCtor = SyntheticEvent;
        var reactEventType = domEventName;
        switch (domEventName) {
          case "keypress":
            if (getEventCharCode(nativeEvent) === 0) {
              return;
            }
          case "keydown":
          case "keyup":
            SyntheticEventCtor = SyntheticKeyboardEvent;
            break;
          case "focusin":
            reactEventType = "focus";
            SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "focusout":
            reactEventType = "blur";
            SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "beforeblur":
          case "afterblur":
            SyntheticEventCtor = SyntheticFocusEvent;
            break;
          case "click":
            if (nativeEvent.button === 2) {
              return;
            }
          case "auxclick":
          case "dblclick":
          case "mousedown":
          case "mousemove":
          case "mouseup":
          case "mouseout":
          case "mouseover":
          case "contextmenu":
            SyntheticEventCtor = SyntheticMouseEvent;
            break;
          case "drag":
          case "dragend":
          case "dragenter":
          case "dragexit":
          case "dragleave":
          case "dragover":
          case "dragstart":
          case "drop":
            SyntheticEventCtor = SyntheticDragEvent;
            break;
          case "touchcancel":
          case "touchend":
          case "touchmove":
          case "touchstart":
            SyntheticEventCtor = SyntheticTouchEvent;
            break;
          case ANIMATION_END:
          case ANIMATION_ITERATION:
          case ANIMATION_START:
            SyntheticEventCtor = SyntheticAnimationEvent;
            break;
          case TRANSITION_END:
            SyntheticEventCtor = SyntheticTransitionEvent;
            break;
          case "scroll":
            SyntheticEventCtor = SyntheticUIEvent;
            break;
          case "wheel":
            SyntheticEventCtor = SyntheticWheelEvent;
            break;
          case "copy":
          case "cut":
          case "paste":
            SyntheticEventCtor = SyntheticClipboardEvent;
            break;
          case "gotpointercapture":
          case "lostpointercapture":
          case "pointercancel":
          case "pointerdown":
          case "pointermove":
          case "pointerout":
          case "pointerover":
          case "pointerup":
            SyntheticEventCtor = SyntheticPointerEvent;
            break;
        }
        var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
        {
          var accumulateTargetOnly = !inCapturePhase && domEventName === "scroll";
          var _listeners = accumulateSinglePhaseListeners(targetInst, reactName, nativeEvent.type, inCapturePhase, accumulateTargetOnly);
          if (_listeners.length > 0) {
            var _event = new SyntheticEventCtor(reactName, reactEventType, null, nativeEvent, nativeEventTarget);
            dispatchQueue.push({
              event: _event,
              listeners: _listeners
            });
          }
        }
      }
      registerSimpleEvents();
      registerEvents$2();
      registerEvents$1();
      registerEvents$3();
      registerEvents();
      function extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags, targetContainer) {
        extractEvents$4(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
        var shouldProcessPolyfillPlugins = (eventSystemFlags & SHOULD_NOT_PROCESS_POLYFILL_EVENT_PLUGINS) === 0;
        if (shouldProcessPolyfillPlugins) {
          extractEvents$2(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
          extractEvents$1(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
          extractEvents$3(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
          extractEvents(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget);
        }
      }
      var mediaEventTypes = ["abort", "canplay", "canplaythrough", "durationchange", "emptied", "encrypted", "ended", "error", "loadeddata", "loadedmetadata", "loadstart", "pause", "play", "playing", "progress", "ratechange", "resize", "seeked", "seeking", "stalled", "suspend", "timeupdate", "volumechange", "waiting"];
      var nonDelegatedEvents = new Set(["cancel", "close", "invalid", "load", "scroll", "toggle"].concat(mediaEventTypes));
      function executeDispatch(event, listener, currentTarget) {
        var type = event.type || "unknown-event";
        event.currentTarget = currentTarget;
        invokeGuardedCallbackAndCatchFirstError(type, listener, undefined, event);
        event.currentTarget = null;
      }
      function processDispatchQueueItemsInOrder(event, dispatchListeners, inCapturePhase) {
        var previousInstance;
        if (inCapturePhase) {
          for (var i = dispatchListeners.length - 1;i >= 0; i--) {
            var _dispatchListeners$i = dispatchListeners[i], instance = _dispatchListeners$i.instance, currentTarget = _dispatchListeners$i.currentTarget, listener = _dispatchListeners$i.listener;
            if (instance !== previousInstance && event.isPropagationStopped()) {
              return;
            }
            executeDispatch(event, listener, currentTarget);
            previousInstance = instance;
          }
        } else {
          for (var _i = 0;_i < dispatchListeners.length; _i++) {
            var _dispatchListeners$_i = dispatchListeners[_i], _instance = _dispatchListeners$_i.instance, _currentTarget = _dispatchListeners$_i.currentTarget, _listener = _dispatchListeners$_i.listener;
            if (_instance !== previousInstance && event.isPropagationStopped()) {
              return;
            }
            executeDispatch(event, _listener, _currentTarget);
            previousInstance = _instance;
          }
        }
      }
      function processDispatchQueue(dispatchQueue, eventSystemFlags) {
        var inCapturePhase = (eventSystemFlags & IS_CAPTURE_PHASE) !== 0;
        for (var i = 0;i < dispatchQueue.length; i++) {
          var _dispatchQueue$i = dispatchQueue[i], event = _dispatchQueue$i.event, listeners = _dispatchQueue$i.listeners;
          processDispatchQueueItemsInOrder(event, listeners, inCapturePhase);
        }
        rethrowCaughtError();
      }
      function dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
        var nativeEventTarget = getEventTarget(nativeEvent);
        var dispatchQueue = [];
        extractEvents$5(dispatchQueue, domEventName, targetInst, nativeEvent, nativeEventTarget, eventSystemFlags);
        processDispatchQueue(dispatchQueue, eventSystemFlags);
      }
      function listenToNonDelegatedEvent(domEventName, targetElement) {
        {
          if (!nonDelegatedEvents.has(domEventName)) {
            error('Did not expect a listenToNonDelegatedEvent() call for "%s". ' + "This is a bug in React. Please file an issue.", domEventName);
          }
        }
        var isCapturePhaseListener = false;
        var listenerSet = getEventListenerSet(targetElement);
        var listenerSetKey = getListenerSetKey(domEventName, isCapturePhaseListener);
        if (!listenerSet.has(listenerSetKey)) {
          addTrappedEventListener(targetElement, domEventName, IS_NON_DELEGATED, isCapturePhaseListener);
          listenerSet.add(listenerSetKey);
        }
      }
      function listenToNativeEvent(domEventName, isCapturePhaseListener, target) {
        {
          if (nonDelegatedEvents.has(domEventName) && !isCapturePhaseListener) {
            error('Did not expect a listenToNativeEvent() call for "%s" in the bubble phase. ' + "This is a bug in React. Please file an issue.", domEventName);
          }
        }
        var eventSystemFlags = 0;
        if (isCapturePhaseListener) {
          eventSystemFlags |= IS_CAPTURE_PHASE;
        }
        addTrappedEventListener(target, domEventName, eventSystemFlags, isCapturePhaseListener);
      }
      var listeningMarker = "_reactListening" + Math.random().toString(36).slice(2);
      function listenToAllSupportedEvents(rootContainerElement) {
        if (!rootContainerElement[listeningMarker]) {
          rootContainerElement[listeningMarker] = true;
          allNativeEvents.forEach(function(domEventName) {
            if (domEventName !== "selectionchange") {
              if (!nonDelegatedEvents.has(domEventName)) {
                listenToNativeEvent(domEventName, false, rootContainerElement);
              }
              listenToNativeEvent(domEventName, true, rootContainerElement);
            }
          });
          var ownerDocument = rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
          if (ownerDocument !== null) {
            if (!ownerDocument[listeningMarker]) {
              ownerDocument[listeningMarker] = true;
              listenToNativeEvent("selectionchange", false, ownerDocument);
            }
          }
        }
      }
      function addTrappedEventListener(targetContainer, domEventName, eventSystemFlags, isCapturePhaseListener, isDeferredListenerForLegacyFBSupport) {
        var listener = createEventListenerWrapperWithPriority(targetContainer, domEventName, eventSystemFlags);
        var isPassiveListener = undefined;
        if (passiveBrowserEventsSupported) {
          if (domEventName === "touchstart" || domEventName === "touchmove" || domEventName === "wheel") {
            isPassiveListener = true;
          }
        }
        targetContainer = targetContainer;
        var unsubscribeListener;
        if (isCapturePhaseListener) {
          if (isPassiveListener !== undefined) {
            unsubscribeListener = addEventCaptureListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
          } else {
            unsubscribeListener = addEventCaptureListener(targetContainer, domEventName, listener);
          }
        } else {
          if (isPassiveListener !== undefined) {
            unsubscribeListener = addEventBubbleListenerWithPassiveFlag(targetContainer, domEventName, listener, isPassiveListener);
          } else {
            unsubscribeListener = addEventBubbleListener(targetContainer, domEventName, listener);
          }
        }
      }
      function isMatchingRootContainer(grandContainer, targetContainer) {
        return grandContainer === targetContainer || grandContainer.nodeType === COMMENT_NODE && grandContainer.parentNode === targetContainer;
      }
      function dispatchEventForPluginEventSystem(domEventName, eventSystemFlags, nativeEvent, targetInst, targetContainer) {
        var ancestorInst = targetInst;
        if ((eventSystemFlags & IS_EVENT_HANDLE_NON_MANAGED_NODE) === 0 && (eventSystemFlags & IS_NON_DELEGATED) === 0) {
          var targetContainerNode = targetContainer;
          if (targetInst !== null) {
            var node = targetInst;
            mainLoop:
              while (true) {
                if (node === null) {
                  return;
                }
                var nodeTag = node.tag;
                if (nodeTag === HostRoot || nodeTag === HostPortal) {
                  var container = node.stateNode.containerInfo;
                  if (isMatchingRootContainer(container, targetContainerNode)) {
                    break;
                  }
                  if (nodeTag === HostPortal) {
                    var grandNode = node.return;
                    while (grandNode !== null) {
                      var grandTag = grandNode.tag;
                      if (grandTag === HostRoot || grandTag === HostPortal) {
                        var grandContainer = grandNode.stateNode.containerInfo;
                        if (isMatchingRootContainer(grandContainer, targetContainerNode)) {
                          return;
                        }
                      }
                      grandNode = grandNode.return;
                    }
                  }
                  while (container !== null) {
                    var parentNode = getClosestInstanceFromNode(container);
                    if (parentNode === null) {
                      return;
                    }
                    var parentTag = parentNode.tag;
                    if (parentTag === HostComponent || parentTag === HostText) {
                      node = ancestorInst = parentNode;
                      continue mainLoop;
                    }
                    container = container.parentNode;
                  }
                }
                node = node.return;
              }
          }
        }
        batchedUpdates(function() {
          return dispatchEventsForPlugins(domEventName, eventSystemFlags, nativeEvent, ancestorInst);
        });
      }
      function createDispatchListener(instance, listener, currentTarget) {
        return {
          instance,
          listener,
          currentTarget
        };
      }
      function accumulateSinglePhaseListeners(targetFiber, reactName, nativeEventType, inCapturePhase, accumulateTargetOnly, nativeEvent) {
        var captureName = reactName !== null ? reactName + "Capture" : null;
        var reactEventName = inCapturePhase ? captureName : reactName;
        var listeners = [];
        var instance = targetFiber;
        var lastHostComponent = null;
        while (instance !== null) {
          var _instance2 = instance, stateNode = _instance2.stateNode, tag = _instance2.tag;
          if (tag === HostComponent && stateNode !== null) {
            lastHostComponent = stateNode;
            if (reactEventName !== null) {
              var listener = getListener(instance, reactEventName);
              if (listener != null) {
                listeners.push(createDispatchListener(instance, listener, lastHostComponent));
              }
            }
          }
          if (accumulateTargetOnly) {
            break;
          }
          instance = instance.return;
        }
        return listeners;
      }
      function accumulateTwoPhaseListeners(targetFiber, reactName) {
        var captureName = reactName + "Capture";
        var listeners = [];
        var instance = targetFiber;
        while (instance !== null) {
          var _instance3 = instance, stateNode = _instance3.stateNode, tag = _instance3.tag;
          if (tag === HostComponent && stateNode !== null) {
            var currentTarget = stateNode;
            var captureListener = getListener(instance, captureName);
            if (captureListener != null) {
              listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
            }
            var bubbleListener = getListener(instance, reactName);
            if (bubbleListener != null) {
              listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
            }
          }
          instance = instance.return;
        }
        return listeners;
      }
      function getParent(inst) {
        if (inst === null) {
          return null;
        }
        do {
          inst = inst.return;
        } while (inst && inst.tag !== HostComponent);
        if (inst) {
          return inst;
        }
        return null;
      }
      function getLowestCommonAncestor(instA, instB) {
        var nodeA = instA;
        var nodeB = instB;
        var depthA = 0;
        for (var tempA = nodeA;tempA; tempA = getParent(tempA)) {
          depthA++;
        }
        var depthB = 0;
        for (var tempB = nodeB;tempB; tempB = getParent(tempB)) {
          depthB++;
        }
        while (depthA - depthB > 0) {
          nodeA = getParent(nodeA);
          depthA--;
        }
        while (depthB - depthA > 0) {
          nodeB = getParent(nodeB);
          depthB--;
        }
        var depth = depthA;
        while (depth--) {
          if (nodeA === nodeB || nodeB !== null && nodeA === nodeB.alternate) {
            return nodeA;
          }
          nodeA = getParent(nodeA);
          nodeB = getParent(nodeB);
        }
        return null;
      }
      function accumulateEnterLeaveListenersForEvent(dispatchQueue, event, target, common, inCapturePhase) {
        var registrationName = event._reactName;
        var listeners = [];
        var instance = target;
        while (instance !== null) {
          if (instance === common) {
            break;
          }
          var _instance4 = instance, alternate = _instance4.alternate, stateNode = _instance4.stateNode, tag = _instance4.tag;
          if (alternate !== null && alternate === common) {
            break;
          }
          if (tag === HostComponent && stateNode !== null) {
            var currentTarget = stateNode;
            if (inCapturePhase) {
              var captureListener = getListener(instance, registrationName);
              if (captureListener != null) {
                listeners.unshift(createDispatchListener(instance, captureListener, currentTarget));
              }
            } else if (!inCapturePhase) {
              var bubbleListener = getListener(instance, registrationName);
              if (bubbleListener != null) {
                listeners.push(createDispatchListener(instance, bubbleListener, currentTarget));
              }
            }
          }
          instance = instance.return;
        }
        if (listeners.length !== 0) {
          dispatchQueue.push({
            event,
            listeners
          });
        }
      }
      function accumulateEnterLeaveTwoPhaseListeners(dispatchQueue, leaveEvent, enterEvent, from, to) {
        var common = from && to ? getLowestCommonAncestor(from, to) : null;
        if (from !== null) {
          accumulateEnterLeaveListenersForEvent(dispatchQueue, leaveEvent, from, common, false);
        }
        if (to !== null && enterEvent !== null) {
          accumulateEnterLeaveListenersForEvent(dispatchQueue, enterEvent, to, common, true);
        }
      }
      function getListenerSetKey(domEventName, capture) {
        return domEventName + "__" + (capture ? "capture" : "bubble");
      }
      var didWarnInvalidHydration = false;
      var DANGEROUSLY_SET_INNER_HTML = "dangerouslySetInnerHTML";
      var SUPPRESS_CONTENT_EDITABLE_WARNING = "suppressContentEditableWarning";
      var SUPPRESS_HYDRATION_WARNING = "suppressHydrationWarning";
      var AUTOFOCUS = "autoFocus";
      var CHILDREN = "children";
      var STYLE = "style";
      var HTML$1 = "__html";
      var warnedUnknownTags;
      var validatePropertiesInDevelopment;
      var warnForPropDifference;
      var warnForExtraAttributes;
      var warnForInvalidEventListener;
      var canDiffStyleForHydrationWarning;
      var normalizeHTML;
      {
        warnedUnknownTags = {
          dialog: true,
          webview: true
        };
        validatePropertiesInDevelopment = function(type, props) {
          validateProperties(type, props);
          validateProperties$1(type, props);
          validateProperties$2(type, props, {
            registrationNameDependencies,
            possibleRegistrationNames
          });
        };
        canDiffStyleForHydrationWarning = canUseDOM && !document.documentMode;
        warnForPropDifference = function(propName, serverValue, clientValue) {
          if (didWarnInvalidHydration) {
            return;
          }
          var normalizedClientValue = normalizeMarkupForTextOrAttribute(clientValue);
          var normalizedServerValue = normalizeMarkupForTextOrAttribute(serverValue);
          if (normalizedServerValue === normalizedClientValue) {
            return;
          }
          didWarnInvalidHydration = true;
          error("Prop `%s` did not match. Server: %s Client: %s", propName, JSON.stringify(normalizedServerValue), JSON.stringify(normalizedClientValue));
        };
        warnForExtraAttributes = function(attributeNames) {
          if (didWarnInvalidHydration) {
            return;
          }
          didWarnInvalidHydration = true;
          var names = [];
          attributeNames.forEach(function(name) {
            names.push(name);
          });
          error("Extra attributes from the server: %s", names);
        };
        warnForInvalidEventListener = function(registrationName, listener) {
          if (listener === false) {
            error("Expected `%s` listener to be a function, instead got `false`.\n\n" + "If you used to conditionally omit it with %s={condition && value}, " + "pass %s={condition ? value : undefined} instead.", registrationName, registrationName, registrationName);
          } else {
            error("Expected `%s` listener to be a function, instead got a value of `%s` type.", registrationName, typeof listener);
          }
        };
        normalizeHTML = function(parent, html) {
          var testElement = parent.namespaceURI === HTML_NAMESPACE ? parent.ownerDocument.createElement(parent.tagName) : parent.ownerDocument.createElementNS(parent.namespaceURI, parent.tagName);
          testElement.innerHTML = html;
          return testElement.innerHTML;
        };
      }
      var NORMALIZE_NEWLINES_REGEX = /\r\n?/g;
      var NORMALIZE_NULL_AND_REPLACEMENT_REGEX = /\u0000|\uFFFD/g;
      function normalizeMarkupForTextOrAttribute(markup) {
        {
          checkHtmlStringCoercion(markup);
        }
        var markupString = typeof markup === "string" ? markup : "" + markup;
        return markupString.replace(NORMALIZE_NEWLINES_REGEX, `
`).replace(NORMALIZE_NULL_AND_REPLACEMENT_REGEX, "");
      }
      function checkForUnmatchedText(serverText, clientText, isConcurrentMode, shouldWarnDev) {
        var normalizedClientText = normalizeMarkupForTextOrAttribute(clientText);
        var normalizedServerText = normalizeMarkupForTextOrAttribute(serverText);
        if (normalizedServerText === normalizedClientText) {
          return;
        }
        if (shouldWarnDev) {
          {
            if (!didWarnInvalidHydration) {
              didWarnInvalidHydration = true;
              error('Text content did not match. Server: "%s" Client: "%s"', normalizedServerText, normalizedClientText);
            }
          }
        }
        if (isConcurrentMode && enableClientRenderFallbackOnTextMismatch) {
          throw new Error("Text content does not match server-rendered HTML.");
        }
      }
      function getOwnerDocumentFromRootContainer(rootContainerElement) {
        return rootContainerElement.nodeType === DOCUMENT_NODE ? rootContainerElement : rootContainerElement.ownerDocument;
      }
      function noop() {}
      function trapClickOnNonInteractiveElement(node) {
        node.onclick = noop;
      }
      function setInitialDOMProperties(tag, domElement, rootContainerElement, nextProps, isCustomComponentTag) {
        for (var propKey in nextProps) {
          if (!nextProps.hasOwnProperty(propKey)) {
            continue;
          }
          var nextProp = nextProps[propKey];
          if (propKey === STYLE) {
            {
              if (nextProp) {
                Object.freeze(nextProp);
              }
            }
            setValueForStyles(domElement, nextProp);
          } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
            var nextHtml = nextProp ? nextProp[HTML$1] : undefined;
            if (nextHtml != null) {
              setInnerHTML(domElement, nextHtml);
            }
          } else if (propKey === CHILDREN) {
            if (typeof nextProp === "string") {
              var canSetTextContent = tag !== "textarea" || nextProp !== "";
              if (canSetTextContent) {
                setTextContent(domElement, nextProp);
              }
            } else if (typeof nextProp === "number") {
              setTextContent(domElement, "" + nextProp);
            }
          } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
            ;
          else if (propKey === AUTOFOCUS)
            ;
          else if (registrationNameDependencies.hasOwnProperty(propKey)) {
            if (nextProp != null) {
              if (typeof nextProp !== "function") {
                warnForInvalidEventListener(propKey, nextProp);
              }
              if (propKey === "onScroll") {
                listenToNonDelegatedEvent("scroll", domElement);
              }
            }
          } else if (nextProp != null) {
            setValueForProperty(domElement, propKey, nextProp, isCustomComponentTag);
          }
        }
      }
      function updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag) {
        for (var i = 0;i < updatePayload.length; i += 2) {
          var propKey = updatePayload[i];
          var propValue = updatePayload[i + 1];
          if (propKey === STYLE) {
            setValueForStyles(domElement, propValue);
          } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
            setInnerHTML(domElement, propValue);
          } else if (propKey === CHILDREN) {
            setTextContent(domElement, propValue);
          } else {
            setValueForProperty(domElement, propKey, propValue, isCustomComponentTag);
          }
        }
      }
      function createElement(type, props, rootContainerElement, parentNamespace) {
        var isCustomComponentTag;
        var ownerDocument = getOwnerDocumentFromRootContainer(rootContainerElement);
        var domElement;
        var namespaceURI = parentNamespace;
        if (namespaceURI === HTML_NAMESPACE) {
          namespaceURI = getIntrinsicNamespace(type);
        }
        if (namespaceURI === HTML_NAMESPACE) {
          {
            isCustomComponentTag = isCustomComponent(type, props);
            if (!isCustomComponentTag && type !== type.toLowerCase()) {
              error("<%s /> is using incorrect casing. " + "Use PascalCase for React components, " + "or lowercase for HTML elements.", type);
            }
          }
          if (type === "script") {
            var div = ownerDocument.createElement("div");
            div.innerHTML = "<script><" + "/script>";
            var firstChild = div.firstChild;
            domElement = div.removeChild(firstChild);
          } else if (typeof props.is === "string") {
            domElement = ownerDocument.createElement(type, {
              is: props.is
            });
          } else {
            domElement = ownerDocument.createElement(type);
            if (type === "select") {
              var node = domElement;
              if (props.multiple) {
                node.multiple = true;
              } else if (props.size) {
                node.size = props.size;
              }
            }
          }
        } else {
          domElement = ownerDocument.createElementNS(namespaceURI, type);
        }
        {
          if (namespaceURI === HTML_NAMESPACE) {
            if (!isCustomComponentTag && Object.prototype.toString.call(domElement) === "[object HTMLUnknownElement]" && !hasOwnProperty.call(warnedUnknownTags, type)) {
              warnedUnknownTags[type] = true;
              error("The tag <%s> is unrecognized in this browser. " + "If you meant to render a React component, start its name with " + "an uppercase letter.", type);
            }
          }
        }
        return domElement;
      }
      function createTextNode(text, rootContainerElement) {
        return getOwnerDocumentFromRootContainer(rootContainerElement).createTextNode(text);
      }
      function setInitialProperties(domElement, tag, rawProps, rootContainerElement) {
        var isCustomComponentTag = isCustomComponent(tag, rawProps);
        {
          validatePropertiesInDevelopment(tag, rawProps);
        }
        var props;
        switch (tag) {
          case "dialog":
            listenToNonDelegatedEvent("cancel", domElement);
            listenToNonDelegatedEvent("close", domElement);
            props = rawProps;
            break;
          case "iframe":
          case "object":
          case "embed":
            listenToNonDelegatedEvent("load", domElement);
            props = rawProps;
            break;
          case "video":
          case "audio":
            for (var i = 0;i < mediaEventTypes.length; i++) {
              listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
            }
            props = rawProps;
            break;
          case "source":
            listenToNonDelegatedEvent("error", domElement);
            props = rawProps;
            break;
          case "img":
          case "image":
          case "link":
            listenToNonDelegatedEvent("error", domElement);
            listenToNonDelegatedEvent("load", domElement);
            props = rawProps;
            break;
          case "details":
            listenToNonDelegatedEvent("toggle", domElement);
            props = rawProps;
            break;
          case "input":
            initWrapperState(domElement, rawProps);
            props = getHostProps(domElement, rawProps);
            listenToNonDelegatedEvent("invalid", domElement);
            break;
          case "option":
            validateProps(domElement, rawProps);
            props = rawProps;
            break;
          case "select":
            initWrapperState$1(domElement, rawProps);
            props = getHostProps$1(domElement, rawProps);
            listenToNonDelegatedEvent("invalid", domElement);
            break;
          case "textarea":
            initWrapperState$2(domElement, rawProps);
            props = getHostProps$2(domElement, rawProps);
            listenToNonDelegatedEvent("invalid", domElement);
            break;
          default:
            props = rawProps;
        }
        assertValidProps(tag, props);
        setInitialDOMProperties(tag, domElement, rootContainerElement, props, isCustomComponentTag);
        switch (tag) {
          case "input":
            track(domElement);
            postMountWrapper(domElement, rawProps, false);
            break;
          case "textarea":
            track(domElement);
            postMountWrapper$3(domElement);
            break;
          case "option":
            postMountWrapper$1(domElement, rawProps);
            break;
          case "select":
            postMountWrapper$2(domElement, rawProps);
            break;
          default:
            if (typeof props.onClick === "function") {
              trapClickOnNonInteractiveElement(domElement);
            }
            break;
        }
      }
      function diffProperties(domElement, tag, lastRawProps, nextRawProps, rootContainerElement) {
        {
          validatePropertiesInDevelopment(tag, nextRawProps);
        }
        var updatePayload = null;
        var lastProps;
        var nextProps;
        switch (tag) {
          case "input":
            lastProps = getHostProps(domElement, lastRawProps);
            nextProps = getHostProps(domElement, nextRawProps);
            updatePayload = [];
            break;
          case "select":
            lastProps = getHostProps$1(domElement, lastRawProps);
            nextProps = getHostProps$1(domElement, nextRawProps);
            updatePayload = [];
            break;
          case "textarea":
            lastProps = getHostProps$2(domElement, lastRawProps);
            nextProps = getHostProps$2(domElement, nextRawProps);
            updatePayload = [];
            break;
          default:
            lastProps = lastRawProps;
            nextProps = nextRawProps;
            if (typeof lastProps.onClick !== "function" && typeof nextProps.onClick === "function") {
              trapClickOnNonInteractiveElement(domElement);
            }
            break;
        }
        assertValidProps(tag, nextProps);
        var propKey;
        var styleName;
        var styleUpdates = null;
        for (propKey in lastProps) {
          if (nextProps.hasOwnProperty(propKey) || !lastProps.hasOwnProperty(propKey) || lastProps[propKey] == null) {
            continue;
          }
          if (propKey === STYLE) {
            var lastStyle = lastProps[propKey];
            for (styleName in lastStyle) {
              if (lastStyle.hasOwnProperty(styleName)) {
                if (!styleUpdates) {
                  styleUpdates = {};
                }
                styleUpdates[styleName] = "";
              }
            }
          } else if (propKey === DANGEROUSLY_SET_INNER_HTML || propKey === CHILDREN)
            ;
          else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
            ;
          else if (propKey === AUTOFOCUS)
            ;
          else if (registrationNameDependencies.hasOwnProperty(propKey)) {
            if (!updatePayload) {
              updatePayload = [];
            }
          } else {
            (updatePayload = updatePayload || []).push(propKey, null);
          }
        }
        for (propKey in nextProps) {
          var nextProp = nextProps[propKey];
          var lastProp = lastProps != null ? lastProps[propKey] : undefined;
          if (!nextProps.hasOwnProperty(propKey) || nextProp === lastProp || nextProp == null && lastProp == null) {
            continue;
          }
          if (propKey === STYLE) {
            {
              if (nextProp) {
                Object.freeze(nextProp);
              }
            }
            if (lastProp) {
              for (styleName in lastProp) {
                if (lastProp.hasOwnProperty(styleName) && (!nextProp || !nextProp.hasOwnProperty(styleName))) {
                  if (!styleUpdates) {
                    styleUpdates = {};
                  }
                  styleUpdates[styleName] = "";
                }
              }
              for (styleName in nextProp) {
                if (nextProp.hasOwnProperty(styleName) && lastProp[styleName] !== nextProp[styleName]) {
                  if (!styleUpdates) {
                    styleUpdates = {};
                  }
                  styleUpdates[styleName] = nextProp[styleName];
                }
              }
            } else {
              if (!styleUpdates) {
                if (!updatePayload) {
                  updatePayload = [];
                }
                updatePayload.push(propKey, styleUpdates);
              }
              styleUpdates = nextProp;
            }
          } else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
            var nextHtml = nextProp ? nextProp[HTML$1] : undefined;
            var lastHtml = lastProp ? lastProp[HTML$1] : undefined;
            if (nextHtml != null) {
              if (lastHtml !== nextHtml) {
                (updatePayload = updatePayload || []).push(propKey, nextHtml);
              }
            }
          } else if (propKey === CHILDREN) {
            if (typeof nextProp === "string" || typeof nextProp === "number") {
              (updatePayload = updatePayload || []).push(propKey, "" + nextProp);
            }
          } else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING)
            ;
          else if (registrationNameDependencies.hasOwnProperty(propKey)) {
            if (nextProp != null) {
              if (typeof nextProp !== "function") {
                warnForInvalidEventListener(propKey, nextProp);
              }
              if (propKey === "onScroll") {
                listenToNonDelegatedEvent("scroll", domElement);
              }
            }
            if (!updatePayload && lastProp !== nextProp) {
              updatePayload = [];
            }
          } else {
            (updatePayload = updatePayload || []).push(propKey, nextProp);
          }
        }
        if (styleUpdates) {
          {
            validateShorthandPropertyCollisionInDev(styleUpdates, nextProps[STYLE]);
          }
          (updatePayload = updatePayload || []).push(STYLE, styleUpdates);
        }
        return updatePayload;
      }
      function updateProperties(domElement, updatePayload, tag, lastRawProps, nextRawProps) {
        if (tag === "input" && nextRawProps.type === "radio" && nextRawProps.name != null) {
          updateChecked(domElement, nextRawProps);
        }
        var wasCustomComponentTag = isCustomComponent(tag, lastRawProps);
        var isCustomComponentTag = isCustomComponent(tag, nextRawProps);
        updateDOMProperties(domElement, updatePayload, wasCustomComponentTag, isCustomComponentTag);
        switch (tag) {
          case "input":
            updateWrapper(domElement, nextRawProps);
            break;
          case "textarea":
            updateWrapper$1(domElement, nextRawProps);
            break;
          case "select":
            postUpdateWrapper(domElement, nextRawProps);
            break;
        }
      }
      function getPossibleStandardName(propName) {
        {
          var lowerCasedName = propName.toLowerCase();
          if (!possibleStandardNames.hasOwnProperty(lowerCasedName)) {
            return null;
          }
          return possibleStandardNames[lowerCasedName] || null;
        }
      }
      function diffHydratedProperties(domElement, tag, rawProps, parentNamespace, rootContainerElement, isConcurrentMode, shouldWarnDev) {
        var isCustomComponentTag;
        var extraAttributeNames;
        {
          isCustomComponentTag = isCustomComponent(tag, rawProps);
          validatePropertiesInDevelopment(tag, rawProps);
        }
        switch (tag) {
          case "dialog":
            listenToNonDelegatedEvent("cancel", domElement);
            listenToNonDelegatedEvent("close", domElement);
            break;
          case "iframe":
          case "object":
          case "embed":
            listenToNonDelegatedEvent("load", domElement);
            break;
          case "video":
          case "audio":
            for (var i = 0;i < mediaEventTypes.length; i++) {
              listenToNonDelegatedEvent(mediaEventTypes[i], domElement);
            }
            break;
          case "source":
            listenToNonDelegatedEvent("error", domElement);
            break;
          case "img":
          case "image":
          case "link":
            listenToNonDelegatedEvent("error", domElement);
            listenToNonDelegatedEvent("load", domElement);
            break;
          case "details":
            listenToNonDelegatedEvent("toggle", domElement);
            break;
          case "input":
            initWrapperState(domElement, rawProps);
            listenToNonDelegatedEvent("invalid", domElement);
            break;
          case "option":
            validateProps(domElement, rawProps);
            break;
          case "select":
            initWrapperState$1(domElement, rawProps);
            listenToNonDelegatedEvent("invalid", domElement);
            break;
          case "textarea":
            initWrapperState$2(domElement, rawProps);
            listenToNonDelegatedEvent("invalid", domElement);
            break;
        }
        assertValidProps(tag, rawProps);
        {
          extraAttributeNames = new Set;
          var attributes = domElement.attributes;
          for (var _i = 0;_i < attributes.length; _i++) {
            var name = attributes[_i].name.toLowerCase();
            switch (name) {
              case "value":
                break;
              case "checked":
                break;
              case "selected":
                break;
              default:
                extraAttributeNames.add(attributes[_i].name);
            }
          }
        }
        var updatePayload = null;
        for (var propKey in rawProps) {
          if (!rawProps.hasOwnProperty(propKey)) {
            continue;
          }
          var nextProp = rawProps[propKey];
          if (propKey === CHILDREN) {
            if (typeof nextProp === "string") {
              if (domElement.textContent !== nextProp) {
                if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                  checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                }
                updatePayload = [CHILDREN, nextProp];
              }
            } else if (typeof nextProp === "number") {
              if (domElement.textContent !== "" + nextProp) {
                if (rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
                  checkForUnmatchedText(domElement.textContent, nextProp, isConcurrentMode, shouldWarnDev);
                }
                updatePayload = [CHILDREN, "" + nextProp];
              }
            }
          } else if (registrationNameDependencies.hasOwnProperty(propKey)) {
            if (nextProp != null) {
              if (typeof nextProp !== "function") {
                warnForInvalidEventListener(propKey, nextProp);
              }
              if (propKey === "onScroll") {
                listenToNonDelegatedEvent("scroll", domElement);
              }
            }
          } else if (shouldWarnDev && true && typeof isCustomComponentTag === "boolean") {
            var serverValue = undefined;
            var propertyInfo = isCustomComponentTag && enableCustomElementPropertySupport ? null : getPropertyInfo(propKey);
            if (rawProps[SUPPRESS_HYDRATION_WARNING] === true)
              ;
            else if (propKey === SUPPRESS_CONTENT_EDITABLE_WARNING || propKey === SUPPRESS_HYDRATION_WARNING || propKey === "value" || propKey === "checked" || propKey === "selected")
              ;
            else if (propKey === DANGEROUSLY_SET_INNER_HTML) {
              var serverHTML = domElement.innerHTML;
              var nextHtml = nextProp ? nextProp[HTML$1] : undefined;
              if (nextHtml != null) {
                var expectedHTML = normalizeHTML(domElement, nextHtml);
                if (expectedHTML !== serverHTML) {
                  warnForPropDifference(propKey, serverHTML, expectedHTML);
                }
              }
            } else if (propKey === STYLE) {
              extraAttributeNames.delete(propKey);
              if (canDiffStyleForHydrationWarning) {
                var expectedStyle = createDangerousStringForStyles(nextProp);
                serverValue = domElement.getAttribute("style");
                if (expectedStyle !== serverValue) {
                  warnForPropDifference(propKey, serverValue, expectedStyle);
                }
              }
            } else if (isCustomComponentTag && !enableCustomElementPropertySupport) {
              extraAttributeNames.delete(propKey.toLowerCase());
              serverValue = getValueForAttribute(domElement, propKey, nextProp);
              if (nextProp !== serverValue) {
                warnForPropDifference(propKey, serverValue, nextProp);
              }
            } else if (!shouldIgnoreAttribute(propKey, propertyInfo, isCustomComponentTag) && !shouldRemoveAttribute(propKey, nextProp, propertyInfo, isCustomComponentTag)) {
              var isMismatchDueToBadCasing = false;
              if (propertyInfo !== null) {
                extraAttributeNames.delete(propertyInfo.attributeName);
                serverValue = getValueForProperty(domElement, propKey, nextProp, propertyInfo);
              } else {
                var ownNamespace = parentNamespace;
                if (ownNamespace === HTML_NAMESPACE) {
                  ownNamespace = getIntrinsicNamespace(tag);
                }
                if (ownNamespace === HTML_NAMESPACE) {
                  extraAttributeNames.delete(propKey.toLowerCase());
                } else {
                  var standardName = getPossibleStandardName(propKey);
                  if (standardName !== null && standardName !== propKey) {
                    isMismatchDueToBadCasing = true;
                    extraAttributeNames.delete(standardName);
                  }
                  extraAttributeNames.delete(propKey);
                }
                serverValue = getValueForAttribute(domElement, propKey, nextProp);
              }
              var dontWarnCustomElement = enableCustomElementPropertySupport;
              if (!dontWarnCustomElement && nextProp !== serverValue && !isMismatchDueToBadCasing) {
                warnForPropDifference(propKey, serverValue, nextProp);
              }
            }
          }
        }
        {
          if (shouldWarnDev) {
            if (extraAttributeNames.size > 0 && rawProps[SUPPRESS_HYDRATION_WARNING] !== true) {
              warnForExtraAttributes(extraAttributeNames);
            }
          }
        }
        switch (tag) {
          case "input":
            track(domElement);
            postMountWrapper(domElement, rawProps, true);
            break;
          case "textarea":
            track(domElement);
            postMountWrapper$3(domElement);
            break;
          case "select":
          case "option":
            break;
          default:
            if (typeof rawProps.onClick === "function") {
              trapClickOnNonInteractiveElement(domElement);
            }
            break;
        }
        return updatePayload;
      }
      function diffHydratedText(textNode, text, isConcurrentMode) {
        var isDifferent = textNode.nodeValue !== text;
        return isDifferent;
      }
      function warnForDeletedHydratableElement(parentNode, child) {
        {
          if (didWarnInvalidHydration) {
            return;
          }
          didWarnInvalidHydration = true;
          error("Did not expect server HTML to contain a <%s> in <%s>.", child.nodeName.toLowerCase(), parentNode.nodeName.toLowerCase());
        }
      }
      function warnForDeletedHydratableText(parentNode, child) {
        {
          if (didWarnInvalidHydration) {
            return;
          }
          didWarnInvalidHydration = true;
          error('Did not expect server HTML to contain the text node "%s" in <%s>.', child.nodeValue, parentNode.nodeName.toLowerCase());
        }
      }
      function warnForInsertedHydratedElement(parentNode, tag, props) {
        {
          if (didWarnInvalidHydration) {
            return;
          }
          didWarnInvalidHydration = true;
          error("Expected server HTML to contain a matching <%s> in <%s>.", tag, parentNode.nodeName.toLowerCase());
        }
      }
      function warnForInsertedHydratedText(parentNode, text) {
        {
          if (text === "") {
            return;
          }
          if (didWarnInvalidHydration) {
            return;
          }
          didWarnInvalidHydration = true;
          error('Expected server HTML to contain a matching text node for "%s" in <%s>.', text, parentNode.nodeName.toLowerCase());
        }
      }
      function restoreControlledState$3(domElement, tag, props) {
        switch (tag) {
          case "input":
            restoreControlledState(domElement, props);
            return;
          case "textarea":
            restoreControlledState$2(domElement, props);
            return;
          case "select":
            restoreControlledState$1(domElement, props);
            return;
        }
      }
      var validateDOMNesting = function() {};
      var updatedAncestorInfo = function() {};
      {
        var specialTags = ["address", "applet", "area", "article", "aside", "base", "basefont", "bgsound", "blockquote", "body", "br", "button", "caption", "center", "col", "colgroup", "dd", "details", "dir", "div", "dl", "dt", "embed", "fieldset", "figcaption", "figure", "footer", "form", "frame", "frameset", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "iframe", "img", "input", "isindex", "li", "link", "listing", "main", "marquee", "menu", "menuitem", "meta", "nav", "noembed", "noframes", "noscript", "object", "ol", "p", "param", "plaintext", "pre", "script", "section", "select", "source", "style", "summary", "table", "tbody", "td", "template", "textarea", "tfoot", "th", "thead", "title", "tr", "track", "ul", "wbr", "xmp"];
        var inScopeTags = [
          "applet",
          "caption",
          "html",
          "table",
          "td",
          "th",
          "marquee",
          "object",
          "template",
          "foreignObject",
          "desc",
          "title"
        ];
        var buttonScopeTags = inScopeTags.concat(["button"]);
        var impliedEndTags = ["dd", "dt", "li", "option", "optgroup", "p", "rp", "rt"];
        var emptyAncestorInfo = {
          current: null,
          formTag: null,
          aTagInScope: null,
          buttonTagInScope: null,
          nobrTagInScope: null,
          pTagInButtonScope: null,
          listItemTagAutoclosing: null,
          dlItemTagAutoclosing: null
        };
        updatedAncestorInfo = function(oldInfo, tag) {
          var ancestorInfo = assign({}, oldInfo || emptyAncestorInfo);
          var info = {
            tag
          };
          if (inScopeTags.indexOf(tag) !== -1) {
            ancestorInfo.aTagInScope = null;
            ancestorInfo.buttonTagInScope = null;
            ancestorInfo.nobrTagInScope = null;
          }
          if (buttonScopeTags.indexOf(tag) !== -1) {
            ancestorInfo.pTagInButtonScope = null;
          }
          if (specialTags.indexOf(tag) !== -1 && tag !== "address" && tag !== "div" && tag !== "p") {
            ancestorInfo.listItemTagAutoclosing = null;
            ancestorInfo.dlItemTagAutoclosing = null;
          }
          ancestorInfo.current = info;
          if (tag === "form") {
            ancestorInfo.formTag = info;
          }
          if (tag === "a") {
            ancestorInfo.aTagInScope = info;
          }
          if (tag === "button") {
            ancestorInfo.buttonTagInScope = info;
          }
          if (tag === "nobr") {
            ancestorInfo.nobrTagInScope = info;
          }
          if (tag === "p") {
            ancestorInfo.pTagInButtonScope = info;
          }
          if (tag === "li") {
            ancestorInfo.listItemTagAutoclosing = info;
          }
          if (tag === "dd" || tag === "dt") {
            ancestorInfo.dlItemTagAutoclosing = info;
          }
          return ancestorInfo;
        };
        var isTagValidWithParent = function(tag, parentTag) {
          switch (parentTag) {
            case "select":
              return tag === "option" || tag === "optgroup" || tag === "#text";
            case "optgroup":
              return tag === "option" || tag === "#text";
            case "option":
              return tag === "#text";
            case "tr":
              return tag === "th" || tag === "td" || tag === "style" || tag === "script" || tag === "template";
            case "tbody":
            case "thead":
            case "tfoot":
              return tag === "tr" || tag === "style" || tag === "script" || tag === "template";
            case "colgroup":
              return tag === "col" || tag === "template";
            case "table":
              return tag === "caption" || tag === "colgroup" || tag === "tbody" || tag === "tfoot" || tag === "thead" || tag === "style" || tag === "script" || tag === "template";
            case "head":
              return tag === "base" || tag === "basefont" || tag === "bgsound" || tag === "link" || tag === "meta" || tag === "title" || tag === "noscript" || tag === "noframes" || tag === "style" || tag === "script" || tag === "template";
            case "html":
              return tag === "head" || tag === "body" || tag === "frameset";
            case "frameset":
              return tag === "frame";
            case "#document":
              return tag === "html";
          }
          switch (tag) {
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
              return parentTag !== "h1" && parentTag !== "h2" && parentTag !== "h3" && parentTag !== "h4" && parentTag !== "h5" && parentTag !== "h6";
            case "rp":
            case "rt":
              return impliedEndTags.indexOf(parentTag) === -1;
            case "body":
            case "caption":
            case "col":
            case "colgroup":
            case "frameset":
            case "frame":
            case "head":
            case "html":
            case "tbody":
            case "td":
            case "tfoot":
            case "th":
            case "thead":
            case "tr":
              return parentTag == null;
          }
          return true;
        };
        var findInvalidAncestorForTag = function(tag, ancestorInfo) {
          switch (tag) {
            case "address":
            case "article":
            case "aside":
            case "blockquote":
            case "center":
            case "details":
            case "dialog":
            case "dir":
            case "div":
            case "dl":
            case "fieldset":
            case "figcaption":
            case "figure":
            case "footer":
            case "header":
            case "hgroup":
            case "main":
            case "menu":
            case "nav":
            case "ol":
            case "p":
            case "section":
            case "summary":
            case "ul":
            case "pre":
            case "listing":
            case "table":
            case "hr":
            case "xmp":
            case "h1":
            case "h2":
            case "h3":
            case "h4":
            case "h5":
            case "h6":
              return ancestorInfo.pTagInButtonScope;
            case "form":
              return ancestorInfo.formTag || ancestorInfo.pTagInButtonScope;
            case "li":
              return ancestorInfo.listItemTagAutoclosing;
            case "dd":
            case "dt":
              return ancestorInfo.dlItemTagAutoclosing;
            case "button":
              return ancestorInfo.buttonTagInScope;
            case "a":
              return ancestorInfo.aTagInScope;
            case "nobr":
              return ancestorInfo.nobrTagInScope;
          }
          return null;
        };
        var didWarn$1 = {};
        validateDOMNesting = function(childTag, childText, ancestorInfo) {
          ancestorInfo = ancestorInfo || emptyAncestorInfo;
          var parentInfo = ancestorInfo.current;
          var parentTag = parentInfo && parentInfo.tag;
          if (childText != null) {
            if (childTag != null) {
              error("validateDOMNesting: when childText is passed, childTag should be null");
            }
            childTag = "#text";
          }
          var invalidParent = isTagValidWithParent(childTag, parentTag) ? null : parentInfo;
          var invalidAncestor = invalidParent ? null : findInvalidAncestorForTag(childTag, ancestorInfo);
          var invalidParentOrAncestor = invalidParent || invalidAncestor;
          if (!invalidParentOrAncestor) {
            return;
          }
          var ancestorTag = invalidParentOrAncestor.tag;
          var warnKey = !!invalidParent + "|" + childTag + "|" + ancestorTag;
          if (didWarn$1[warnKey]) {
            return;
          }
          didWarn$1[warnKey] = true;
          var tagDisplayName = childTag;
          var whitespaceInfo = "";
          if (childTag === "#text") {
            if (/\S/.test(childText)) {
              tagDisplayName = "Text nodes";
            } else {
              tagDisplayName = "Whitespace text nodes";
              whitespaceInfo = " Make sure you don't have any extra whitespace between tags on " + "each line of your source code.";
            }
          } else {
            tagDisplayName = "<" + childTag + ">";
          }
          if (invalidParent) {
            var info = "";
            if (ancestorTag === "table" && childTag === "tr") {
              info += " Add a <tbody>, <thead> or <tfoot> to your code to match the DOM tree generated by " + "the browser.";
            }
            error("validateDOMNesting(...): %s cannot appear as a child of <%s>.%s%s", tagDisplayName, ancestorTag, whitespaceInfo, info);
          } else {
            error("validateDOMNesting(...): %s cannot appear as a descendant of " + "<%s>.", tagDisplayName, ancestorTag);
          }
        };
      }
      var SUPPRESS_HYDRATION_WARNING$1 = "suppressHydrationWarning";
      var SUSPENSE_START_DATA = "$";
      var SUSPENSE_END_DATA = "/$";
      var SUSPENSE_PENDING_START_DATA = "$?";
      var SUSPENSE_FALLBACK_START_DATA = "$!";
      var STYLE$1 = "style";
      var eventsEnabled = null;
      var selectionInformation = null;
      function getRootHostContext(rootContainerInstance) {
        var type;
        var namespace;
        var nodeType = rootContainerInstance.nodeType;
        switch (nodeType) {
          case DOCUMENT_NODE:
          case DOCUMENT_FRAGMENT_NODE: {
            type = nodeType === DOCUMENT_NODE ? "#document" : "#fragment";
            var root2 = rootContainerInstance.documentElement;
            namespace = root2 ? root2.namespaceURI : getChildNamespace(null, "");
            break;
          }
          default: {
            var container = nodeType === COMMENT_NODE ? rootContainerInstance.parentNode : rootContainerInstance;
            var ownNamespace = container.namespaceURI || null;
            type = container.tagName;
            namespace = getChildNamespace(ownNamespace, type);
            break;
          }
        }
        {
          var validatedTag = type.toLowerCase();
          var ancestorInfo = updatedAncestorInfo(null, validatedTag);
          return {
            namespace,
            ancestorInfo
          };
        }
      }
      function getChildHostContext(parentHostContext, type, rootContainerInstance) {
        {
          var parentHostContextDev = parentHostContext;
          var namespace = getChildNamespace(parentHostContextDev.namespace, type);
          var ancestorInfo = updatedAncestorInfo(parentHostContextDev.ancestorInfo, type);
          return {
            namespace,
            ancestorInfo
          };
        }
      }
      function getPublicInstance(instance) {
        return instance;
      }
      function prepareForCommit(containerInfo) {
        eventsEnabled = isEnabled();
        selectionInformation = getSelectionInformation();
        var activeInstance = null;
        setEnabled(false);
        return activeInstance;
      }
      function resetAfterCommit(containerInfo) {
        restoreSelection(selectionInformation);
        setEnabled(eventsEnabled);
        eventsEnabled = null;
        selectionInformation = null;
      }
      function createInstance(type, props, rootContainerInstance, hostContext, internalInstanceHandle) {
        var parentNamespace;
        {
          var hostContextDev = hostContext;
          validateDOMNesting(type, null, hostContextDev.ancestorInfo);
          if (typeof props.children === "string" || typeof props.children === "number") {
            var string = "" + props.children;
            var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
            validateDOMNesting(null, string, ownAncestorInfo);
          }
          parentNamespace = hostContextDev.namespace;
        }
        var domElement = createElement(type, props, rootContainerInstance, parentNamespace);
        precacheFiberNode(internalInstanceHandle, domElement);
        updateFiberProps(domElement, props);
        return domElement;
      }
      function appendInitialChild(parentInstance, child) {
        parentInstance.appendChild(child);
      }
      function finalizeInitialChildren(domElement, type, props, rootContainerInstance, hostContext) {
        setInitialProperties(domElement, type, props, rootContainerInstance);
        switch (type) {
          case "button":
          case "input":
          case "select":
          case "textarea":
            return !!props.autoFocus;
          case "img":
            return true;
          default:
            return false;
        }
      }
      function prepareUpdate(domElement, type, oldProps, newProps, rootContainerInstance, hostContext) {
        {
          var hostContextDev = hostContext;
          if (typeof newProps.children !== typeof oldProps.children && (typeof newProps.children === "string" || typeof newProps.children === "number")) {
            var string = "" + newProps.children;
            var ownAncestorInfo = updatedAncestorInfo(hostContextDev.ancestorInfo, type);
            validateDOMNesting(null, string, ownAncestorInfo);
          }
        }
        return diffProperties(domElement, type, oldProps, newProps);
      }
      function shouldSetTextContent(type, props) {
        return type === "textarea" || type === "noscript" || typeof props.children === "string" || typeof props.children === "number" || typeof props.dangerouslySetInnerHTML === "object" && props.dangerouslySetInnerHTML !== null && props.dangerouslySetInnerHTML.__html != null;
      }
      function createTextInstance(text, rootContainerInstance, hostContext, internalInstanceHandle) {
        {
          var hostContextDev = hostContext;
          validateDOMNesting(null, text, hostContextDev.ancestorInfo);
        }
        var textNode = createTextNode(text, rootContainerInstance);
        precacheFiberNode(internalInstanceHandle, textNode);
        return textNode;
      }
      function getCurrentEventPriority() {
        var currentEvent = window.event;
        if (currentEvent === undefined) {
          return DefaultEventPriority;
        }
        return getEventPriority(currentEvent.type);
      }
      var scheduleTimeout = typeof setTimeout === "function" ? setTimeout : undefined;
      var cancelTimeout = typeof clearTimeout === "function" ? clearTimeout : undefined;
      var noTimeout = -1;
      var localPromise = typeof Promise === "function" ? Promise : undefined;
      var scheduleMicrotask = typeof queueMicrotask === "function" ? queueMicrotask : typeof localPromise !== "undefined" ? function(callback) {
        return localPromise.resolve(null).then(callback).catch(handleErrorInNextTick);
      } : scheduleTimeout;
      function handleErrorInNextTick(error2) {
        setTimeout(function() {
          throw error2;
        });
      }
      function commitMount(domElement, type, newProps, internalInstanceHandle) {
        switch (type) {
          case "button":
          case "input":
          case "select":
          case "textarea":
            if (newProps.autoFocus) {
              domElement.focus();
            }
            return;
          case "img": {
            if (newProps.src) {
              domElement.src = newProps.src;
            }
            return;
          }
        }
      }
      function commitUpdate(domElement, updatePayload, type, oldProps, newProps, internalInstanceHandle) {
        updateProperties(domElement, updatePayload, type, oldProps, newProps);
        updateFiberProps(domElement, newProps);
      }
      function resetTextContent(domElement) {
        setTextContent(domElement, "");
      }
      function commitTextUpdate(textInstance, oldText, newText) {
        textInstance.nodeValue = newText;
      }
      function appendChild(parentInstance, child) {
        parentInstance.appendChild(child);
      }
      function appendChildToContainer(container, child) {
        var parentNode;
        if (container.nodeType === COMMENT_NODE) {
          parentNode = container.parentNode;
          parentNode.insertBefore(child, container);
        } else {
          parentNode = container;
          parentNode.appendChild(child);
        }
        var reactRootContainer = container._reactRootContainer;
        if ((reactRootContainer === null || reactRootContainer === undefined) && parentNode.onclick === null) {
          trapClickOnNonInteractiveElement(parentNode);
        }
      }
      function insertBefore(parentInstance, child, beforeChild) {
        parentInstance.insertBefore(child, beforeChild);
      }
      function insertInContainerBefore(container, child, beforeChild) {
        if (container.nodeType === COMMENT_NODE) {
          container.parentNode.insertBefore(child, beforeChild);
        } else {
          container.insertBefore(child, beforeChild);
        }
      }
      function removeChild(parentInstance, child) {
        parentInstance.removeChild(child);
      }
      function removeChildFromContainer(container, child) {
        if (container.nodeType === COMMENT_NODE) {
          container.parentNode.removeChild(child);
        } else {
          container.removeChild(child);
        }
      }
      function clearSuspenseBoundary(parentInstance, suspenseInstance) {
        var node = suspenseInstance;
        var depth = 0;
        do {
          var nextNode = node.nextSibling;
          parentInstance.removeChild(node);
          if (nextNode && nextNode.nodeType === COMMENT_NODE) {
            var data = nextNode.data;
            if (data === SUSPENSE_END_DATA) {
              if (depth === 0) {
                parentInstance.removeChild(nextNode);
                retryIfBlockedOn(suspenseInstance);
                return;
              } else {
                depth--;
              }
            } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_PENDING_START_DATA || data === SUSPENSE_FALLBACK_START_DATA) {
              depth++;
            }
          }
          node = nextNode;
        } while (node);
        retryIfBlockedOn(suspenseInstance);
      }
      function clearSuspenseBoundaryFromContainer(container, suspenseInstance) {
        if (container.nodeType === COMMENT_NODE) {
          clearSuspenseBoundary(container.parentNode, suspenseInstance);
        } else if (container.nodeType === ELEMENT_NODE) {
          clearSuspenseBoundary(container, suspenseInstance);
        }
        retryIfBlockedOn(container);
      }
      function hideInstance(instance) {
        instance = instance;
        var style2 = instance.style;
        if (typeof style2.setProperty === "function") {
          style2.setProperty("display", "none", "important");
        } else {
          style2.display = "none";
        }
      }
      function hideTextInstance(textInstance) {
        textInstance.nodeValue = "";
      }
      function unhideInstance(instance, props) {
        instance = instance;
        var styleProp = props[STYLE$1];
        var display = styleProp !== undefined && styleProp !== null && styleProp.hasOwnProperty("display") ? styleProp.display : null;
        instance.style.display = dangerousStyleValue("display", display);
      }
      function unhideTextInstance(textInstance, text) {
        textInstance.nodeValue = text;
      }
      function clearContainer(container) {
        if (container.nodeType === ELEMENT_NODE) {
          container.textContent = "";
        } else if (container.nodeType === DOCUMENT_NODE) {
          if (container.documentElement) {
            container.removeChild(container.documentElement);
          }
        }
      }
      function canHydrateInstance(instance, type, props) {
        if (instance.nodeType !== ELEMENT_NODE || type.toLowerCase() !== instance.nodeName.toLowerCase()) {
          return null;
        }
        return instance;
      }
      function canHydrateTextInstance(instance, text) {
        if (text === "" || instance.nodeType !== TEXT_NODE) {
          return null;
        }
        return instance;
      }
      function canHydrateSuspenseInstance(instance) {
        if (instance.nodeType !== COMMENT_NODE) {
          return null;
        }
        return instance;
      }
      function isSuspenseInstancePending(instance) {
        return instance.data === SUSPENSE_PENDING_START_DATA;
      }
      function isSuspenseInstanceFallback(instance) {
        return instance.data === SUSPENSE_FALLBACK_START_DATA;
      }
      function getSuspenseInstanceFallbackErrorDetails(instance) {
        var dataset = instance.nextSibling && instance.nextSibling.dataset;
        var digest, message, stack;
        if (dataset) {
          digest = dataset.dgst;
          {
            message = dataset.msg;
            stack = dataset.stck;
          }
        }
        {
          return {
            message,
            digest,
            stack
          };
        }
      }
      function registerSuspenseInstanceRetry(instance, callback) {
        instance._reactRetry = callback;
      }
      function getNextHydratable(node) {
        for (;node != null; node = node.nextSibling) {
          var nodeType = node.nodeType;
          if (nodeType === ELEMENT_NODE || nodeType === TEXT_NODE) {
            break;
          }
          if (nodeType === COMMENT_NODE) {
            var nodeData = node.data;
            if (nodeData === SUSPENSE_START_DATA || nodeData === SUSPENSE_FALLBACK_START_DATA || nodeData === SUSPENSE_PENDING_START_DATA) {
              break;
            }
            if (nodeData === SUSPENSE_END_DATA) {
              return null;
            }
          }
        }
        return node;
      }
      function getNextHydratableSibling(instance) {
        return getNextHydratable(instance.nextSibling);
      }
      function getFirstHydratableChild(parentInstance) {
        return getNextHydratable(parentInstance.firstChild);
      }
      function getFirstHydratableChildWithinContainer(parentContainer) {
        return getNextHydratable(parentContainer.firstChild);
      }
      function getFirstHydratableChildWithinSuspenseInstance(parentInstance) {
        return getNextHydratable(parentInstance.nextSibling);
      }
      function hydrateInstance(instance, type, props, rootContainerInstance, hostContext, internalInstanceHandle, shouldWarnDev) {
        precacheFiberNode(internalInstanceHandle, instance);
        updateFiberProps(instance, props);
        var parentNamespace;
        {
          var hostContextDev = hostContext;
          parentNamespace = hostContextDev.namespace;
        }
        var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
        return diffHydratedProperties(instance, type, props, parentNamespace, rootContainerInstance, isConcurrentMode, shouldWarnDev);
      }
      function hydrateTextInstance(textInstance, text, internalInstanceHandle, shouldWarnDev) {
        precacheFiberNode(internalInstanceHandle, textInstance);
        var isConcurrentMode = (internalInstanceHandle.mode & ConcurrentMode) !== NoMode;
        return diffHydratedText(textInstance, text);
      }
      function hydrateSuspenseInstance(suspenseInstance, internalInstanceHandle) {
        precacheFiberNode(internalInstanceHandle, suspenseInstance);
      }
      function getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance) {
        var node = suspenseInstance.nextSibling;
        var depth = 0;
        while (node) {
          if (node.nodeType === COMMENT_NODE) {
            var data = node.data;
            if (data === SUSPENSE_END_DATA) {
              if (depth === 0) {
                return getNextHydratableSibling(node);
              } else {
                depth--;
              }
            } else if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
              depth++;
            }
          }
          node = node.nextSibling;
        }
        return null;
      }
      function getParentSuspenseInstance(targetInstance) {
        var node = targetInstance.previousSibling;
        var depth = 0;
        while (node) {
          if (node.nodeType === COMMENT_NODE) {
            var data = node.data;
            if (data === SUSPENSE_START_DATA || data === SUSPENSE_FALLBACK_START_DATA || data === SUSPENSE_PENDING_START_DATA) {
              if (depth === 0) {
                return node;
              } else {
                depth--;
              }
            } else if (data === SUSPENSE_END_DATA) {
              depth++;
            }
          }
          node = node.previousSibling;
        }
        return null;
      }
      function commitHydratedContainer(container) {
        retryIfBlockedOn(container);
      }
      function commitHydratedSuspenseInstance(suspenseInstance) {
        retryIfBlockedOn(suspenseInstance);
      }
      function shouldDeleteUnhydratedTailInstances(parentType) {
        return parentType !== "head" && parentType !== "body";
      }
      function didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, text, isConcurrentMode) {
        var shouldWarnDev = true;
        checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);
      }
      function didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, text, isConcurrentMode) {
        if (parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
          var shouldWarnDev = true;
          checkForUnmatchedText(textInstance.nodeValue, text, isConcurrentMode, shouldWarnDev);
        }
      }
      function didNotHydrateInstanceWithinContainer(parentContainer, instance) {
        {
          if (instance.nodeType === ELEMENT_NODE) {
            warnForDeletedHydratableElement(parentContainer, instance);
          } else if (instance.nodeType === COMMENT_NODE)
            ;
          else {
            warnForDeletedHydratableText(parentContainer, instance);
          }
        }
      }
      function didNotHydrateInstanceWithinSuspenseInstance(parentInstance, instance) {
        {
          var parentNode = parentInstance.parentNode;
          if (parentNode !== null) {
            if (instance.nodeType === ELEMENT_NODE) {
              warnForDeletedHydratableElement(parentNode, instance);
            } else if (instance.nodeType === COMMENT_NODE)
              ;
            else {
              warnForDeletedHydratableText(parentNode, instance);
            }
          }
        }
      }
      function didNotHydrateInstance(parentType, parentProps, parentInstance, instance, isConcurrentMode) {
        {
          if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
            if (instance.nodeType === ELEMENT_NODE) {
              warnForDeletedHydratableElement(parentInstance, instance);
            } else if (instance.nodeType === COMMENT_NODE)
              ;
            else {
              warnForDeletedHydratableText(parentInstance, instance);
            }
          }
        }
      }
      function didNotFindHydratableInstanceWithinContainer(parentContainer, type, props) {
        {
          warnForInsertedHydratedElement(parentContainer, type);
        }
      }
      function didNotFindHydratableTextInstanceWithinContainer(parentContainer, text) {
        {
          warnForInsertedHydratedText(parentContainer, text);
        }
      }
      function didNotFindHydratableInstanceWithinSuspenseInstance(parentInstance, type, props) {
        {
          var parentNode = parentInstance.parentNode;
          if (parentNode !== null)
            warnForInsertedHydratedElement(parentNode, type);
        }
      }
      function didNotFindHydratableTextInstanceWithinSuspenseInstance(parentInstance, text) {
        {
          var parentNode = parentInstance.parentNode;
          if (parentNode !== null)
            warnForInsertedHydratedText(parentNode, text);
        }
      }
      function didNotFindHydratableInstance(parentType, parentProps, parentInstance, type, props, isConcurrentMode) {
        {
          if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
            warnForInsertedHydratedElement(parentInstance, type);
          }
        }
      }
      function didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, text, isConcurrentMode) {
        {
          if (isConcurrentMode || parentProps[SUPPRESS_HYDRATION_WARNING$1] !== true) {
            warnForInsertedHydratedText(parentInstance, text);
          }
        }
      }
      function errorHydratingContainer(parentContainer) {
        {
          error("An error occurred during hydration. The server HTML was replaced with client content in <%s>.", parentContainer.nodeName.toLowerCase());
        }
      }
      function preparePortalMount(portalInstance) {
        listenToAllSupportedEvents(portalInstance);
      }
      var randomKey = Math.random().toString(36).slice(2);
      var internalInstanceKey = "__reactFiber$" + randomKey;
      var internalPropsKey = "__reactProps$" + randomKey;
      var internalContainerInstanceKey = "__reactContainer$" + randomKey;
      var internalEventHandlersKey = "__reactEvents$" + randomKey;
      var internalEventHandlerListenersKey = "__reactListeners$" + randomKey;
      var internalEventHandlesSetKey = "__reactHandles$" + randomKey;
      function detachDeletedInstance(node) {
        delete node[internalInstanceKey];
        delete node[internalPropsKey];
        delete node[internalEventHandlersKey];
        delete node[internalEventHandlerListenersKey];
        delete node[internalEventHandlesSetKey];
      }
      function precacheFiberNode(hostInst, node) {
        node[internalInstanceKey] = hostInst;
      }
      function markContainerAsRoot(hostRoot, node) {
        node[internalContainerInstanceKey] = hostRoot;
      }
      function unmarkContainerAsRoot(node) {
        node[internalContainerInstanceKey] = null;
      }
      function isContainerMarkedAsRoot(node) {
        return !!node[internalContainerInstanceKey];
      }
      function getClosestInstanceFromNode(targetNode) {
        var targetInst = targetNode[internalInstanceKey];
        if (targetInst) {
          return targetInst;
        }
        var parentNode = targetNode.parentNode;
        while (parentNode) {
          targetInst = parentNode[internalContainerInstanceKey] || parentNode[internalInstanceKey];
          if (targetInst) {
            var alternate = targetInst.alternate;
            if (targetInst.child !== null || alternate !== null && alternate.child !== null) {
              var suspenseInstance = getParentSuspenseInstance(targetNode);
              while (suspenseInstance !== null) {
                var targetSuspenseInst = suspenseInstance[internalInstanceKey];
                if (targetSuspenseInst) {
                  return targetSuspenseInst;
                }
                suspenseInstance = getParentSuspenseInstance(suspenseInstance);
              }
            }
            return targetInst;
          }
          targetNode = parentNode;
          parentNode = targetNode.parentNode;
        }
        return null;
      }
      function getInstanceFromNode(node) {
        var inst = node[internalInstanceKey] || node[internalContainerInstanceKey];
        if (inst) {
          if (inst.tag === HostComponent || inst.tag === HostText || inst.tag === SuspenseComponent || inst.tag === HostRoot) {
            return inst;
          } else {
            return null;
          }
        }
        return null;
      }
      function getNodeFromInstance(inst) {
        if (inst.tag === HostComponent || inst.tag === HostText) {
          return inst.stateNode;
        }
        throw new Error("getNodeFromInstance: Invalid argument.");
      }
      function getFiberCurrentPropsFromNode(node) {
        return node[internalPropsKey] || null;
      }
      function updateFiberProps(node, props) {
        node[internalPropsKey] = props;
      }
      function getEventListenerSet(node) {
        var elementListenerSet = node[internalEventHandlersKey];
        if (elementListenerSet === undefined) {
          elementListenerSet = node[internalEventHandlersKey] = new Set;
        }
        return elementListenerSet;
      }
      var loggedTypeFailures = {};
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame$1.setExtraStackFrame(null);
          }
        }
      }
      function checkPropTypes(typeSpecs, values, location2, componentName, element) {
        {
          var has2 = Function.call.bind(hasOwnProperty);
          for (var typeSpecName in typeSpecs) {
            if (has2(typeSpecs, typeSpecName)) {
              var error$1 = undefined;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; " + "it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`." + "This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  err.name = "Invariant Violation";
                  throw err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error("%s: type specification of %s" + " `%s` is invalid; the type checker " + "function must return `null` or an `Error` but returned a %s. " + "You may have forgotten to pass an argument to the type checker " + "creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and " + "shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
              }
              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error("Failed %s type: %s", location2, error$1.message);
                setCurrentlyValidatingElement(null);
              }
            }
          }
        }
      }
      var valueStack = [];
      var fiberStack;
      {
        fiberStack = [];
      }
      var index = -1;
      function createCursor(defaultValue) {
        return {
          current: defaultValue
        };
      }
      function pop(cursor, fiber) {
        if (index < 0) {
          {
            error("Unexpected pop.");
          }
          return;
        }
        {
          if (fiber !== fiberStack[index]) {
            error("Unexpected Fiber popped.");
          }
        }
        cursor.current = valueStack[index];
        valueStack[index] = null;
        {
          fiberStack[index] = null;
        }
        index--;
      }
      function push(cursor, value, fiber) {
        index++;
        valueStack[index] = cursor.current;
        {
          fiberStack[index] = fiber;
        }
        cursor.current = value;
      }
      var warnedAboutMissingGetChildContext;
      {
        warnedAboutMissingGetChildContext = {};
      }
      var emptyContextObject = {};
      {
        Object.freeze(emptyContextObject);
      }
      var contextStackCursor = createCursor(emptyContextObject);
      var didPerformWorkStackCursor = createCursor(false);
      var previousContext = emptyContextObject;
      function getUnmaskedContext(workInProgress2, Component, didPushOwnContextIfProvider) {
        {
          if (didPushOwnContextIfProvider && isContextProvider(Component)) {
            return previousContext;
          }
          return contextStackCursor.current;
        }
      }
      function cacheContext(workInProgress2, unmaskedContext, maskedContext) {
        {
          var instance = workInProgress2.stateNode;
          instance.__reactInternalMemoizedUnmaskedChildContext = unmaskedContext;
          instance.__reactInternalMemoizedMaskedChildContext = maskedContext;
        }
      }
      function getMaskedContext(workInProgress2, unmaskedContext) {
        {
          var type = workInProgress2.type;
          var contextTypes = type.contextTypes;
          if (!contextTypes) {
            return emptyContextObject;
          }
          var instance = workInProgress2.stateNode;
          if (instance && instance.__reactInternalMemoizedUnmaskedChildContext === unmaskedContext) {
            return instance.__reactInternalMemoizedMaskedChildContext;
          }
          var context = {};
          for (var key in contextTypes) {
            context[key] = unmaskedContext[key];
          }
          {
            var name = getComponentNameFromFiber(workInProgress2) || "Unknown";
            checkPropTypes(contextTypes, context, "context", name);
          }
          if (instance) {
            cacheContext(workInProgress2, unmaskedContext, context);
          }
          return context;
        }
      }
      function hasContextChanged() {
        {
          return didPerformWorkStackCursor.current;
        }
      }
      function isContextProvider(type) {
        {
          var childContextTypes = type.childContextTypes;
          return childContextTypes !== null && childContextTypes !== undefined;
        }
      }
      function popContext(fiber) {
        {
          pop(didPerformWorkStackCursor, fiber);
          pop(contextStackCursor, fiber);
        }
      }
      function popTopLevelContextObject(fiber) {
        {
          pop(didPerformWorkStackCursor, fiber);
          pop(contextStackCursor, fiber);
        }
      }
      function pushTopLevelContextObject(fiber, context, didChange) {
        {
          if (contextStackCursor.current !== emptyContextObject) {
            throw new Error("Unexpected context found on stack. " + "This error is likely caused by a bug in React. Please file an issue.");
          }
          push(contextStackCursor, context, fiber);
          push(didPerformWorkStackCursor, didChange, fiber);
        }
      }
      function processChildContext(fiber, type, parentContext) {
        {
          var instance = fiber.stateNode;
          var childContextTypes = type.childContextTypes;
          if (typeof instance.getChildContext !== "function") {
            {
              var componentName = getComponentNameFromFiber(fiber) || "Unknown";
              if (!warnedAboutMissingGetChildContext[componentName]) {
                warnedAboutMissingGetChildContext[componentName] = true;
                error("%s.childContextTypes is specified but there is no getChildContext() method " + "on the instance. You can either define getChildContext() on %s or remove " + "childContextTypes from it.", componentName, componentName);
              }
            }
            return parentContext;
          }
          var childContext = instance.getChildContext();
          for (var contextKey in childContext) {
            if (!(contextKey in childContextTypes)) {
              throw new Error((getComponentNameFromFiber(fiber) || "Unknown") + '.getChildContext(): key "' + contextKey + '" is not defined in childContextTypes.');
            }
          }
          {
            var name = getComponentNameFromFiber(fiber) || "Unknown";
            checkPropTypes(childContextTypes, childContext, "child context", name);
          }
          return assign({}, parentContext, childContext);
        }
      }
      function pushContextProvider(workInProgress2) {
        {
          var instance = workInProgress2.stateNode;
          var memoizedMergedChildContext = instance && instance.__reactInternalMemoizedMergedChildContext || emptyContextObject;
          previousContext = contextStackCursor.current;
          push(contextStackCursor, memoizedMergedChildContext, workInProgress2);
          push(didPerformWorkStackCursor, didPerformWorkStackCursor.current, workInProgress2);
          return true;
        }
      }
      function invalidateContextProvider(workInProgress2, type, didChange) {
        {
          var instance = workInProgress2.stateNode;
          if (!instance) {
            throw new Error("Expected to have an instance by this point. " + "This error is likely caused by a bug in React. Please file an issue.");
          }
          if (didChange) {
            var mergedContext = processChildContext(workInProgress2, type, previousContext);
            instance.__reactInternalMemoizedMergedChildContext = mergedContext;
            pop(didPerformWorkStackCursor, workInProgress2);
            pop(contextStackCursor, workInProgress2);
            push(contextStackCursor, mergedContext, workInProgress2);
            push(didPerformWorkStackCursor, didChange, workInProgress2);
          } else {
            pop(didPerformWorkStackCursor, workInProgress2);
            push(didPerformWorkStackCursor, didChange, workInProgress2);
          }
        }
      }
      function findCurrentUnmaskedContext(fiber) {
        {
          if (!isFiberMounted(fiber) || fiber.tag !== ClassComponent) {
            throw new Error("Expected subtree parent to be a mounted class component. " + "This error is likely caused by a bug in React. Please file an issue.");
          }
          var node = fiber;
          do {
            switch (node.tag) {
              case HostRoot:
                return node.stateNode.context;
              case ClassComponent: {
                var Component = node.type;
                if (isContextProvider(Component)) {
                  return node.stateNode.__reactInternalMemoizedMergedChildContext;
                }
                break;
              }
            }
            node = node.return;
          } while (node !== null);
          throw new Error("Found unexpected detached subtree parent. " + "This error is likely caused by a bug in React. Please file an issue.");
        }
      }
      var LegacyRoot = 0;
      var ConcurrentRoot = 1;
      var syncQueue = null;
      var includesLegacySyncCallbacks = false;
      var isFlushingSyncQueue = false;
      function scheduleSyncCallback(callback) {
        if (syncQueue === null) {
          syncQueue = [callback];
        } else {
          syncQueue.push(callback);
        }
      }
      function scheduleLegacySyncCallback(callback) {
        includesLegacySyncCallbacks = true;
        scheduleSyncCallback(callback);
      }
      function flushSyncCallbacksOnlyInLegacyMode() {
        if (includesLegacySyncCallbacks) {
          flushSyncCallbacks();
        }
      }
      function flushSyncCallbacks() {
        if (!isFlushingSyncQueue && syncQueue !== null) {
          isFlushingSyncQueue = true;
          var i = 0;
          var previousUpdatePriority = getCurrentUpdatePriority();
          try {
            var isSync = true;
            var queue = syncQueue;
            setCurrentUpdatePriority(DiscreteEventPriority);
            for (;i < queue.length; i++) {
              var callback = queue[i];
              do {
                callback = callback(isSync);
              } while (callback !== null);
            }
            syncQueue = null;
            includesLegacySyncCallbacks = false;
          } catch (error2) {
            if (syncQueue !== null) {
              syncQueue = syncQueue.slice(i + 1);
            }
            scheduleCallback(ImmediatePriority, flushSyncCallbacks);
            throw error2;
          } finally {
            setCurrentUpdatePriority(previousUpdatePriority);
            isFlushingSyncQueue = false;
          }
        }
        return null;
      }
      var forkStack = [];
      var forkStackIndex = 0;
      var treeForkProvider = null;
      var treeForkCount = 0;
      var idStack = [];
      var idStackIndex = 0;
      var treeContextProvider = null;
      var treeContextId = 1;
      var treeContextOverflow = "";
      function isForkedChild(workInProgress2) {
        warnIfNotHydrating();
        return (workInProgress2.flags & Forked) !== NoFlags;
      }
      function getForksAtLevel(workInProgress2) {
        warnIfNotHydrating();
        return treeForkCount;
      }
      function getTreeId() {
        var overflow = treeContextOverflow;
        var idWithLeadingBit = treeContextId;
        var id = idWithLeadingBit & ~getLeadingBit(idWithLeadingBit);
        return id.toString(32) + overflow;
      }
      function pushTreeFork(workInProgress2, totalChildren) {
        warnIfNotHydrating();
        forkStack[forkStackIndex++] = treeForkCount;
        forkStack[forkStackIndex++] = treeForkProvider;
        treeForkProvider = workInProgress2;
        treeForkCount = totalChildren;
      }
      function pushTreeId(workInProgress2, totalChildren, index2) {
        warnIfNotHydrating();
        idStack[idStackIndex++] = treeContextId;
        idStack[idStackIndex++] = treeContextOverflow;
        idStack[idStackIndex++] = treeContextProvider;
        treeContextProvider = workInProgress2;
        var baseIdWithLeadingBit = treeContextId;
        var baseOverflow = treeContextOverflow;
        var baseLength = getBitLength(baseIdWithLeadingBit) - 1;
        var baseId = baseIdWithLeadingBit & ~(1 << baseLength);
        var slot = index2 + 1;
        var length = getBitLength(totalChildren) + baseLength;
        if (length > 30) {
          var numberOfOverflowBits = baseLength - baseLength % 5;
          var newOverflowBits = (1 << numberOfOverflowBits) - 1;
          var newOverflow = (baseId & newOverflowBits).toString(32);
          var restOfBaseId = baseId >> numberOfOverflowBits;
          var restOfBaseLength = baseLength - numberOfOverflowBits;
          var restOfLength = getBitLength(totalChildren) + restOfBaseLength;
          var restOfNewBits = slot << restOfBaseLength;
          var id = restOfNewBits | restOfBaseId;
          var overflow = newOverflow + baseOverflow;
          treeContextId = 1 << restOfLength | id;
          treeContextOverflow = overflow;
        } else {
          var newBits = slot << baseLength;
          var _id = newBits | baseId;
          var _overflow = baseOverflow;
          treeContextId = 1 << length | _id;
          treeContextOverflow = _overflow;
        }
      }
      function pushMaterializedTreeId(workInProgress2) {
        warnIfNotHydrating();
        var returnFiber = workInProgress2.return;
        if (returnFiber !== null) {
          var numberOfForks = 1;
          var slotIndex = 0;
          pushTreeFork(workInProgress2, numberOfForks);
          pushTreeId(workInProgress2, numberOfForks, slotIndex);
        }
      }
      function getBitLength(number) {
        return 32 - clz32(number);
      }
      function getLeadingBit(id) {
        return 1 << getBitLength(id) - 1;
      }
      function popTreeContext(workInProgress2) {
        while (workInProgress2 === treeForkProvider) {
          treeForkProvider = forkStack[--forkStackIndex];
          forkStack[forkStackIndex] = null;
          treeForkCount = forkStack[--forkStackIndex];
          forkStack[forkStackIndex] = null;
        }
        while (workInProgress2 === treeContextProvider) {
          treeContextProvider = idStack[--idStackIndex];
          idStack[idStackIndex] = null;
          treeContextOverflow = idStack[--idStackIndex];
          idStack[idStackIndex] = null;
          treeContextId = idStack[--idStackIndex];
          idStack[idStackIndex] = null;
        }
      }
      function getSuspendedTreeContext() {
        warnIfNotHydrating();
        if (treeContextProvider !== null) {
          return {
            id: treeContextId,
            overflow: treeContextOverflow
          };
        } else {
          return null;
        }
      }
      function restoreSuspendedTreeContext(workInProgress2, suspendedContext) {
        warnIfNotHydrating();
        idStack[idStackIndex++] = treeContextId;
        idStack[idStackIndex++] = treeContextOverflow;
        idStack[idStackIndex++] = treeContextProvider;
        treeContextId = suspendedContext.id;
        treeContextOverflow = suspendedContext.overflow;
        treeContextProvider = workInProgress2;
      }
      function warnIfNotHydrating() {
        {
          if (!getIsHydrating()) {
            error("Expected to be hydrating. This is a bug in React. Please file " + "an issue.");
          }
        }
      }
      var hydrationParentFiber = null;
      var nextHydratableInstance = null;
      var isHydrating = false;
      var didSuspendOrErrorDEV = false;
      var hydrationErrors = null;
      function warnIfHydrating() {
        {
          if (isHydrating) {
            error("We should not be hydrating here. This is a bug in React. Please file a bug.");
          }
        }
      }
      function markDidThrowWhileHydratingDEV() {
        {
          didSuspendOrErrorDEV = true;
        }
      }
      function didSuspendOrErrorWhileHydratingDEV() {
        {
          return didSuspendOrErrorDEV;
        }
      }
      function enterHydrationState(fiber) {
        var parentInstance = fiber.stateNode.containerInfo;
        nextHydratableInstance = getFirstHydratableChildWithinContainer(parentInstance);
        hydrationParentFiber = fiber;
        isHydrating = true;
        hydrationErrors = null;
        didSuspendOrErrorDEV = false;
        return true;
      }
      function reenterHydrationStateFromDehydratedSuspenseInstance(fiber, suspenseInstance, treeContext) {
        nextHydratableInstance = getFirstHydratableChildWithinSuspenseInstance(suspenseInstance);
        hydrationParentFiber = fiber;
        isHydrating = true;
        hydrationErrors = null;
        didSuspendOrErrorDEV = false;
        if (treeContext !== null) {
          restoreSuspendedTreeContext(fiber, treeContext);
        }
        return true;
      }
      function warnUnhydratedInstance(returnFiber, instance) {
        {
          switch (returnFiber.tag) {
            case HostRoot: {
              didNotHydrateInstanceWithinContainer(returnFiber.stateNode.containerInfo, instance);
              break;
            }
            case HostComponent: {
              var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
              didNotHydrateInstance(returnFiber.type, returnFiber.memoizedProps, returnFiber.stateNode, instance, isConcurrentMode);
              break;
            }
            case SuspenseComponent: {
              var suspenseState = returnFiber.memoizedState;
              if (suspenseState.dehydrated !== null)
                didNotHydrateInstanceWithinSuspenseInstance(suspenseState.dehydrated, instance);
              break;
            }
          }
        }
      }
      function deleteHydratableInstance(returnFiber, instance) {
        warnUnhydratedInstance(returnFiber, instance);
        var childToDelete = createFiberFromHostInstanceForDeletion();
        childToDelete.stateNode = instance;
        childToDelete.return = returnFiber;
        var deletions = returnFiber.deletions;
        if (deletions === null) {
          returnFiber.deletions = [childToDelete];
          returnFiber.flags |= ChildDeletion;
        } else {
          deletions.push(childToDelete);
        }
      }
      function warnNonhydratedInstance(returnFiber, fiber) {
        {
          if (didSuspendOrErrorDEV) {
            return;
          }
          switch (returnFiber.tag) {
            case HostRoot: {
              var parentContainer = returnFiber.stateNode.containerInfo;
              switch (fiber.tag) {
                case HostComponent:
                  var type = fiber.type;
                  var props = fiber.pendingProps;
                  didNotFindHydratableInstanceWithinContainer(parentContainer, type);
                  break;
                case HostText:
                  var text = fiber.pendingProps;
                  didNotFindHydratableTextInstanceWithinContainer(parentContainer, text);
                  break;
              }
              break;
            }
            case HostComponent: {
              var parentType = returnFiber.type;
              var parentProps = returnFiber.memoizedProps;
              var parentInstance = returnFiber.stateNode;
              switch (fiber.tag) {
                case HostComponent: {
                  var _type = fiber.type;
                  var _props = fiber.pendingProps;
                  var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                  didNotFindHydratableInstance(parentType, parentProps, parentInstance, _type, _props, isConcurrentMode);
                  break;
                }
                case HostText: {
                  var _text = fiber.pendingProps;
                  var _isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                  didNotFindHydratableTextInstance(parentType, parentProps, parentInstance, _text, _isConcurrentMode);
                  break;
                }
              }
              break;
            }
            case SuspenseComponent: {
              var suspenseState = returnFiber.memoizedState;
              var _parentInstance = suspenseState.dehydrated;
              if (_parentInstance !== null)
                switch (fiber.tag) {
                  case HostComponent:
                    var _type2 = fiber.type;
                    var _props2 = fiber.pendingProps;
                    didNotFindHydratableInstanceWithinSuspenseInstance(_parentInstance, _type2);
                    break;
                  case HostText:
                    var _text2 = fiber.pendingProps;
                    didNotFindHydratableTextInstanceWithinSuspenseInstance(_parentInstance, _text2);
                    break;
                }
              break;
            }
            default:
              return;
          }
        }
      }
      function insertNonHydratedInstance(returnFiber, fiber) {
        fiber.flags = fiber.flags & ~Hydrating | Placement;
        warnNonhydratedInstance(returnFiber, fiber);
      }
      function tryHydrate(fiber, nextInstance) {
        switch (fiber.tag) {
          case HostComponent: {
            var type = fiber.type;
            var props = fiber.pendingProps;
            var instance = canHydrateInstance(nextInstance, type);
            if (instance !== null) {
              fiber.stateNode = instance;
              hydrationParentFiber = fiber;
              nextHydratableInstance = getFirstHydratableChild(instance);
              return true;
            }
            return false;
          }
          case HostText: {
            var text = fiber.pendingProps;
            var textInstance = canHydrateTextInstance(nextInstance, text);
            if (textInstance !== null) {
              fiber.stateNode = textInstance;
              hydrationParentFiber = fiber;
              nextHydratableInstance = null;
              return true;
            }
            return false;
          }
          case SuspenseComponent: {
            var suspenseInstance = canHydrateSuspenseInstance(nextInstance);
            if (suspenseInstance !== null) {
              var suspenseState = {
                dehydrated: suspenseInstance,
                treeContext: getSuspendedTreeContext(),
                retryLane: OffscreenLane
              };
              fiber.memoizedState = suspenseState;
              var dehydratedFragment = createFiberFromDehydratedFragment(suspenseInstance);
              dehydratedFragment.return = fiber;
              fiber.child = dehydratedFragment;
              hydrationParentFiber = fiber;
              nextHydratableInstance = null;
              return true;
            }
            return false;
          }
          default:
            return false;
        }
      }
      function shouldClientRenderOnMismatch(fiber) {
        return (fiber.mode & ConcurrentMode) !== NoMode && (fiber.flags & DidCapture) === NoFlags;
      }
      function throwOnHydrationMismatch(fiber) {
        throw new Error("Hydration failed because the initial UI does not match what was " + "rendered on the server.");
      }
      function tryToClaimNextHydratableInstance(fiber) {
        if (!isHydrating) {
          return;
        }
        var nextInstance = nextHydratableInstance;
        if (!nextInstance) {
          if (shouldClientRenderOnMismatch(fiber)) {
            warnNonhydratedInstance(hydrationParentFiber, fiber);
            throwOnHydrationMismatch();
          }
          insertNonHydratedInstance(hydrationParentFiber, fiber);
          isHydrating = false;
          hydrationParentFiber = fiber;
          return;
        }
        var firstAttemptedInstance = nextInstance;
        if (!tryHydrate(fiber, nextInstance)) {
          if (shouldClientRenderOnMismatch(fiber)) {
            warnNonhydratedInstance(hydrationParentFiber, fiber);
            throwOnHydrationMismatch();
          }
          nextInstance = getNextHydratableSibling(firstAttemptedInstance);
          var prevHydrationParentFiber = hydrationParentFiber;
          if (!nextInstance || !tryHydrate(fiber, nextInstance)) {
            insertNonHydratedInstance(hydrationParentFiber, fiber);
            isHydrating = false;
            hydrationParentFiber = fiber;
            return;
          }
          deleteHydratableInstance(prevHydrationParentFiber, firstAttemptedInstance);
        }
      }
      function prepareToHydrateHostInstance(fiber, rootContainerInstance, hostContext) {
        var instance = fiber.stateNode;
        var shouldWarnIfMismatchDev = !didSuspendOrErrorDEV;
        var updatePayload = hydrateInstance(instance, fiber.type, fiber.memoizedProps, rootContainerInstance, hostContext, fiber, shouldWarnIfMismatchDev);
        fiber.updateQueue = updatePayload;
        if (updatePayload !== null) {
          return true;
        }
        return false;
      }
      function prepareToHydrateHostTextInstance(fiber) {
        var textInstance = fiber.stateNode;
        var textContent = fiber.memoizedProps;
        var shouldUpdate = hydrateTextInstance(textInstance, textContent, fiber);
        if (shouldUpdate) {
          var returnFiber = hydrationParentFiber;
          if (returnFiber !== null) {
            switch (returnFiber.tag) {
              case HostRoot: {
                var parentContainer = returnFiber.stateNode.containerInfo;
                var isConcurrentMode = (returnFiber.mode & ConcurrentMode) !== NoMode;
                didNotMatchHydratedContainerTextInstance(parentContainer, textInstance, textContent, isConcurrentMode);
                break;
              }
              case HostComponent: {
                var parentType = returnFiber.type;
                var parentProps = returnFiber.memoizedProps;
                var parentInstance = returnFiber.stateNode;
                var _isConcurrentMode2 = (returnFiber.mode & ConcurrentMode) !== NoMode;
                didNotMatchHydratedTextInstance(parentType, parentProps, parentInstance, textInstance, textContent, _isConcurrentMode2);
                break;
              }
            }
          }
        }
        return shouldUpdate;
      }
      function prepareToHydrateHostSuspenseInstance(fiber) {
        var suspenseState = fiber.memoizedState;
        var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
        if (!suspenseInstance) {
          throw new Error("Expected to have a hydrated suspense instance. " + "This error is likely caused by a bug in React. Please file an issue.");
        }
        hydrateSuspenseInstance(suspenseInstance, fiber);
      }
      function skipPastDehydratedSuspenseInstance(fiber) {
        var suspenseState = fiber.memoizedState;
        var suspenseInstance = suspenseState !== null ? suspenseState.dehydrated : null;
        if (!suspenseInstance) {
          throw new Error("Expected to have a hydrated suspense instance. " + "This error is likely caused by a bug in React. Please file an issue.");
        }
        return getNextHydratableInstanceAfterSuspenseInstance(suspenseInstance);
      }
      function popToNextHostParent(fiber) {
        var parent = fiber.return;
        while (parent !== null && parent.tag !== HostComponent && parent.tag !== HostRoot && parent.tag !== SuspenseComponent) {
          parent = parent.return;
        }
        hydrationParentFiber = parent;
      }
      function popHydrationState(fiber) {
        if (fiber !== hydrationParentFiber) {
          return false;
        }
        if (!isHydrating) {
          popToNextHostParent(fiber);
          isHydrating = true;
          return false;
        }
        if (fiber.tag !== HostRoot && (fiber.tag !== HostComponent || shouldDeleteUnhydratedTailInstances(fiber.type) && !shouldSetTextContent(fiber.type, fiber.memoizedProps))) {
          var nextInstance = nextHydratableInstance;
          if (nextInstance) {
            if (shouldClientRenderOnMismatch(fiber)) {
              warnIfUnhydratedTailNodes(fiber);
              throwOnHydrationMismatch();
            } else {
              while (nextInstance) {
                deleteHydratableInstance(fiber, nextInstance);
                nextInstance = getNextHydratableSibling(nextInstance);
              }
            }
          }
        }
        popToNextHostParent(fiber);
        if (fiber.tag === SuspenseComponent) {
          nextHydratableInstance = skipPastDehydratedSuspenseInstance(fiber);
        } else {
          nextHydratableInstance = hydrationParentFiber ? getNextHydratableSibling(fiber.stateNode) : null;
        }
        return true;
      }
      function hasUnhydratedTailNodes() {
        return isHydrating && nextHydratableInstance !== null;
      }
      function warnIfUnhydratedTailNodes(fiber) {
        var nextInstance = nextHydratableInstance;
        while (nextInstance) {
          warnUnhydratedInstance(fiber, nextInstance);
          nextInstance = getNextHydratableSibling(nextInstance);
        }
      }
      function resetHydrationState() {
        hydrationParentFiber = null;
        nextHydratableInstance = null;
        isHydrating = false;
        didSuspendOrErrorDEV = false;
      }
      function upgradeHydrationErrorsToRecoverable() {
        if (hydrationErrors !== null) {
          queueRecoverableErrors(hydrationErrors);
          hydrationErrors = null;
        }
      }
      function getIsHydrating() {
        return isHydrating;
      }
      function queueHydrationError(error2) {
        if (hydrationErrors === null) {
          hydrationErrors = [error2];
        } else {
          hydrationErrors.push(error2);
        }
      }
      var ReactCurrentBatchConfig$1 = ReactSharedInternals.ReactCurrentBatchConfig;
      var NoTransition = null;
      function requestCurrentTransition() {
        return ReactCurrentBatchConfig$1.transition;
      }
      var ReactStrictModeWarnings = {
        recordUnsafeLifecycleWarnings: function(fiber, instance) {},
        flushPendingUnsafeLifecycleWarnings: function() {},
        recordLegacyContextWarning: function(fiber, instance) {},
        flushLegacyContextWarning: function() {},
        discardPendingWarnings: function() {}
      };
      {
        var findStrictRoot = function(fiber) {
          var maybeStrictRoot = null;
          var node = fiber;
          while (node !== null) {
            if (node.mode & StrictLegacyMode) {
              maybeStrictRoot = node;
            }
            node = node.return;
          }
          return maybeStrictRoot;
        };
        var setToSortedString = function(set2) {
          var array = [];
          set2.forEach(function(value) {
            array.push(value);
          });
          return array.sort().join(", ");
        };
        var pendingComponentWillMountWarnings = [];
        var pendingUNSAFE_ComponentWillMountWarnings = [];
        var pendingComponentWillReceivePropsWarnings = [];
        var pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
        var pendingComponentWillUpdateWarnings = [];
        var pendingUNSAFE_ComponentWillUpdateWarnings = [];
        var didWarnAboutUnsafeLifecycles = new Set;
        ReactStrictModeWarnings.recordUnsafeLifecycleWarnings = function(fiber, instance) {
          if (didWarnAboutUnsafeLifecycles.has(fiber.type)) {
            return;
          }
          if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
            pendingComponentWillMountWarnings.push(fiber);
          }
          if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillMount === "function") {
            pendingUNSAFE_ComponentWillMountWarnings.push(fiber);
          }
          if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
            pendingComponentWillReceivePropsWarnings.push(fiber);
          }
          if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillReceiveProps === "function") {
            pendingUNSAFE_ComponentWillReceivePropsWarnings.push(fiber);
          }
          if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
            pendingComponentWillUpdateWarnings.push(fiber);
          }
          if (fiber.mode & StrictLegacyMode && typeof instance.UNSAFE_componentWillUpdate === "function") {
            pendingUNSAFE_ComponentWillUpdateWarnings.push(fiber);
          }
        };
        ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings = function() {
          var componentWillMountUniqueNames = new Set;
          if (pendingComponentWillMountWarnings.length > 0) {
            pendingComponentWillMountWarnings.forEach(function(fiber) {
              componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
              didWarnAboutUnsafeLifecycles.add(fiber.type);
            });
            pendingComponentWillMountWarnings = [];
          }
          var UNSAFE_componentWillMountUniqueNames = new Set;
          if (pendingUNSAFE_ComponentWillMountWarnings.length > 0) {
            pendingUNSAFE_ComponentWillMountWarnings.forEach(function(fiber) {
              UNSAFE_componentWillMountUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
              didWarnAboutUnsafeLifecycles.add(fiber.type);
            });
            pendingUNSAFE_ComponentWillMountWarnings = [];
          }
          var componentWillReceivePropsUniqueNames = new Set;
          if (pendingComponentWillReceivePropsWarnings.length > 0) {
            pendingComponentWillReceivePropsWarnings.forEach(function(fiber) {
              componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
              didWarnAboutUnsafeLifecycles.add(fiber.type);
            });
            pendingComponentWillReceivePropsWarnings = [];
          }
          var UNSAFE_componentWillReceivePropsUniqueNames = new Set;
          if (pendingUNSAFE_ComponentWillReceivePropsWarnings.length > 0) {
            pendingUNSAFE_ComponentWillReceivePropsWarnings.forEach(function(fiber) {
              UNSAFE_componentWillReceivePropsUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
              didWarnAboutUnsafeLifecycles.add(fiber.type);
            });
            pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
          }
          var componentWillUpdateUniqueNames = new Set;
          if (pendingComponentWillUpdateWarnings.length > 0) {
            pendingComponentWillUpdateWarnings.forEach(function(fiber) {
              componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
              didWarnAboutUnsafeLifecycles.add(fiber.type);
            });
            pendingComponentWillUpdateWarnings = [];
          }
          var UNSAFE_componentWillUpdateUniqueNames = new Set;
          if (pendingUNSAFE_ComponentWillUpdateWarnings.length > 0) {
            pendingUNSAFE_ComponentWillUpdateWarnings.forEach(function(fiber) {
              UNSAFE_componentWillUpdateUniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
              didWarnAboutUnsafeLifecycles.add(fiber.type);
            });
            pendingUNSAFE_ComponentWillUpdateWarnings = [];
          }
          if (UNSAFE_componentWillMountUniqueNames.size > 0) {
            var sortedNames = setToSortedString(UNSAFE_componentWillMountUniqueNames);
            error("Using UNSAFE_componentWillMount in strict mode is not recommended and may indicate bugs in your code. " + `See https://reactjs.org/link/unsafe-component-lifecycles for details.

` + `* Move code with side effects to componentDidMount, and set initial state in the constructor.
` + `
Please update the following components: %s`, sortedNames);
          }
          if (UNSAFE_componentWillReceivePropsUniqueNames.size > 0) {
            var _sortedNames = setToSortedString(UNSAFE_componentWillReceivePropsUniqueNames);
            error("Using UNSAFE_componentWillReceiveProps in strict mode is not recommended " + "and may indicate bugs in your code. " + `See https://reactjs.org/link/unsafe-component-lifecycles for details.

` + `* Move data fetching code or side effects to componentDidUpdate.
` + "* If you're updating state whenever props change, " + "refactor your code to use memoization techniques or move it to " + `static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
` + `
Please update the following components: %s`, _sortedNames);
          }
          if (UNSAFE_componentWillUpdateUniqueNames.size > 0) {
            var _sortedNames2 = setToSortedString(UNSAFE_componentWillUpdateUniqueNames);
            error("Using UNSAFE_componentWillUpdate in strict mode is not recommended " + "and may indicate bugs in your code. " + `See https://reactjs.org/link/unsafe-component-lifecycles for details.

` + `* Move data fetching code or side effects to componentDidUpdate.
` + `
Please update the following components: %s`, _sortedNames2);
          }
          if (componentWillMountUniqueNames.size > 0) {
            var _sortedNames3 = setToSortedString(componentWillMountUniqueNames);
            warn("componentWillMount has been renamed, and is not recommended for use. " + `See https://reactjs.org/link/unsafe-component-lifecycles for details.

` + `* Move code with side effects to componentDidMount, and set initial state in the constructor.
` + "* Rename componentWillMount to UNSAFE_componentWillMount to suppress " + "this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. " + "To rename all deprecated lifecycles to their new names, you can run " + "`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n" + `
Please update the following components: %s`, _sortedNames3);
          }
          if (componentWillReceivePropsUniqueNames.size > 0) {
            var _sortedNames4 = setToSortedString(componentWillReceivePropsUniqueNames);
            warn("componentWillReceiveProps has been renamed, and is not recommended for use. " + `See https://reactjs.org/link/unsafe-component-lifecycles for details.

` + `* Move data fetching code or side effects to componentDidUpdate.
` + "* If you're updating state whenever props change, refactor your " + "code to use memoization techniques or move it to " + `static getDerivedStateFromProps. Learn more at: https://reactjs.org/link/derived-state
` + "* Rename componentWillReceiveProps to UNSAFE_componentWillReceiveProps to suppress " + "this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. " + "To rename all deprecated lifecycles to their new names, you can run " + "`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n" + `
Please update the following components: %s`, _sortedNames4);
          }
          if (componentWillUpdateUniqueNames.size > 0) {
            var _sortedNames5 = setToSortedString(componentWillUpdateUniqueNames);
            warn("componentWillUpdate has been renamed, and is not recommended for use. " + `See https://reactjs.org/link/unsafe-component-lifecycles for details.

` + `* Move data fetching code or side effects to componentDidUpdate.
` + "* Rename componentWillUpdate to UNSAFE_componentWillUpdate to suppress " + "this warning in non-strict mode. In React 18.x, only the UNSAFE_ name will work. " + "To rename all deprecated lifecycles to their new names, you can run " + "`npx react-codemod rename-unsafe-lifecycles` in your project source folder.\n" + `
Please update the following components: %s`, _sortedNames5);
          }
        };
        var pendingLegacyContextWarning = new Map;
        var didWarnAboutLegacyContext = new Set;
        ReactStrictModeWarnings.recordLegacyContextWarning = function(fiber, instance) {
          var strictRoot = findStrictRoot(fiber);
          if (strictRoot === null) {
            error("Expected to find a StrictMode component in a strict mode tree. " + "This error is likely caused by a bug in React. Please file an issue.");
            return;
          }
          if (didWarnAboutLegacyContext.has(fiber.type)) {
            return;
          }
          var warningsForRoot = pendingLegacyContextWarning.get(strictRoot);
          if (fiber.type.contextTypes != null || fiber.type.childContextTypes != null || instance !== null && typeof instance.getChildContext === "function") {
            if (warningsForRoot === undefined) {
              warningsForRoot = [];
              pendingLegacyContextWarning.set(strictRoot, warningsForRoot);
            }
            warningsForRoot.push(fiber);
          }
        };
        ReactStrictModeWarnings.flushLegacyContextWarning = function() {
          pendingLegacyContextWarning.forEach(function(fiberArray, strictRoot) {
            if (fiberArray.length === 0) {
              return;
            }
            var firstFiber = fiberArray[0];
            var uniqueNames = new Set;
            fiberArray.forEach(function(fiber) {
              uniqueNames.add(getComponentNameFromFiber(fiber) || "Component");
              didWarnAboutLegacyContext.add(fiber.type);
            });
            var sortedNames = setToSortedString(uniqueNames);
            try {
              setCurrentFiber(firstFiber);
              error("Legacy context API has been detected within a strict-mode tree." + `

The old API will be supported in all 16.x releases, but applications ` + "using it should migrate to the new version." + `

Please update the following components: %s` + `

Learn more about this warning here: https://reactjs.org/link/legacy-context`, sortedNames);
            } finally {
              resetCurrentFiber();
            }
          });
        };
        ReactStrictModeWarnings.discardPendingWarnings = function() {
          pendingComponentWillMountWarnings = [];
          pendingUNSAFE_ComponentWillMountWarnings = [];
          pendingComponentWillReceivePropsWarnings = [];
          pendingUNSAFE_ComponentWillReceivePropsWarnings = [];
          pendingComponentWillUpdateWarnings = [];
          pendingUNSAFE_ComponentWillUpdateWarnings = [];
          pendingLegacyContextWarning = new Map;
        };
      }
      var didWarnAboutMaps;
      var didWarnAboutGenerators;
      var didWarnAboutStringRefs;
      var ownerHasKeyUseWarning;
      var ownerHasFunctionTypeWarning;
      var warnForMissingKey = function(child, returnFiber) {};
      {
        didWarnAboutMaps = false;
        didWarnAboutGenerators = false;
        didWarnAboutStringRefs = {};
        ownerHasKeyUseWarning = {};
        ownerHasFunctionTypeWarning = {};
        warnForMissingKey = function(child, returnFiber) {
          if (child === null || typeof child !== "object") {
            return;
          }
          if (!child._store || child._store.validated || child.key != null) {
            return;
          }
          if (typeof child._store !== "object") {
            throw new Error("React Component in warnForMissingKey should have a _store. " + "This error is likely caused by a bug in React. Please file an issue.");
          }
          child._store.validated = true;
          var componentName = getComponentNameFromFiber(returnFiber) || "Component";
          if (ownerHasKeyUseWarning[componentName]) {
            return;
          }
          ownerHasKeyUseWarning[componentName] = true;
          error("Each child in a list should have a unique " + '"key" prop. See https://reactjs.org/link/warning-keys for ' + "more information.");
        };
      }
      function isReactClass(type) {
        return type.prototype && type.prototype.isReactComponent;
      }
      function coerceRef(returnFiber, current2, element) {
        var mixedRef = element.ref;
        if (mixedRef !== null && typeof mixedRef !== "function" && typeof mixedRef !== "object") {
          {
            if ((returnFiber.mode & StrictLegacyMode || warnAboutStringRefs) && !(element._owner && element._self && element._owner.stateNode !== element._self) && !(element._owner && element._owner.tag !== ClassComponent) && !(typeof element.type === "function" && !isReactClass(element.type)) && element._owner) {
              var componentName = getComponentNameFromFiber(returnFiber) || "Component";
              if (!didWarnAboutStringRefs[componentName]) {
                {
                  error('Component "%s" contains the string ref "%s". Support for string refs ' + "will be removed in a future major release. We recommend using " + "useRef() or createRef() instead. " + "Learn more about using refs safely here: " + "https://reactjs.org/link/strict-mode-string-ref", componentName, mixedRef);
                }
                didWarnAboutStringRefs[componentName] = true;
              }
            }
          }
          if (element._owner) {
            var owner = element._owner;
            var inst;
            if (owner) {
              var ownerFiber = owner;
              if (ownerFiber.tag !== ClassComponent) {
                throw new Error("Function components cannot have string refs. " + "We recommend using useRef() instead. " + "Learn more about using refs safely here: " + "https://reactjs.org/link/strict-mode-string-ref");
              }
              inst = ownerFiber.stateNode;
            }
            if (!inst) {
              throw new Error("Missing owner for string ref " + mixedRef + ". This error is likely caused by a " + "bug in React. Please file an issue.");
            }
            var resolvedInst = inst;
            {
              checkPropStringCoercion(mixedRef, "ref");
            }
            var stringRef = "" + mixedRef;
            if (current2 !== null && current2.ref !== null && typeof current2.ref === "function" && current2.ref._stringRef === stringRef) {
              return current2.ref;
            }
            var ref = function(value) {
              var refs = resolvedInst.refs;
              if (value === null) {
                delete refs[stringRef];
              } else {
                refs[stringRef] = value;
              }
            };
            ref._stringRef = stringRef;
            return ref;
          } else {
            if (typeof mixedRef !== "string") {
              throw new Error("Expected ref to be a function, a string, an object returned by React.createRef(), or null.");
            }
            if (!element._owner) {
              throw new Error("Element ref was specified as a string (" + mixedRef + ") but no owner was set. This could happen for one of" + ` the following reasons:
` + `1. You may be adding a ref to a function component
` + `2. You may be adding a ref to a component that was not created inside a component's render method
` + `3. You have multiple copies of React loaded
` + "See https://reactjs.org/link/refs-must-have-owner for more information.");
            }
          }
        }
        return mixedRef;
      }
      function throwOnInvalidObjectType(returnFiber, newChild) {
        var childString = Object.prototype.toString.call(newChild);
        throw new Error("Objects are not valid as a React child (found: " + (childString === "[object Object]" ? "object with keys {" + Object.keys(newChild).join(", ") + "}" : childString) + "). " + "If you meant to render a collection of children, use an array " + "instead.");
      }
      function warnOnFunctionType(returnFiber) {
        {
          var componentName = getComponentNameFromFiber(returnFiber) || "Component";
          if (ownerHasFunctionTypeWarning[componentName]) {
            return;
          }
          ownerHasFunctionTypeWarning[componentName] = true;
          error("Functions are not valid as a React child. This may happen if " + "you return a Component instead of <Component /> from render. " + "Or maybe you meant to call this function rather than return it.");
        }
      }
      function resolveLazy(lazyType) {
        var payload = lazyType._payload;
        var init = lazyType._init;
        return init(payload);
      }
      function ChildReconciler(shouldTrackSideEffects) {
        function deleteChild(returnFiber, childToDelete) {
          if (!shouldTrackSideEffects) {
            return;
          }
          var deletions = returnFiber.deletions;
          if (deletions === null) {
            returnFiber.deletions = [childToDelete];
            returnFiber.flags |= ChildDeletion;
          } else {
            deletions.push(childToDelete);
          }
        }
        function deleteRemainingChildren(returnFiber, currentFirstChild) {
          if (!shouldTrackSideEffects) {
            return null;
          }
          var childToDelete = currentFirstChild;
          while (childToDelete !== null) {
            deleteChild(returnFiber, childToDelete);
            childToDelete = childToDelete.sibling;
          }
          return null;
        }
        function mapRemainingChildren(returnFiber, currentFirstChild) {
          var existingChildren = new Map;
          var existingChild = currentFirstChild;
          while (existingChild !== null) {
            if (existingChild.key !== null) {
              existingChildren.set(existingChild.key, existingChild);
            } else {
              existingChildren.set(existingChild.index, existingChild);
            }
            existingChild = existingChild.sibling;
          }
          return existingChildren;
        }
        function useFiber(fiber, pendingProps) {
          var clone = createWorkInProgress(fiber, pendingProps);
          clone.index = 0;
          clone.sibling = null;
          return clone;
        }
        function placeChild(newFiber, lastPlacedIndex, newIndex) {
          newFiber.index = newIndex;
          if (!shouldTrackSideEffects) {
            newFiber.flags |= Forked;
            return lastPlacedIndex;
          }
          var current2 = newFiber.alternate;
          if (current2 !== null) {
            var oldIndex = current2.index;
            if (oldIndex < lastPlacedIndex) {
              newFiber.flags |= Placement;
              return lastPlacedIndex;
            } else {
              return oldIndex;
            }
          } else {
            newFiber.flags |= Placement;
            return lastPlacedIndex;
          }
        }
        function placeSingleChild(newFiber) {
          if (shouldTrackSideEffects && newFiber.alternate === null) {
            newFiber.flags |= Placement;
          }
          return newFiber;
        }
        function updateTextNode(returnFiber, current2, textContent, lanes) {
          if (current2 === null || current2.tag !== HostText) {
            var created = createFiberFromText(textContent, returnFiber.mode, lanes);
            created.return = returnFiber;
            return created;
          } else {
            var existing = useFiber(current2, textContent);
            existing.return = returnFiber;
            return existing;
          }
        }
        function updateElement(returnFiber, current2, element, lanes) {
          var elementType = element.type;
          if (elementType === REACT_FRAGMENT_TYPE) {
            return updateFragment2(returnFiber, current2, element.props.children, lanes, element.key);
          }
          if (current2 !== null) {
            if (current2.elementType === elementType || isCompatibleFamilyForHotReloading(current2, element) || typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === current2.type) {
              var existing = useFiber(current2, element.props);
              existing.ref = coerceRef(returnFiber, current2, element);
              existing.return = returnFiber;
              {
                existing._debugSource = element._source;
                existing._debugOwner = element._owner;
              }
              return existing;
            }
          }
          var created = createFiberFromElement(element, returnFiber.mode, lanes);
          created.ref = coerceRef(returnFiber, current2, element);
          created.return = returnFiber;
          return created;
        }
        function updatePortal(returnFiber, current2, portal, lanes) {
          if (current2 === null || current2.tag !== HostPortal || current2.stateNode.containerInfo !== portal.containerInfo || current2.stateNode.implementation !== portal.implementation) {
            var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
            created.return = returnFiber;
            return created;
          } else {
            var existing = useFiber(current2, portal.children || []);
            existing.return = returnFiber;
            return existing;
          }
        }
        function updateFragment2(returnFiber, current2, fragment, lanes, key) {
          if (current2 === null || current2.tag !== Fragment) {
            var created = createFiberFromFragment(fragment, returnFiber.mode, lanes, key);
            created.return = returnFiber;
            return created;
          } else {
            var existing = useFiber(current2, fragment);
            existing.return = returnFiber;
            return existing;
          }
        }
        function createChild(returnFiber, newChild, lanes) {
          if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
            var created = createFiberFromText("" + newChild, returnFiber.mode, lanes);
            created.return = returnFiber;
            return created;
          }
          if (typeof newChild === "object" && newChild !== null) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE: {
                var _created = createFiberFromElement(newChild, returnFiber.mode, lanes);
                _created.ref = coerceRef(returnFiber, null, newChild);
                _created.return = returnFiber;
                return _created;
              }
              case REACT_PORTAL_TYPE: {
                var _created2 = createFiberFromPortal(newChild, returnFiber.mode, lanes);
                _created2.return = returnFiber;
                return _created2;
              }
              case REACT_LAZY_TYPE: {
                var payload = newChild._payload;
                var init = newChild._init;
                return createChild(returnFiber, init(payload), lanes);
              }
            }
            if (isArray(newChild) || getIteratorFn(newChild)) {
              var _created3 = createFiberFromFragment(newChild, returnFiber.mode, lanes, null);
              _created3.return = returnFiber;
              return _created3;
            }
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          {
            if (typeof newChild === "function") {
              warnOnFunctionType(returnFiber);
            }
          }
          return null;
        }
        function updateSlot(returnFiber, oldFiber, newChild, lanes) {
          var key = oldFiber !== null ? oldFiber.key : null;
          if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
            if (key !== null) {
              return null;
            }
            return updateTextNode(returnFiber, oldFiber, "" + newChild, lanes);
          }
          if (typeof newChild === "object" && newChild !== null) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE: {
                if (newChild.key === key) {
                  return updateElement(returnFiber, oldFiber, newChild, lanes);
                } else {
                  return null;
                }
              }
              case REACT_PORTAL_TYPE: {
                if (newChild.key === key) {
                  return updatePortal(returnFiber, oldFiber, newChild, lanes);
                } else {
                  return null;
                }
              }
              case REACT_LAZY_TYPE: {
                var payload = newChild._payload;
                var init = newChild._init;
                return updateSlot(returnFiber, oldFiber, init(payload), lanes);
              }
            }
            if (isArray(newChild) || getIteratorFn(newChild)) {
              if (key !== null) {
                return null;
              }
              return updateFragment2(returnFiber, oldFiber, newChild, lanes, null);
            }
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          {
            if (typeof newChild === "function") {
              warnOnFunctionType(returnFiber);
            }
          }
          return null;
        }
        function updateFromMap(existingChildren, returnFiber, newIdx, newChild, lanes) {
          if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
            var matchedFiber = existingChildren.get(newIdx) || null;
            return updateTextNode(returnFiber, matchedFiber, "" + newChild, lanes);
          }
          if (typeof newChild === "object" && newChild !== null) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE: {
                var _matchedFiber = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                return updateElement(returnFiber, _matchedFiber, newChild, lanes);
              }
              case REACT_PORTAL_TYPE: {
                var _matchedFiber2 = existingChildren.get(newChild.key === null ? newIdx : newChild.key) || null;
                return updatePortal(returnFiber, _matchedFiber2, newChild, lanes);
              }
              case REACT_LAZY_TYPE:
                var payload = newChild._payload;
                var init = newChild._init;
                return updateFromMap(existingChildren, returnFiber, newIdx, init(payload), lanes);
            }
            if (isArray(newChild) || getIteratorFn(newChild)) {
              var _matchedFiber3 = existingChildren.get(newIdx) || null;
              return updateFragment2(returnFiber, _matchedFiber3, newChild, lanes, null);
            }
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          {
            if (typeof newChild === "function") {
              warnOnFunctionType(returnFiber);
            }
          }
          return null;
        }
        function warnOnInvalidKey(child, knownKeys, returnFiber) {
          {
            if (typeof child !== "object" || child === null) {
              return knownKeys;
            }
            switch (child.$$typeof) {
              case REACT_ELEMENT_TYPE:
              case REACT_PORTAL_TYPE:
                warnForMissingKey(child, returnFiber);
                var key = child.key;
                if (typeof key !== "string") {
                  break;
                }
                if (knownKeys === null) {
                  knownKeys = new Set;
                  knownKeys.add(key);
                  break;
                }
                if (!knownKeys.has(key)) {
                  knownKeys.add(key);
                  break;
                }
                error("Encountered two children with the same key, `%s`. " + "Keys should be unique so that components maintain their identity " + "across updates. Non-unique keys may cause children to be " + "duplicated and/or omitted  the behavior is unsupported and " + "could change in a future version.", key);
                break;
              case REACT_LAZY_TYPE:
                var payload = child._payload;
                var init = child._init;
                warnOnInvalidKey(init(payload), knownKeys, returnFiber);
                break;
            }
          }
          return knownKeys;
        }
        function reconcileChildrenArray(returnFiber, currentFirstChild, newChildren, lanes) {
          {
            var knownKeys = null;
            for (var i = 0;i < newChildren.length; i++) {
              var child = newChildren[i];
              knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
            }
          }
          var resultingFirstChild = null;
          var previousNewFiber = null;
          var oldFiber = currentFirstChild;
          var lastPlacedIndex = 0;
          var newIdx = 0;
          var nextOldFiber = null;
          for (;oldFiber !== null && newIdx < newChildren.length; newIdx++) {
            if (oldFiber.index > newIdx) {
              nextOldFiber = oldFiber;
              oldFiber = null;
            } else {
              nextOldFiber = oldFiber.sibling;
            }
            var newFiber = updateSlot(returnFiber, oldFiber, newChildren[newIdx], lanes);
            if (newFiber === null) {
              if (oldFiber === null) {
                oldFiber = nextOldFiber;
              }
              break;
            }
            if (shouldTrackSideEffects) {
              if (oldFiber && newFiber.alternate === null) {
                deleteChild(returnFiber, oldFiber);
              }
            }
            lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
            if (previousNewFiber === null) {
              resultingFirstChild = newFiber;
            } else {
              previousNewFiber.sibling = newFiber;
            }
            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }
          if (newIdx === newChildren.length) {
            deleteRemainingChildren(returnFiber, oldFiber);
            if (getIsHydrating()) {
              var numberOfForks = newIdx;
              pushTreeFork(returnFiber, numberOfForks);
            }
            return resultingFirstChild;
          }
          if (oldFiber === null) {
            for (;newIdx < newChildren.length; newIdx++) {
              var _newFiber = createChild(returnFiber, newChildren[newIdx], lanes);
              if (_newFiber === null) {
                continue;
              }
              lastPlacedIndex = placeChild(_newFiber, lastPlacedIndex, newIdx);
              if (previousNewFiber === null) {
                resultingFirstChild = _newFiber;
              } else {
                previousNewFiber.sibling = _newFiber;
              }
              previousNewFiber = _newFiber;
            }
            if (getIsHydrating()) {
              var _numberOfForks = newIdx;
              pushTreeFork(returnFiber, _numberOfForks);
            }
            return resultingFirstChild;
          }
          var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
          for (;newIdx < newChildren.length; newIdx++) {
            var _newFiber2 = updateFromMap(existingChildren, returnFiber, newIdx, newChildren[newIdx], lanes);
            if (_newFiber2 !== null) {
              if (shouldTrackSideEffects) {
                if (_newFiber2.alternate !== null) {
                  existingChildren.delete(_newFiber2.key === null ? newIdx : _newFiber2.key);
                }
              }
              lastPlacedIndex = placeChild(_newFiber2, lastPlacedIndex, newIdx);
              if (previousNewFiber === null) {
                resultingFirstChild = _newFiber2;
              } else {
                previousNewFiber.sibling = _newFiber2;
              }
              previousNewFiber = _newFiber2;
            }
          }
          if (shouldTrackSideEffects) {
            existingChildren.forEach(function(child2) {
              return deleteChild(returnFiber, child2);
            });
          }
          if (getIsHydrating()) {
            var _numberOfForks2 = newIdx;
            pushTreeFork(returnFiber, _numberOfForks2);
          }
          return resultingFirstChild;
        }
        function reconcileChildrenIterator(returnFiber, currentFirstChild, newChildrenIterable, lanes) {
          var iteratorFn = getIteratorFn(newChildrenIterable);
          if (typeof iteratorFn !== "function") {
            throw new Error("An object is not an iterable. This error is likely caused by a bug in " + "React. Please file an issue.");
          }
          {
            if (typeof Symbol === "function" && newChildrenIterable[Symbol.toStringTag] === "Generator") {
              if (!didWarnAboutGenerators) {
                error("Using Generators as children is unsupported and will likely yield " + "unexpected results because enumerating a generator mutates it. " + "You may convert it to an array with `Array.from()` or the " + "`[...spread]` operator before rendering. Keep in mind " + "you might need to polyfill these features for older browsers.");
              }
              didWarnAboutGenerators = true;
            }
            if (newChildrenIterable.entries === iteratorFn) {
              if (!didWarnAboutMaps) {
                error("Using Maps as children is not supported. " + "Use an array of keyed ReactElements instead.");
              }
              didWarnAboutMaps = true;
            }
            var _newChildren = iteratorFn.call(newChildrenIterable);
            if (_newChildren) {
              var knownKeys = null;
              var _step = _newChildren.next();
              for (;!_step.done; _step = _newChildren.next()) {
                var child = _step.value;
                knownKeys = warnOnInvalidKey(child, knownKeys, returnFiber);
              }
            }
          }
          var newChildren = iteratorFn.call(newChildrenIterable);
          if (newChildren == null) {
            throw new Error("An iterable object provided no iterator.");
          }
          var resultingFirstChild = null;
          var previousNewFiber = null;
          var oldFiber = currentFirstChild;
          var lastPlacedIndex = 0;
          var newIdx = 0;
          var nextOldFiber = null;
          var step = newChildren.next();
          for (;oldFiber !== null && !step.done; newIdx++, step = newChildren.next()) {
            if (oldFiber.index > newIdx) {
              nextOldFiber = oldFiber;
              oldFiber = null;
            } else {
              nextOldFiber = oldFiber.sibling;
            }
            var newFiber = updateSlot(returnFiber, oldFiber, step.value, lanes);
            if (newFiber === null) {
              if (oldFiber === null) {
                oldFiber = nextOldFiber;
              }
              break;
            }
            if (shouldTrackSideEffects) {
              if (oldFiber && newFiber.alternate === null) {
                deleteChild(returnFiber, oldFiber);
              }
            }
            lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);
            if (previousNewFiber === null) {
              resultingFirstChild = newFiber;
            } else {
              previousNewFiber.sibling = newFiber;
            }
            previousNewFiber = newFiber;
            oldFiber = nextOldFiber;
          }
          if (step.done) {
            deleteRemainingChildren(returnFiber, oldFiber);
            if (getIsHydrating()) {
              var numberOfForks = newIdx;
              pushTreeFork(returnFiber, numberOfForks);
            }
            return resultingFirstChild;
          }
          if (oldFiber === null) {
            for (;!step.done; newIdx++, step = newChildren.next()) {
              var _newFiber3 = createChild(returnFiber, step.value, lanes);
              if (_newFiber3 === null) {
                continue;
              }
              lastPlacedIndex = placeChild(_newFiber3, lastPlacedIndex, newIdx);
              if (previousNewFiber === null) {
                resultingFirstChild = _newFiber3;
              } else {
                previousNewFiber.sibling = _newFiber3;
              }
              previousNewFiber = _newFiber3;
            }
            if (getIsHydrating()) {
              var _numberOfForks3 = newIdx;
              pushTreeFork(returnFiber, _numberOfForks3);
            }
            return resultingFirstChild;
          }
          var existingChildren = mapRemainingChildren(returnFiber, oldFiber);
          for (;!step.done; newIdx++, step = newChildren.next()) {
            var _newFiber4 = updateFromMap(existingChildren, returnFiber, newIdx, step.value, lanes);
            if (_newFiber4 !== null) {
              if (shouldTrackSideEffects) {
                if (_newFiber4.alternate !== null) {
                  existingChildren.delete(_newFiber4.key === null ? newIdx : _newFiber4.key);
                }
              }
              lastPlacedIndex = placeChild(_newFiber4, lastPlacedIndex, newIdx);
              if (previousNewFiber === null) {
                resultingFirstChild = _newFiber4;
              } else {
                previousNewFiber.sibling = _newFiber4;
              }
              previousNewFiber = _newFiber4;
            }
          }
          if (shouldTrackSideEffects) {
            existingChildren.forEach(function(child2) {
              return deleteChild(returnFiber, child2);
            });
          }
          if (getIsHydrating()) {
            var _numberOfForks4 = newIdx;
            pushTreeFork(returnFiber, _numberOfForks4);
          }
          return resultingFirstChild;
        }
        function reconcileSingleTextNode(returnFiber, currentFirstChild, textContent, lanes) {
          if (currentFirstChild !== null && currentFirstChild.tag === HostText) {
            deleteRemainingChildren(returnFiber, currentFirstChild.sibling);
            var existing = useFiber(currentFirstChild, textContent);
            existing.return = returnFiber;
            return existing;
          }
          deleteRemainingChildren(returnFiber, currentFirstChild);
          var created = createFiberFromText(textContent, returnFiber.mode, lanes);
          created.return = returnFiber;
          return created;
        }
        function reconcileSingleElement(returnFiber, currentFirstChild, element, lanes) {
          var key = element.key;
          var child = currentFirstChild;
          while (child !== null) {
            if (child.key === key) {
              var elementType = element.type;
              if (elementType === REACT_FRAGMENT_TYPE) {
                if (child.tag === Fragment) {
                  deleteRemainingChildren(returnFiber, child.sibling);
                  var existing = useFiber(child, element.props.children);
                  existing.return = returnFiber;
                  {
                    existing._debugSource = element._source;
                    existing._debugOwner = element._owner;
                  }
                  return existing;
                }
              } else {
                if (child.elementType === elementType || isCompatibleFamilyForHotReloading(child, element) || typeof elementType === "object" && elementType !== null && elementType.$$typeof === REACT_LAZY_TYPE && resolveLazy(elementType) === child.type) {
                  deleteRemainingChildren(returnFiber, child.sibling);
                  var _existing = useFiber(child, element.props);
                  _existing.ref = coerceRef(returnFiber, child, element);
                  _existing.return = returnFiber;
                  {
                    _existing._debugSource = element._source;
                    _existing._debugOwner = element._owner;
                  }
                  return _existing;
                }
              }
              deleteRemainingChildren(returnFiber, child);
              break;
            } else {
              deleteChild(returnFiber, child);
            }
            child = child.sibling;
          }
          if (element.type === REACT_FRAGMENT_TYPE) {
            var created = createFiberFromFragment(element.props.children, returnFiber.mode, lanes, element.key);
            created.return = returnFiber;
            return created;
          } else {
            var _created4 = createFiberFromElement(element, returnFiber.mode, lanes);
            _created4.ref = coerceRef(returnFiber, currentFirstChild, element);
            _created4.return = returnFiber;
            return _created4;
          }
        }
        function reconcileSinglePortal(returnFiber, currentFirstChild, portal, lanes) {
          var key = portal.key;
          var child = currentFirstChild;
          while (child !== null) {
            if (child.key === key) {
              if (child.tag === HostPortal && child.stateNode.containerInfo === portal.containerInfo && child.stateNode.implementation === portal.implementation) {
                deleteRemainingChildren(returnFiber, child.sibling);
                var existing = useFiber(child, portal.children || []);
                existing.return = returnFiber;
                return existing;
              } else {
                deleteRemainingChildren(returnFiber, child);
                break;
              }
            } else {
              deleteChild(returnFiber, child);
            }
            child = child.sibling;
          }
          var created = createFiberFromPortal(portal, returnFiber.mode, lanes);
          created.return = returnFiber;
          return created;
        }
        function reconcileChildFibers2(returnFiber, currentFirstChild, newChild, lanes) {
          var isUnkeyedTopLevelFragment = typeof newChild === "object" && newChild !== null && newChild.type === REACT_FRAGMENT_TYPE && newChild.key === null;
          if (isUnkeyedTopLevelFragment) {
            newChild = newChild.props.children;
          }
          if (typeof newChild === "object" && newChild !== null) {
            switch (newChild.$$typeof) {
              case REACT_ELEMENT_TYPE:
                return placeSingleChild(reconcileSingleElement(returnFiber, currentFirstChild, newChild, lanes));
              case REACT_PORTAL_TYPE:
                return placeSingleChild(reconcileSinglePortal(returnFiber, currentFirstChild, newChild, lanes));
              case REACT_LAZY_TYPE:
                var payload = newChild._payload;
                var init = newChild._init;
                return reconcileChildFibers2(returnFiber, currentFirstChild, init(payload), lanes);
            }
            if (isArray(newChild)) {
              return reconcileChildrenArray(returnFiber, currentFirstChild, newChild, lanes);
            }
            if (getIteratorFn(newChild)) {
              return reconcileChildrenIterator(returnFiber, currentFirstChild, newChild, lanes);
            }
            throwOnInvalidObjectType(returnFiber, newChild);
          }
          if (typeof newChild === "string" && newChild !== "" || typeof newChild === "number") {
            return placeSingleChild(reconcileSingleTextNode(returnFiber, currentFirstChild, "" + newChild, lanes));
          }
          {
            if (typeof newChild === "function") {
              warnOnFunctionType(returnFiber);
            }
          }
          return deleteRemainingChildren(returnFiber, currentFirstChild);
        }
        return reconcileChildFibers2;
      }
      var reconcileChildFibers = ChildReconciler(true);
      var mountChildFibers = ChildReconciler(false);
      function cloneChildFibers(current2, workInProgress2) {
        if (current2 !== null && workInProgress2.child !== current2.child) {
          throw new Error("Resuming work not yet implemented.");
        }
        if (workInProgress2.child === null) {
          return;
        }
        var currentChild = workInProgress2.child;
        var newChild = createWorkInProgress(currentChild, currentChild.pendingProps);
        workInProgress2.child = newChild;
        newChild.return = workInProgress2;
        while (currentChild.sibling !== null) {
          currentChild = currentChild.sibling;
          newChild = newChild.sibling = createWorkInProgress(currentChild, currentChild.pendingProps);
          newChild.return = workInProgress2;
        }
        newChild.sibling = null;
      }
      function resetChildFibers(workInProgress2, lanes) {
        var child = workInProgress2.child;
        while (child !== null) {
          resetWorkInProgress(child, lanes);
          child = child.sibling;
        }
      }
      var valueCursor = createCursor(null);
      var rendererSigil;
      {
        rendererSigil = {};
      }
      var currentlyRenderingFiber = null;
      var lastContextDependency = null;
      var lastFullyObservedContext = null;
      var isDisallowedContextReadInDEV = false;
      function resetContextDependencies() {
        currentlyRenderingFiber = null;
        lastContextDependency = null;
        lastFullyObservedContext = null;
        {
          isDisallowedContextReadInDEV = false;
        }
      }
      function enterDisallowedContextReadInDEV() {
        {
          isDisallowedContextReadInDEV = true;
        }
      }
      function exitDisallowedContextReadInDEV() {
        {
          isDisallowedContextReadInDEV = false;
        }
      }
      function pushProvider(providerFiber, context, nextValue) {
        {
          push(valueCursor, context._currentValue, providerFiber);
          context._currentValue = nextValue;
          {
            if (context._currentRenderer !== undefined && context._currentRenderer !== null && context._currentRenderer !== rendererSigil) {
              error("Detected multiple renderers concurrently rendering the " + "same context provider. This is currently unsupported.");
            }
            context._currentRenderer = rendererSigil;
          }
        }
      }
      function popProvider(context, providerFiber) {
        var currentValue = valueCursor.current;
        pop(valueCursor, providerFiber);
        {
          {
            context._currentValue = currentValue;
          }
        }
      }
      function scheduleContextWorkOnParentPath(parent, renderLanes2, propagationRoot) {
        var node = parent;
        while (node !== null) {
          var alternate = node.alternate;
          if (!isSubsetOfLanes(node.childLanes, renderLanes2)) {
            node.childLanes = mergeLanes(node.childLanes, renderLanes2);
            if (alternate !== null) {
              alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
            }
          } else if (alternate !== null && !isSubsetOfLanes(alternate.childLanes, renderLanes2)) {
            alternate.childLanes = mergeLanes(alternate.childLanes, renderLanes2);
          }
          if (node === propagationRoot) {
            break;
          }
          node = node.return;
        }
        {
          if (node !== propagationRoot) {
            error("Expected to find the propagation root when scheduling context work. " + "This error is likely caused by a bug in React. Please file an issue.");
          }
        }
      }
      function propagateContextChange(workInProgress2, context, renderLanes2) {
        {
          propagateContextChange_eager(workInProgress2, context, renderLanes2);
        }
      }
      function propagateContextChange_eager(workInProgress2, context, renderLanes2) {
        var fiber = workInProgress2.child;
        if (fiber !== null) {
          fiber.return = workInProgress2;
        }
        while (fiber !== null) {
          var nextFiber = undefined;
          var list = fiber.dependencies;
          if (list !== null) {
            nextFiber = fiber.child;
            var dependency = list.firstContext;
            while (dependency !== null) {
              if (dependency.context === context) {
                if (fiber.tag === ClassComponent) {
                  var lane = pickArbitraryLane(renderLanes2);
                  var update = createUpdate(NoTimestamp, lane);
                  update.tag = ForceUpdate;
                  var updateQueue = fiber.updateQueue;
                  if (updateQueue === null)
                    ;
                  else {
                    var sharedQueue = updateQueue.shared;
                    var pending = sharedQueue.pending;
                    if (pending === null) {
                      update.next = update;
                    } else {
                      update.next = pending.next;
                      pending.next = update;
                    }
                    sharedQueue.pending = update;
                  }
                }
                fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
                var alternate = fiber.alternate;
                if (alternate !== null) {
                  alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
                }
                scheduleContextWorkOnParentPath(fiber.return, renderLanes2, workInProgress2);
                list.lanes = mergeLanes(list.lanes, renderLanes2);
                break;
              }
              dependency = dependency.next;
            }
          } else if (fiber.tag === ContextProvider) {
            nextFiber = fiber.type === workInProgress2.type ? null : fiber.child;
          } else if (fiber.tag === DehydratedFragment) {
            var parentSuspense = fiber.return;
            if (parentSuspense === null) {
              throw new Error("We just came from a parent so we must have had a parent. This is a bug in React.");
            }
            parentSuspense.lanes = mergeLanes(parentSuspense.lanes, renderLanes2);
            var _alternate = parentSuspense.alternate;
            if (_alternate !== null) {
              _alternate.lanes = mergeLanes(_alternate.lanes, renderLanes2);
            }
            scheduleContextWorkOnParentPath(parentSuspense, renderLanes2, workInProgress2);
            nextFiber = fiber.sibling;
          } else {
            nextFiber = fiber.child;
          }
          if (nextFiber !== null) {
            nextFiber.return = fiber;
          } else {
            nextFiber = fiber;
            while (nextFiber !== null) {
              if (nextFiber === workInProgress2) {
                nextFiber = null;
                break;
              }
              var sibling = nextFiber.sibling;
              if (sibling !== null) {
                sibling.return = nextFiber.return;
                nextFiber = sibling;
                break;
              }
              nextFiber = nextFiber.return;
            }
          }
          fiber = nextFiber;
        }
      }
      function prepareToReadContext(workInProgress2, renderLanes2) {
        currentlyRenderingFiber = workInProgress2;
        lastContextDependency = null;
        lastFullyObservedContext = null;
        var dependencies = workInProgress2.dependencies;
        if (dependencies !== null) {
          {
            var firstContext = dependencies.firstContext;
            if (firstContext !== null) {
              if (includesSomeLane(dependencies.lanes, renderLanes2)) {
                markWorkInProgressReceivedUpdate();
              }
              dependencies.firstContext = null;
            }
          }
        }
      }
      function readContext(context) {
        {
          if (isDisallowedContextReadInDEV) {
            error("Context can only be read while React is rendering. " + "In classes, you can read it in the render method or getDerivedStateFromProps. " + "In function components, you can read it directly in the function body, but not " + "inside Hooks like useReducer() or useMemo().");
          }
        }
        var value = context._currentValue;
        if (lastFullyObservedContext === context)
          ;
        else {
          var contextItem = {
            context,
            memoizedValue: value,
            next: null
          };
          if (lastContextDependency === null) {
            if (currentlyRenderingFiber === null) {
              throw new Error("Context can only be read while React is rendering. " + "In classes, you can read it in the render method or getDerivedStateFromProps. " + "In function components, you can read it directly in the function body, but not " + "inside Hooks like useReducer() or useMemo().");
            }
            lastContextDependency = contextItem;
            currentlyRenderingFiber.dependencies = {
              lanes: NoLanes,
              firstContext: contextItem
            };
          } else {
            lastContextDependency = lastContextDependency.next = contextItem;
          }
        }
        return value;
      }
      var concurrentQueues = null;
      function pushConcurrentUpdateQueue(queue) {
        if (concurrentQueues === null) {
          concurrentQueues = [queue];
        } else {
          concurrentQueues.push(queue);
        }
      }
      function finishQueueingConcurrentUpdates() {
        if (concurrentQueues !== null) {
          for (var i = 0;i < concurrentQueues.length; i++) {
            var queue = concurrentQueues[i];
            var lastInterleavedUpdate = queue.interleaved;
            if (lastInterleavedUpdate !== null) {
              queue.interleaved = null;
              var firstInterleavedUpdate = lastInterleavedUpdate.next;
              var lastPendingUpdate = queue.pending;
              if (lastPendingUpdate !== null) {
                var firstPendingUpdate = lastPendingUpdate.next;
                lastPendingUpdate.next = firstInterleavedUpdate;
                lastInterleavedUpdate.next = firstPendingUpdate;
              }
              queue.pending = lastInterleavedUpdate;
            }
          }
          concurrentQueues = null;
        }
      }
      function enqueueConcurrentHookUpdate(fiber, queue, update, lane) {
        var interleaved = queue.interleaved;
        if (interleaved === null) {
          update.next = update;
          pushConcurrentUpdateQueue(queue);
        } else {
          update.next = interleaved.next;
          interleaved.next = update;
        }
        queue.interleaved = update;
        return markUpdateLaneFromFiberToRoot(fiber, lane);
      }
      function enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane) {
        var interleaved = queue.interleaved;
        if (interleaved === null) {
          update.next = update;
          pushConcurrentUpdateQueue(queue);
        } else {
          update.next = interleaved.next;
          interleaved.next = update;
        }
        queue.interleaved = update;
      }
      function enqueueConcurrentClassUpdate(fiber, queue, update, lane) {
        var interleaved = queue.interleaved;
        if (interleaved === null) {
          update.next = update;
          pushConcurrentUpdateQueue(queue);
        } else {
          update.next = interleaved.next;
          interleaved.next = update;
        }
        queue.interleaved = update;
        return markUpdateLaneFromFiberToRoot(fiber, lane);
      }
      function enqueueConcurrentRenderForLane(fiber, lane) {
        return markUpdateLaneFromFiberToRoot(fiber, lane);
      }
      var unsafe_markUpdateLaneFromFiberToRoot = markUpdateLaneFromFiberToRoot;
      function markUpdateLaneFromFiberToRoot(sourceFiber, lane) {
        sourceFiber.lanes = mergeLanes(sourceFiber.lanes, lane);
        var alternate = sourceFiber.alternate;
        if (alternate !== null) {
          alternate.lanes = mergeLanes(alternate.lanes, lane);
        }
        {
          if (alternate === null && (sourceFiber.flags & (Placement | Hydrating)) !== NoFlags) {
            warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
          }
        }
        var node = sourceFiber;
        var parent = sourceFiber.return;
        while (parent !== null) {
          parent.childLanes = mergeLanes(parent.childLanes, lane);
          alternate = parent.alternate;
          if (alternate !== null) {
            alternate.childLanes = mergeLanes(alternate.childLanes, lane);
          } else {
            {
              if ((parent.flags & (Placement | Hydrating)) !== NoFlags) {
                warnAboutUpdateOnNotYetMountedFiberInDEV(sourceFiber);
              }
            }
          }
          node = parent;
          parent = parent.return;
        }
        if (node.tag === HostRoot) {
          var root2 = node.stateNode;
          return root2;
        } else {
          return null;
        }
      }
      var UpdateState = 0;
      var ReplaceState = 1;
      var ForceUpdate = 2;
      var CaptureUpdate = 3;
      var hasForceUpdate = false;
      var didWarnUpdateInsideUpdate;
      var currentlyProcessingQueue;
      {
        didWarnUpdateInsideUpdate = false;
        currentlyProcessingQueue = null;
      }
      function initializeUpdateQueue(fiber) {
        var queue = {
          baseState: fiber.memoizedState,
          firstBaseUpdate: null,
          lastBaseUpdate: null,
          shared: {
            pending: null,
            interleaved: null,
            lanes: NoLanes
          },
          effects: null
        };
        fiber.updateQueue = queue;
      }
      function cloneUpdateQueue(current2, workInProgress2) {
        var queue = workInProgress2.updateQueue;
        var currentQueue = current2.updateQueue;
        if (queue === currentQueue) {
          var clone = {
            baseState: currentQueue.baseState,
            firstBaseUpdate: currentQueue.firstBaseUpdate,
            lastBaseUpdate: currentQueue.lastBaseUpdate,
            shared: currentQueue.shared,
            effects: currentQueue.effects
          };
          workInProgress2.updateQueue = clone;
        }
      }
      function createUpdate(eventTime, lane) {
        var update = {
          eventTime,
          lane,
          tag: UpdateState,
          payload: null,
          callback: null,
          next: null
        };
        return update;
      }
      function enqueueUpdate(fiber, update, lane) {
        var updateQueue = fiber.updateQueue;
        if (updateQueue === null) {
          return null;
        }
        var sharedQueue = updateQueue.shared;
        {
          if (currentlyProcessingQueue === sharedQueue && !didWarnUpdateInsideUpdate) {
            error("An update (setState, replaceState, or forceUpdate) was scheduled " + "from inside an update function. Update functions should be pure, " + "with zero side-effects. Consider using componentDidUpdate or a " + "callback.");
            didWarnUpdateInsideUpdate = true;
          }
        }
        if (isUnsafeClassRenderPhaseUpdate()) {
          var pending = sharedQueue.pending;
          if (pending === null) {
            update.next = update;
          } else {
            update.next = pending.next;
            pending.next = update;
          }
          sharedQueue.pending = update;
          return unsafe_markUpdateLaneFromFiberToRoot(fiber, lane);
        } else {
          return enqueueConcurrentClassUpdate(fiber, sharedQueue, update, lane);
        }
      }
      function entangleTransitions(root2, fiber, lane) {
        var updateQueue = fiber.updateQueue;
        if (updateQueue === null) {
          return;
        }
        var sharedQueue = updateQueue.shared;
        if (isTransitionLane(lane)) {
          var queueLanes = sharedQueue.lanes;
          queueLanes = intersectLanes(queueLanes, root2.pendingLanes);
          var newQueueLanes = mergeLanes(queueLanes, lane);
          sharedQueue.lanes = newQueueLanes;
          markRootEntangled(root2, newQueueLanes);
        }
      }
      function enqueueCapturedUpdate(workInProgress2, capturedUpdate) {
        var queue = workInProgress2.updateQueue;
        var current2 = workInProgress2.alternate;
        if (current2 !== null) {
          var currentQueue = current2.updateQueue;
          if (queue === currentQueue) {
            var newFirst = null;
            var newLast = null;
            var firstBaseUpdate = queue.firstBaseUpdate;
            if (firstBaseUpdate !== null) {
              var update = firstBaseUpdate;
              do {
                var clone = {
                  eventTime: update.eventTime,
                  lane: update.lane,
                  tag: update.tag,
                  payload: update.payload,
                  callback: update.callback,
                  next: null
                };
                if (newLast === null) {
                  newFirst = newLast = clone;
                } else {
                  newLast.next = clone;
                  newLast = clone;
                }
                update = update.next;
              } while (update !== null);
              if (newLast === null) {
                newFirst = newLast = capturedUpdate;
              } else {
                newLast.next = capturedUpdate;
                newLast = capturedUpdate;
              }
            } else {
              newFirst = newLast = capturedUpdate;
            }
            queue = {
              baseState: currentQueue.baseState,
              firstBaseUpdate: newFirst,
              lastBaseUpdate: newLast,
              shared: currentQueue.shared,
              effects: currentQueue.effects
            };
            workInProgress2.updateQueue = queue;
            return;
          }
        }
        var lastBaseUpdate = queue.lastBaseUpdate;
        if (lastBaseUpdate === null) {
          queue.firstBaseUpdate = capturedUpdate;
        } else {
          lastBaseUpdate.next = capturedUpdate;
        }
        queue.lastBaseUpdate = capturedUpdate;
      }
      function getStateFromUpdate(workInProgress2, queue, update, prevState, nextProps, instance) {
        switch (update.tag) {
          case ReplaceState: {
            var payload = update.payload;
            if (typeof payload === "function") {
              {
                enterDisallowedContextReadInDEV();
              }
              var nextState = payload.call(instance, prevState, nextProps);
              {
                if (workInProgress2.mode & StrictLegacyMode) {
                  setIsStrictModeForDevtools(true);
                  try {
                    payload.call(instance, prevState, nextProps);
                  } finally {
                    setIsStrictModeForDevtools(false);
                  }
                }
                exitDisallowedContextReadInDEV();
              }
              return nextState;
            }
            return payload;
          }
          case CaptureUpdate: {
            workInProgress2.flags = workInProgress2.flags & ~ShouldCapture | DidCapture;
          }
          case UpdateState: {
            var _payload = update.payload;
            var partialState;
            if (typeof _payload === "function") {
              {
                enterDisallowedContextReadInDEV();
              }
              partialState = _payload.call(instance, prevState, nextProps);
              {
                if (workInProgress2.mode & StrictLegacyMode) {
                  setIsStrictModeForDevtools(true);
                  try {
                    _payload.call(instance, prevState, nextProps);
                  } finally {
                    setIsStrictModeForDevtools(false);
                  }
                }
                exitDisallowedContextReadInDEV();
              }
            } else {
              partialState = _payload;
            }
            if (partialState === null || partialState === undefined) {
              return prevState;
            }
            return assign({}, prevState, partialState);
          }
          case ForceUpdate: {
            hasForceUpdate = true;
            return prevState;
          }
        }
        return prevState;
      }
      function processUpdateQueue(workInProgress2, props, instance, renderLanes2) {
        var queue = workInProgress2.updateQueue;
        hasForceUpdate = false;
        {
          currentlyProcessingQueue = queue.shared;
        }
        var firstBaseUpdate = queue.firstBaseUpdate;
        var lastBaseUpdate = queue.lastBaseUpdate;
        var pendingQueue = queue.shared.pending;
        if (pendingQueue !== null) {
          queue.shared.pending = null;
          var lastPendingUpdate = pendingQueue;
          var firstPendingUpdate = lastPendingUpdate.next;
          lastPendingUpdate.next = null;
          if (lastBaseUpdate === null) {
            firstBaseUpdate = firstPendingUpdate;
          } else {
            lastBaseUpdate.next = firstPendingUpdate;
          }
          lastBaseUpdate = lastPendingUpdate;
          var current2 = workInProgress2.alternate;
          if (current2 !== null) {
            var currentQueue = current2.updateQueue;
            var currentLastBaseUpdate = currentQueue.lastBaseUpdate;
            if (currentLastBaseUpdate !== lastBaseUpdate) {
              if (currentLastBaseUpdate === null) {
                currentQueue.firstBaseUpdate = firstPendingUpdate;
              } else {
                currentLastBaseUpdate.next = firstPendingUpdate;
              }
              currentQueue.lastBaseUpdate = lastPendingUpdate;
            }
          }
        }
        if (firstBaseUpdate !== null) {
          var newState = queue.baseState;
          var newLanes = NoLanes;
          var newBaseState = null;
          var newFirstBaseUpdate = null;
          var newLastBaseUpdate = null;
          var update = firstBaseUpdate;
          do {
            var updateLane = update.lane;
            var updateEventTime = update.eventTime;
            if (!isSubsetOfLanes(renderLanes2, updateLane)) {
              var clone = {
                eventTime: updateEventTime,
                lane: updateLane,
                tag: update.tag,
                payload: update.payload,
                callback: update.callback,
                next: null
              };
              if (newLastBaseUpdate === null) {
                newFirstBaseUpdate = newLastBaseUpdate = clone;
                newBaseState = newState;
              } else {
                newLastBaseUpdate = newLastBaseUpdate.next = clone;
              }
              newLanes = mergeLanes(newLanes, updateLane);
            } else {
              if (newLastBaseUpdate !== null) {
                var _clone = {
                  eventTime: updateEventTime,
                  lane: NoLane,
                  tag: update.tag,
                  payload: update.payload,
                  callback: update.callback,
                  next: null
                };
                newLastBaseUpdate = newLastBaseUpdate.next = _clone;
              }
              newState = getStateFromUpdate(workInProgress2, queue, update, newState, props, instance);
              var callback = update.callback;
              if (callback !== null && update.lane !== NoLane) {
                workInProgress2.flags |= Callback;
                var effects = queue.effects;
                if (effects === null) {
                  queue.effects = [update];
                } else {
                  effects.push(update);
                }
              }
            }
            update = update.next;
            if (update === null) {
              pendingQueue = queue.shared.pending;
              if (pendingQueue === null) {
                break;
              } else {
                var _lastPendingUpdate = pendingQueue;
                var _firstPendingUpdate = _lastPendingUpdate.next;
                _lastPendingUpdate.next = null;
                update = _firstPendingUpdate;
                queue.lastBaseUpdate = _lastPendingUpdate;
                queue.shared.pending = null;
              }
            }
          } while (true);
          if (newLastBaseUpdate === null) {
            newBaseState = newState;
          }
          queue.baseState = newBaseState;
          queue.firstBaseUpdate = newFirstBaseUpdate;
          queue.lastBaseUpdate = newLastBaseUpdate;
          var lastInterleaved = queue.shared.interleaved;
          if (lastInterleaved !== null) {
            var interleaved = lastInterleaved;
            do {
              newLanes = mergeLanes(newLanes, interleaved.lane);
              interleaved = interleaved.next;
            } while (interleaved !== lastInterleaved);
          } else if (firstBaseUpdate === null) {
            queue.shared.lanes = NoLanes;
          }
          markSkippedUpdateLanes(newLanes);
          workInProgress2.lanes = newLanes;
          workInProgress2.memoizedState = newState;
        }
        {
          currentlyProcessingQueue = null;
        }
      }
      function callCallback(callback, context) {
        if (typeof callback !== "function") {
          throw new Error("Invalid argument passed as callback. Expected a function. Instead " + ("received: " + callback));
        }
        callback.call(context);
      }
      function resetHasForceUpdateBeforeProcessing() {
        hasForceUpdate = false;
      }
      function checkHasForceUpdateAfterProcessing() {
        return hasForceUpdate;
      }
      function commitUpdateQueue(finishedWork, finishedQueue, instance) {
        var effects = finishedQueue.effects;
        finishedQueue.effects = null;
        if (effects !== null) {
          for (var i = 0;i < effects.length; i++) {
            var effect = effects[i];
            var callback = effect.callback;
            if (callback !== null) {
              effect.callback = null;
              callCallback(callback, instance);
            }
          }
        }
      }
      var NO_CONTEXT = {};
      var contextStackCursor$1 = createCursor(NO_CONTEXT);
      var contextFiberStackCursor = createCursor(NO_CONTEXT);
      var rootInstanceStackCursor = createCursor(NO_CONTEXT);
      function requiredContext(c) {
        if (c === NO_CONTEXT) {
          throw new Error("Expected host context to exist. This error is likely caused by a bug " + "in React. Please file an issue.");
        }
        return c;
      }
      function getRootHostContainer() {
        var rootInstance = requiredContext(rootInstanceStackCursor.current);
        return rootInstance;
      }
      function pushHostContainer(fiber, nextRootInstance) {
        push(rootInstanceStackCursor, nextRootInstance, fiber);
        push(contextFiberStackCursor, fiber, fiber);
        push(contextStackCursor$1, NO_CONTEXT, fiber);
        var nextRootContext = getRootHostContext(nextRootInstance);
        pop(contextStackCursor$1, fiber);
        push(contextStackCursor$1, nextRootContext, fiber);
      }
      function popHostContainer(fiber) {
        pop(contextStackCursor$1, fiber);
        pop(contextFiberStackCursor, fiber);
        pop(rootInstanceStackCursor, fiber);
      }
      function getHostContext() {
        var context = requiredContext(contextStackCursor$1.current);
        return context;
      }
      function pushHostContext(fiber) {
        var rootInstance = requiredContext(rootInstanceStackCursor.current);
        var context = requiredContext(contextStackCursor$1.current);
        var nextContext = getChildHostContext(context, fiber.type);
        if (context === nextContext) {
          return;
        }
        push(contextFiberStackCursor, fiber, fiber);
        push(contextStackCursor$1, nextContext, fiber);
      }
      function popHostContext(fiber) {
        if (contextFiberStackCursor.current !== fiber) {
          return;
        }
        pop(contextStackCursor$1, fiber);
        pop(contextFiberStackCursor, fiber);
      }
      var DefaultSuspenseContext = 0;
      var SubtreeSuspenseContextMask = 1;
      var InvisibleParentSuspenseContext = 1;
      var ForceSuspenseFallback = 2;
      var suspenseStackCursor = createCursor(DefaultSuspenseContext);
      function hasSuspenseContext(parentContext, flag) {
        return (parentContext & flag) !== 0;
      }
      function setDefaultShallowSuspenseContext(parentContext) {
        return parentContext & SubtreeSuspenseContextMask;
      }
      function setShallowSuspenseContext(parentContext, shallowContext) {
        return parentContext & SubtreeSuspenseContextMask | shallowContext;
      }
      function addSubtreeSuspenseContext(parentContext, subtreeContext) {
        return parentContext | subtreeContext;
      }
      function pushSuspenseContext(fiber, newContext) {
        push(suspenseStackCursor, newContext, fiber);
      }
      function popSuspenseContext(fiber) {
        pop(suspenseStackCursor, fiber);
      }
      function shouldCaptureSuspense(workInProgress2, hasInvisibleParent) {
        var nextState = workInProgress2.memoizedState;
        if (nextState !== null) {
          if (nextState.dehydrated !== null) {
            return true;
          }
          return false;
        }
        var props = workInProgress2.memoizedProps;
        {
          return true;
        }
      }
      function findFirstSuspended(row) {
        var node = row;
        while (node !== null) {
          if (node.tag === SuspenseComponent) {
            var state = node.memoizedState;
            if (state !== null) {
              var dehydrated = state.dehydrated;
              if (dehydrated === null || isSuspenseInstancePending(dehydrated) || isSuspenseInstanceFallback(dehydrated)) {
                return node;
              }
            }
          } else if (node.tag === SuspenseListComponent && node.memoizedProps.revealOrder !== undefined) {
            var didSuspend = (node.flags & DidCapture) !== NoFlags;
            if (didSuspend) {
              return node;
            }
          } else if (node.child !== null) {
            node.child.return = node;
            node = node.child;
            continue;
          }
          if (node === row) {
            return null;
          }
          while (node.sibling === null) {
            if (node.return === null || node.return === row) {
              return null;
            }
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
        return null;
      }
      var NoFlags$1 = 0;
      var HasEffect = 1;
      var Insertion = 2;
      var Layout = 4;
      var Passive$1 = 8;
      var workInProgressSources = [];
      function resetWorkInProgressVersions() {
        for (var i = 0;i < workInProgressSources.length; i++) {
          var mutableSource = workInProgressSources[i];
          {
            mutableSource._workInProgressVersionPrimary = null;
          }
        }
        workInProgressSources.length = 0;
      }
      function registerMutableSourceForHydration(root2, mutableSource) {
        var getVersion = mutableSource._getVersion;
        var version = getVersion(mutableSource._source);
        if (root2.mutableSourceEagerHydrationData == null) {
          root2.mutableSourceEagerHydrationData = [mutableSource, version];
        } else {
          root2.mutableSourceEagerHydrationData.push(mutableSource, version);
        }
      }
      var { ReactCurrentDispatcher: ReactCurrentDispatcher$1, ReactCurrentBatchConfig: ReactCurrentBatchConfig$2 } = ReactSharedInternals;
      var didWarnAboutMismatchedHooksForComponent;
      var didWarnUncachedGetSnapshot;
      {
        didWarnAboutMismatchedHooksForComponent = new Set;
      }
      var renderLanes = NoLanes;
      var currentlyRenderingFiber$1 = null;
      var currentHook = null;
      var workInProgressHook = null;
      var didScheduleRenderPhaseUpdate = false;
      var didScheduleRenderPhaseUpdateDuringThisPass = false;
      var localIdCounter = 0;
      var globalClientIdCounter = 0;
      var RE_RENDER_LIMIT = 25;
      var currentHookNameInDev = null;
      var hookTypesDev = null;
      var hookTypesUpdateIndexDev = -1;
      var ignorePreviousDependencies = false;
      function mountHookTypesDev() {
        {
          var hookName = currentHookNameInDev;
          if (hookTypesDev === null) {
            hookTypesDev = [hookName];
          } else {
            hookTypesDev.push(hookName);
          }
        }
      }
      function updateHookTypesDev() {
        {
          var hookName = currentHookNameInDev;
          if (hookTypesDev !== null) {
            hookTypesUpdateIndexDev++;
            if (hookTypesDev[hookTypesUpdateIndexDev] !== hookName) {
              warnOnHookMismatchInDev(hookName);
            }
          }
        }
      }
      function checkDepsAreArrayDev(deps) {
        {
          if (deps !== undefined && deps !== null && !isArray(deps)) {
            error("%s received a final argument that is not an array (instead, received `%s`). When " + "specified, the final argument must be an array.", currentHookNameInDev, typeof deps);
          }
        }
      }
      function warnOnHookMismatchInDev(currentHookName) {
        {
          var componentName = getComponentNameFromFiber(currentlyRenderingFiber$1);
          if (!didWarnAboutMismatchedHooksForComponent.has(componentName)) {
            didWarnAboutMismatchedHooksForComponent.add(componentName);
            if (hookTypesDev !== null) {
              var table = "";
              var secondColumnStart = 30;
              for (var i = 0;i <= hookTypesUpdateIndexDev; i++) {
                var oldHookName = hookTypesDev[i];
                var newHookName = i === hookTypesUpdateIndexDev ? currentHookName : oldHookName;
                var row = i + 1 + ". " + oldHookName;
                while (row.length < secondColumnStart) {
                  row += " ";
                }
                row += newHookName + `
`;
                table += row;
              }
              error("React has detected a change in the order of Hooks called by %s. " + "This will lead to bugs and errors if not fixed. " + `For more information, read the Rules of Hooks: https://reactjs.org/link/rules-of-hooks

` + `   Previous render            Next render
` + `   ------------------------------------------------------
` + "%s" + `   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
`, componentName, table);
            }
          }
        }
      }
      function throwInvalidHookError() {
        throw new Error("Invalid hook call. Hooks can only be called inside of the body of a function component. This could happen for" + ` one of the following reasons:
` + `1. You might have mismatching versions of React and the renderer (such as React DOM)
` + `2. You might be breaking the Rules of Hooks
` + `3. You might have more than one copy of React in the same app
` + "See https://reactjs.org/link/invalid-hook-call for tips about how to debug and fix this problem.");
      }
      function areHookInputsEqual(nextDeps, prevDeps) {
        {
          if (ignorePreviousDependencies) {
            return false;
          }
        }
        if (prevDeps === null) {
          {
            error("%s received a final argument during this render, but not during " + "the previous render. Even though the final argument is optional, " + "its type cannot change between renders.", currentHookNameInDev);
          }
          return false;
        }
        {
          if (nextDeps.length !== prevDeps.length) {
            error("The final argument passed to %s changed size between renders. The " + `order and size of this array must remain constant.

` + `Previous: %s
` + "Incoming: %s", currentHookNameInDev, "[" + prevDeps.join(", ") + "]", "[" + nextDeps.join(", ") + "]");
          }
        }
        for (var i = 0;i < prevDeps.length && i < nextDeps.length; i++) {
          if (objectIs(nextDeps[i], prevDeps[i])) {
            continue;
          }
          return false;
        }
        return true;
      }
      function renderWithHooks(current2, workInProgress2, Component, props, secondArg, nextRenderLanes) {
        renderLanes = nextRenderLanes;
        currentlyRenderingFiber$1 = workInProgress2;
        {
          hookTypesDev = current2 !== null ? current2._debugHookTypes : null;
          hookTypesUpdateIndexDev = -1;
          ignorePreviousDependencies = current2 !== null && current2.type !== workInProgress2.type;
        }
        workInProgress2.memoizedState = null;
        workInProgress2.updateQueue = null;
        workInProgress2.lanes = NoLanes;
        {
          if (current2 !== null && current2.memoizedState !== null) {
            ReactCurrentDispatcher$1.current = HooksDispatcherOnUpdateInDEV;
          } else if (hookTypesDev !== null) {
            ReactCurrentDispatcher$1.current = HooksDispatcherOnMountWithHookTypesInDEV;
          } else {
            ReactCurrentDispatcher$1.current = HooksDispatcherOnMountInDEV;
          }
        }
        var children = Component(props, secondArg);
        if (didScheduleRenderPhaseUpdateDuringThisPass) {
          var numberOfReRenders = 0;
          do {
            didScheduleRenderPhaseUpdateDuringThisPass = false;
            localIdCounter = 0;
            if (numberOfReRenders >= RE_RENDER_LIMIT) {
              throw new Error("Too many re-renders. React limits the number of renders to prevent " + "an infinite loop.");
            }
            numberOfReRenders += 1;
            {
              ignorePreviousDependencies = false;
            }
            currentHook = null;
            workInProgressHook = null;
            workInProgress2.updateQueue = null;
            {
              hookTypesUpdateIndexDev = -1;
            }
            ReactCurrentDispatcher$1.current = HooksDispatcherOnRerenderInDEV;
            children = Component(props, secondArg);
          } while (didScheduleRenderPhaseUpdateDuringThisPass);
        }
        ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
        {
          workInProgress2._debugHookTypes = hookTypesDev;
        }
        var didRenderTooFewHooks = currentHook !== null && currentHook.next !== null;
        renderLanes = NoLanes;
        currentlyRenderingFiber$1 = null;
        currentHook = null;
        workInProgressHook = null;
        {
          currentHookNameInDev = null;
          hookTypesDev = null;
          hookTypesUpdateIndexDev = -1;
          if (current2 !== null && (current2.flags & StaticMask) !== (workInProgress2.flags & StaticMask) && (current2.mode & ConcurrentMode) !== NoMode) {
            error("Internal React error: Expected static flag was missing. Please " + "notify the React team.");
          }
        }
        didScheduleRenderPhaseUpdate = false;
        if (didRenderTooFewHooks) {
          throw new Error("Rendered fewer hooks than expected. This may be caused by an accidental " + "early return statement.");
        }
        return children;
      }
      function checkDidRenderIdHook() {
        var didRenderIdHook = localIdCounter !== 0;
        localIdCounter = 0;
        return didRenderIdHook;
      }
      function bailoutHooks(current2, workInProgress2, lanes) {
        workInProgress2.updateQueue = current2.updateQueue;
        if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
          workInProgress2.flags &= ~(MountPassiveDev | MountLayoutDev | Passive | Update);
        } else {
          workInProgress2.flags &= ~(Passive | Update);
        }
        current2.lanes = removeLanes(current2.lanes, lanes);
      }
      function resetHooksAfterThrow() {
        ReactCurrentDispatcher$1.current = ContextOnlyDispatcher;
        if (didScheduleRenderPhaseUpdate) {
          var hook = currentlyRenderingFiber$1.memoizedState;
          while (hook !== null) {
            var queue = hook.queue;
            if (queue !== null) {
              queue.pending = null;
            }
            hook = hook.next;
          }
          didScheduleRenderPhaseUpdate = false;
        }
        renderLanes = NoLanes;
        currentlyRenderingFiber$1 = null;
        currentHook = null;
        workInProgressHook = null;
        {
          hookTypesDev = null;
          hookTypesUpdateIndexDev = -1;
          currentHookNameInDev = null;
          isUpdatingOpaqueValueInRenderPhase = false;
        }
        didScheduleRenderPhaseUpdateDuringThisPass = false;
        localIdCounter = 0;
      }
      function mountWorkInProgressHook() {
        var hook = {
          memoizedState: null,
          baseState: null,
          baseQueue: null,
          queue: null,
          next: null
        };
        if (workInProgressHook === null) {
          currentlyRenderingFiber$1.memoizedState = workInProgressHook = hook;
        } else {
          workInProgressHook = workInProgressHook.next = hook;
        }
        return workInProgressHook;
      }
      function updateWorkInProgressHook() {
        var nextCurrentHook;
        if (currentHook === null) {
          var current2 = currentlyRenderingFiber$1.alternate;
          if (current2 !== null) {
            nextCurrentHook = current2.memoizedState;
          } else {
            nextCurrentHook = null;
          }
        } else {
          nextCurrentHook = currentHook.next;
        }
        var nextWorkInProgressHook;
        if (workInProgressHook === null) {
          nextWorkInProgressHook = currentlyRenderingFiber$1.memoizedState;
        } else {
          nextWorkInProgressHook = workInProgressHook.next;
        }
        if (nextWorkInProgressHook !== null) {
          workInProgressHook = nextWorkInProgressHook;
          nextWorkInProgressHook = workInProgressHook.next;
          currentHook = nextCurrentHook;
        } else {
          if (nextCurrentHook === null) {
            throw new Error("Rendered more hooks than during the previous render.");
          }
          currentHook = nextCurrentHook;
          var newHook = {
            memoizedState: currentHook.memoizedState,
            baseState: currentHook.baseState,
            baseQueue: currentHook.baseQueue,
            queue: currentHook.queue,
            next: null
          };
          if (workInProgressHook === null) {
            currentlyRenderingFiber$1.memoizedState = workInProgressHook = newHook;
          } else {
            workInProgressHook = workInProgressHook.next = newHook;
          }
        }
        return workInProgressHook;
      }
      function createFunctionComponentUpdateQueue() {
        return {
          lastEffect: null,
          stores: null
        };
      }
      function basicStateReducer(state, action) {
        return typeof action === "function" ? action(state) : action;
      }
      function mountReducer(reducer, initialArg, init) {
        var hook = mountWorkInProgressHook();
        var initialState;
        if (init !== undefined) {
          initialState = init(initialArg);
        } else {
          initialState = initialArg;
        }
        hook.memoizedState = hook.baseState = initialState;
        var queue = {
          pending: null,
          interleaved: null,
          lanes: NoLanes,
          dispatch: null,
          lastRenderedReducer: reducer,
          lastRenderedState: initialState
        };
        hook.queue = queue;
        var dispatch = queue.dispatch = dispatchReducerAction.bind(null, currentlyRenderingFiber$1, queue);
        return [hook.memoizedState, dispatch];
      }
      function updateReducer(reducer, initialArg, init) {
        var hook = updateWorkInProgressHook();
        var queue = hook.queue;
        if (queue === null) {
          throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
        }
        queue.lastRenderedReducer = reducer;
        var current2 = currentHook;
        var baseQueue = current2.baseQueue;
        var pendingQueue = queue.pending;
        if (pendingQueue !== null) {
          if (baseQueue !== null) {
            var baseFirst = baseQueue.next;
            var pendingFirst = pendingQueue.next;
            baseQueue.next = pendingFirst;
            pendingQueue.next = baseFirst;
          }
          {
            if (current2.baseQueue !== baseQueue) {
              error("Internal error: Expected work-in-progress queue to be a clone. " + "This is a bug in React.");
            }
          }
          current2.baseQueue = baseQueue = pendingQueue;
          queue.pending = null;
        }
        if (baseQueue !== null) {
          var first = baseQueue.next;
          var newState = current2.baseState;
          var newBaseState = null;
          var newBaseQueueFirst = null;
          var newBaseQueueLast = null;
          var update = first;
          do {
            var updateLane = update.lane;
            if (!isSubsetOfLanes(renderLanes, updateLane)) {
              var clone = {
                lane: updateLane,
                action: update.action,
                hasEagerState: update.hasEagerState,
                eagerState: update.eagerState,
                next: null
              };
              if (newBaseQueueLast === null) {
                newBaseQueueFirst = newBaseQueueLast = clone;
                newBaseState = newState;
              } else {
                newBaseQueueLast = newBaseQueueLast.next = clone;
              }
              currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, updateLane);
              markSkippedUpdateLanes(updateLane);
            } else {
              if (newBaseQueueLast !== null) {
                var _clone = {
                  lane: NoLane,
                  action: update.action,
                  hasEagerState: update.hasEagerState,
                  eagerState: update.eagerState,
                  next: null
                };
                newBaseQueueLast = newBaseQueueLast.next = _clone;
              }
              if (update.hasEagerState) {
                newState = update.eagerState;
              } else {
                var action = update.action;
                newState = reducer(newState, action);
              }
            }
            update = update.next;
          } while (update !== null && update !== first);
          if (newBaseQueueLast === null) {
            newBaseState = newState;
          } else {
            newBaseQueueLast.next = newBaseQueueFirst;
          }
          if (!objectIs(newState, hook.memoizedState)) {
            markWorkInProgressReceivedUpdate();
          }
          hook.memoizedState = newState;
          hook.baseState = newBaseState;
          hook.baseQueue = newBaseQueueLast;
          queue.lastRenderedState = newState;
        }
        var lastInterleaved = queue.interleaved;
        if (lastInterleaved !== null) {
          var interleaved = lastInterleaved;
          do {
            var interleavedLane = interleaved.lane;
            currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, interleavedLane);
            markSkippedUpdateLanes(interleavedLane);
            interleaved = interleaved.next;
          } while (interleaved !== lastInterleaved);
        } else if (baseQueue === null) {
          queue.lanes = NoLanes;
        }
        var dispatch = queue.dispatch;
        return [hook.memoizedState, dispatch];
      }
      function rerenderReducer(reducer, initialArg, init) {
        var hook = updateWorkInProgressHook();
        var queue = hook.queue;
        if (queue === null) {
          throw new Error("Should have a queue. This is likely a bug in React. Please file an issue.");
        }
        queue.lastRenderedReducer = reducer;
        var dispatch = queue.dispatch;
        var lastRenderPhaseUpdate = queue.pending;
        var newState = hook.memoizedState;
        if (lastRenderPhaseUpdate !== null) {
          queue.pending = null;
          var firstRenderPhaseUpdate = lastRenderPhaseUpdate.next;
          var update = firstRenderPhaseUpdate;
          do {
            var action = update.action;
            newState = reducer(newState, action);
            update = update.next;
          } while (update !== firstRenderPhaseUpdate);
          if (!objectIs(newState, hook.memoizedState)) {
            markWorkInProgressReceivedUpdate();
          }
          hook.memoizedState = newState;
          if (hook.baseQueue === null) {
            hook.baseState = newState;
          }
          queue.lastRenderedState = newState;
        }
        return [newState, dispatch];
      }
      function mountMutableSource(source, getSnapshot, subscribe) {
        {
          return;
        }
      }
      function updateMutableSource(source, getSnapshot, subscribe) {
        {
          return;
        }
      }
      function mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        var fiber = currentlyRenderingFiber$1;
        var hook = mountWorkInProgressHook();
        var nextSnapshot;
        var isHydrating2 = getIsHydrating();
        if (isHydrating2) {
          if (getServerSnapshot === undefined) {
            throw new Error("Missing getServerSnapshot, which is required for " + "server-rendered content. Will revert to client rendering.");
          }
          nextSnapshot = getServerSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              if (nextSnapshot !== getServerSnapshot()) {
                error("The result of getServerSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
        } else {
          nextSnapshot = getSnapshot();
          {
            if (!didWarnUncachedGetSnapshot) {
              var cachedSnapshot = getSnapshot();
              if (!objectIs(nextSnapshot, cachedSnapshot)) {
                error("The result of getSnapshot should be cached to avoid an infinite loop");
                didWarnUncachedGetSnapshot = true;
              }
            }
          }
          var root2 = getWorkInProgressRoot();
          if (root2 === null) {
            throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
          }
          if (!includesBlockingLane(root2, renderLanes)) {
            pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
          }
        }
        hook.memoizedState = nextSnapshot;
        var inst = {
          value: nextSnapshot,
          getSnapshot
        };
        hook.queue = inst;
        mountEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
        fiber.flags |= Passive;
        pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), undefined, null);
        return nextSnapshot;
      }
      function updateSyncExternalStore(subscribe, getSnapshot, getServerSnapshot) {
        var fiber = currentlyRenderingFiber$1;
        var hook = updateWorkInProgressHook();
        var nextSnapshot = getSnapshot();
        {
          if (!didWarnUncachedGetSnapshot) {
            var cachedSnapshot = getSnapshot();
            if (!objectIs(nextSnapshot, cachedSnapshot)) {
              error("The result of getSnapshot should be cached to avoid an infinite loop");
              didWarnUncachedGetSnapshot = true;
            }
          }
        }
        var prevSnapshot = hook.memoizedState;
        var snapshotChanged = !objectIs(prevSnapshot, nextSnapshot);
        if (snapshotChanged) {
          hook.memoizedState = nextSnapshot;
          markWorkInProgressReceivedUpdate();
        }
        var inst = hook.queue;
        updateEffect(subscribeToStore.bind(null, fiber, inst, subscribe), [subscribe]);
        if (inst.getSnapshot !== getSnapshot || snapshotChanged || workInProgressHook !== null && workInProgressHook.memoizedState.tag & HasEffect) {
          fiber.flags |= Passive;
          pushEffect(HasEffect | Passive$1, updateStoreInstance.bind(null, fiber, inst, nextSnapshot, getSnapshot), undefined, null);
          var root2 = getWorkInProgressRoot();
          if (root2 === null) {
            throw new Error("Expected a work-in-progress root. This is a bug in React. Please file an issue.");
          }
          if (!includesBlockingLane(root2, renderLanes)) {
            pushStoreConsistencyCheck(fiber, getSnapshot, nextSnapshot);
          }
        }
        return nextSnapshot;
      }
      function pushStoreConsistencyCheck(fiber, getSnapshot, renderedSnapshot) {
        fiber.flags |= StoreConsistency;
        var check = {
          getSnapshot,
          value: renderedSnapshot
        };
        var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
        if (componentUpdateQueue === null) {
          componentUpdateQueue = createFunctionComponentUpdateQueue();
          currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
          componentUpdateQueue.stores = [check];
        } else {
          var stores = componentUpdateQueue.stores;
          if (stores === null) {
            componentUpdateQueue.stores = [check];
          } else {
            stores.push(check);
          }
        }
      }
      function updateStoreInstance(fiber, inst, nextSnapshot, getSnapshot) {
        inst.value = nextSnapshot;
        inst.getSnapshot = getSnapshot;
        if (checkIfSnapshotChanged(inst)) {
          forceStoreRerender(fiber);
        }
      }
      function subscribeToStore(fiber, inst, subscribe) {
        var handleStoreChange = function() {
          if (checkIfSnapshotChanged(inst)) {
            forceStoreRerender(fiber);
          }
        };
        return subscribe(handleStoreChange);
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        var prevValue = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(prevValue, nextValue);
        } catch (error2) {
          return true;
        }
      }
      function forceStoreRerender(fiber) {
        var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
        if (root2 !== null) {
          scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
        }
      }
      function mountState(initialState) {
        var hook = mountWorkInProgressHook();
        if (typeof initialState === "function") {
          initialState = initialState();
        }
        hook.memoizedState = hook.baseState = initialState;
        var queue = {
          pending: null,
          interleaved: null,
          lanes: NoLanes,
          dispatch: null,
          lastRenderedReducer: basicStateReducer,
          lastRenderedState: initialState
        };
        hook.queue = queue;
        var dispatch = queue.dispatch = dispatchSetState.bind(null, currentlyRenderingFiber$1, queue);
        return [hook.memoizedState, dispatch];
      }
      function updateState(initialState) {
        return updateReducer(basicStateReducer);
      }
      function rerenderState(initialState) {
        return rerenderReducer(basicStateReducer);
      }
      function pushEffect(tag, create, destroy, deps) {
        var effect = {
          tag,
          create,
          destroy,
          deps,
          next: null
        };
        var componentUpdateQueue = currentlyRenderingFiber$1.updateQueue;
        if (componentUpdateQueue === null) {
          componentUpdateQueue = createFunctionComponentUpdateQueue();
          currentlyRenderingFiber$1.updateQueue = componentUpdateQueue;
          componentUpdateQueue.lastEffect = effect.next = effect;
        } else {
          var lastEffect = componentUpdateQueue.lastEffect;
          if (lastEffect === null) {
            componentUpdateQueue.lastEffect = effect.next = effect;
          } else {
            var firstEffect = lastEffect.next;
            lastEffect.next = effect;
            effect.next = firstEffect;
            componentUpdateQueue.lastEffect = effect;
          }
        }
        return effect;
      }
      function mountRef(initialValue) {
        var hook = mountWorkInProgressHook();
        {
          var _ref2 = {
            current: initialValue
          };
          hook.memoizedState = _ref2;
          return _ref2;
        }
      }
      function updateRef(initialValue) {
        var hook = updateWorkInProgressHook();
        return hook.memoizedState;
      }
      function mountEffectImpl(fiberFlags, hookFlags, create, deps) {
        var hook = mountWorkInProgressHook();
        var nextDeps = deps === undefined ? null : deps;
        currentlyRenderingFiber$1.flags |= fiberFlags;
        hook.memoizedState = pushEffect(HasEffect | hookFlags, create, undefined, nextDeps);
      }
      function updateEffectImpl(fiberFlags, hookFlags, create, deps) {
        var hook = updateWorkInProgressHook();
        var nextDeps = deps === undefined ? null : deps;
        var destroy = undefined;
        if (currentHook !== null) {
          var prevEffect = currentHook.memoizedState;
          destroy = prevEffect.destroy;
          if (nextDeps !== null) {
            var prevDeps = prevEffect.deps;
            if (areHookInputsEqual(nextDeps, prevDeps)) {
              hook.memoizedState = pushEffect(hookFlags, create, destroy, nextDeps);
              return;
            }
          }
        }
        currentlyRenderingFiber$1.flags |= fiberFlags;
        hook.memoizedState = pushEffect(HasEffect | hookFlags, create, destroy, nextDeps);
      }
      function mountEffect(create, deps) {
        if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
          return mountEffectImpl(MountPassiveDev | Passive | PassiveStatic, Passive$1, create, deps);
        } else {
          return mountEffectImpl(Passive | PassiveStatic, Passive$1, create, deps);
        }
      }
      function updateEffect(create, deps) {
        return updateEffectImpl(Passive, Passive$1, create, deps);
      }
      function mountInsertionEffect(create, deps) {
        return mountEffectImpl(Update, Insertion, create, deps);
      }
      function updateInsertionEffect(create, deps) {
        return updateEffectImpl(Update, Insertion, create, deps);
      }
      function mountLayoutEffect(create, deps) {
        var fiberFlags = Update;
        {
          fiberFlags |= LayoutStatic;
        }
        if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
          fiberFlags |= MountLayoutDev;
        }
        return mountEffectImpl(fiberFlags, Layout, create, deps);
      }
      function updateLayoutEffect(create, deps) {
        return updateEffectImpl(Update, Layout, create, deps);
      }
      function imperativeHandleEffect(create, ref) {
        if (typeof ref === "function") {
          var refCallback = ref;
          var _inst = create();
          refCallback(_inst);
          return function() {
            refCallback(null);
          };
        } else if (ref !== null && ref !== undefined) {
          var refObject = ref;
          {
            if (!refObject.hasOwnProperty("current")) {
              error("Expected useImperativeHandle() first argument to either be a " + "ref callback or React.createRef() object. Instead received: %s.", "an object with keys {" + Object.keys(refObject).join(", ") + "}");
            }
          }
          var _inst2 = create();
          refObject.current = _inst2;
          return function() {
            refObject.current = null;
          };
        }
      }
      function mountImperativeHandle(ref, create, deps) {
        {
          if (typeof create !== "function") {
            error("Expected useImperativeHandle() second argument to be a function " + "that creates a handle. Instead received: %s.", create !== null ? typeof create : "null");
          }
        }
        var effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;
        var fiberFlags = Update;
        {
          fiberFlags |= LayoutStatic;
        }
        if ((currentlyRenderingFiber$1.mode & StrictEffectsMode) !== NoMode) {
          fiberFlags |= MountLayoutDev;
        }
        return mountEffectImpl(fiberFlags, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
      }
      function updateImperativeHandle(ref, create, deps) {
        {
          if (typeof create !== "function") {
            error("Expected useImperativeHandle() second argument to be a function " + "that creates a handle. Instead received: %s.", create !== null ? typeof create : "null");
          }
        }
        var effectDeps = deps !== null && deps !== undefined ? deps.concat([ref]) : null;
        return updateEffectImpl(Update, Layout, imperativeHandleEffect.bind(null, create, ref), effectDeps);
      }
      function mountDebugValue(value, formatterFn) {}
      var updateDebugValue = mountDebugValue;
      function mountCallback(callback, deps) {
        var hook = mountWorkInProgressHook();
        var nextDeps = deps === undefined ? null : deps;
        hook.memoizedState = [callback, nextDeps];
        return callback;
      }
      function updateCallback(callback, deps) {
        var hook = updateWorkInProgressHook();
        var nextDeps = deps === undefined ? null : deps;
        var prevState = hook.memoizedState;
        if (prevState !== null) {
          if (nextDeps !== null) {
            var prevDeps = prevState[1];
            if (areHookInputsEqual(nextDeps, prevDeps)) {
              return prevState[0];
            }
          }
        }
        hook.memoizedState = [callback, nextDeps];
        return callback;
      }
      function mountMemo(nextCreate, deps) {
        var hook = mountWorkInProgressHook();
        var nextDeps = deps === undefined ? null : deps;
        var nextValue = nextCreate();
        hook.memoizedState = [nextValue, nextDeps];
        return nextValue;
      }
      function updateMemo(nextCreate, deps) {
        var hook = updateWorkInProgressHook();
        var nextDeps = deps === undefined ? null : deps;
        var prevState = hook.memoizedState;
        if (prevState !== null) {
          if (nextDeps !== null) {
            var prevDeps = prevState[1];
            if (areHookInputsEqual(nextDeps, prevDeps)) {
              return prevState[0];
            }
          }
        }
        var nextValue = nextCreate();
        hook.memoizedState = [nextValue, nextDeps];
        return nextValue;
      }
      function mountDeferredValue(value) {
        var hook = mountWorkInProgressHook();
        hook.memoizedState = value;
        return value;
      }
      function updateDeferredValue(value) {
        var hook = updateWorkInProgressHook();
        var resolvedCurrentHook = currentHook;
        var prevValue = resolvedCurrentHook.memoizedState;
        return updateDeferredValueImpl(hook, prevValue, value);
      }
      function rerenderDeferredValue(value) {
        var hook = updateWorkInProgressHook();
        if (currentHook === null) {
          hook.memoizedState = value;
          return value;
        } else {
          var prevValue = currentHook.memoizedState;
          return updateDeferredValueImpl(hook, prevValue, value);
        }
      }
      function updateDeferredValueImpl(hook, prevValue, value) {
        var shouldDeferValue = !includesOnlyNonUrgentLanes(renderLanes);
        if (shouldDeferValue) {
          if (!objectIs(value, prevValue)) {
            var deferredLane = claimNextTransitionLane();
            currentlyRenderingFiber$1.lanes = mergeLanes(currentlyRenderingFiber$1.lanes, deferredLane);
            markSkippedUpdateLanes(deferredLane);
            hook.baseState = true;
          }
          return prevValue;
        } else {
          if (hook.baseState) {
            hook.baseState = false;
            markWorkInProgressReceivedUpdate();
          }
          hook.memoizedState = value;
          return value;
        }
      }
      function startTransition(setPending, callback, options2) {
        var previousPriority = getCurrentUpdatePriority();
        setCurrentUpdatePriority(higherEventPriority(previousPriority, ContinuousEventPriority));
        setPending(true);
        var prevTransition = ReactCurrentBatchConfig$2.transition;
        ReactCurrentBatchConfig$2.transition = {};
        var currentTransition = ReactCurrentBatchConfig$2.transition;
        {
          ReactCurrentBatchConfig$2.transition._updatedFibers = new Set;
        }
        try {
          setPending(false);
          callback();
        } finally {
          setCurrentUpdatePriority(previousPriority);
          ReactCurrentBatchConfig$2.transition = prevTransition;
          {
            if (prevTransition === null && currentTransition._updatedFibers) {
              var updatedFibersCount = currentTransition._updatedFibers.size;
              if (updatedFibersCount > 10) {
                warn("Detected a large number of updates inside startTransition. " + "If this is due to a subscription please re-write it to use React provided hooks. " + "Otherwise concurrent mode guarantees are off the table.");
              }
              currentTransition._updatedFibers.clear();
            }
          }
        }
      }
      function mountTransition() {
        var _mountState = mountState(false), isPending = _mountState[0], setPending = _mountState[1];
        var start = startTransition.bind(null, setPending);
        var hook = mountWorkInProgressHook();
        hook.memoizedState = start;
        return [isPending, start];
      }
      function updateTransition() {
        var _updateState = updateState(), isPending = _updateState[0];
        var hook = updateWorkInProgressHook();
        var start = hook.memoizedState;
        return [isPending, start];
      }
      function rerenderTransition() {
        var _rerenderState = rerenderState(), isPending = _rerenderState[0];
        var hook = updateWorkInProgressHook();
        var start = hook.memoizedState;
        return [isPending, start];
      }
      var isUpdatingOpaqueValueInRenderPhase = false;
      function getIsUpdatingOpaqueValueInRenderPhaseInDEV() {
        {
          return isUpdatingOpaqueValueInRenderPhase;
        }
      }
      function mountId() {
        var hook = mountWorkInProgressHook();
        var root2 = getWorkInProgressRoot();
        var identifierPrefix = root2.identifierPrefix;
        var id;
        if (getIsHydrating()) {
          var treeId = getTreeId();
          id = ":" + identifierPrefix + "R" + treeId;
          var localId = localIdCounter++;
          if (localId > 0) {
            id += "H" + localId.toString(32);
          }
          id += ":";
        } else {
          var globalClientId = globalClientIdCounter++;
          id = ":" + identifierPrefix + "r" + globalClientId.toString(32) + ":";
        }
        hook.memoizedState = id;
        return id;
      }
      function updateId() {
        var hook = updateWorkInProgressHook();
        var id = hook.memoizedState;
        return id;
      }
      function dispatchReducerAction(fiber, queue, action) {
        {
          if (typeof arguments[3] === "function") {
            error("State updates from the useState() and useReducer() Hooks don't support the " + "second callback argument. To execute a side effect after " + "rendering, declare it in the component body with useEffect().");
          }
        }
        var lane = requestUpdateLane(fiber);
        var update = {
          lane,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        if (isRenderPhaseUpdate(fiber)) {
          enqueueRenderPhaseUpdate(queue, update);
        } else {
          var root2 = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
          if (root2 !== null) {
            var eventTime = requestEventTime();
            scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
            entangleTransitionUpdate(root2, queue, lane);
          }
        }
        markUpdateInDevTools(fiber, lane);
      }
      function dispatchSetState(fiber, queue, action) {
        {
          if (typeof arguments[3] === "function") {
            error("State updates from the useState() and useReducer() Hooks don't support the " + "second callback argument. To execute a side effect after " + "rendering, declare it in the component body with useEffect().");
          }
        }
        var lane = requestUpdateLane(fiber);
        var update = {
          lane,
          action,
          hasEagerState: false,
          eagerState: null,
          next: null
        };
        if (isRenderPhaseUpdate(fiber)) {
          enqueueRenderPhaseUpdate(queue, update);
        } else {
          var alternate = fiber.alternate;
          if (fiber.lanes === NoLanes && (alternate === null || alternate.lanes === NoLanes)) {
            var lastRenderedReducer = queue.lastRenderedReducer;
            if (lastRenderedReducer !== null) {
              var prevDispatcher;
              {
                prevDispatcher = ReactCurrentDispatcher$1.current;
                ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
              }
              try {
                var currentState = queue.lastRenderedState;
                var eagerState = lastRenderedReducer(currentState, action);
                update.hasEagerState = true;
                update.eagerState = eagerState;
                if (objectIs(eagerState, currentState)) {
                  enqueueConcurrentHookUpdateAndEagerlyBailout(fiber, queue, update, lane);
                  return;
                }
              } catch (error2) {} finally {
                {
                  ReactCurrentDispatcher$1.current = prevDispatcher;
                }
              }
            }
          }
          var root2 = enqueueConcurrentHookUpdate(fiber, queue, update, lane);
          if (root2 !== null) {
            var eventTime = requestEventTime();
            scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
            entangleTransitionUpdate(root2, queue, lane);
          }
        }
        markUpdateInDevTools(fiber, lane);
      }
      function isRenderPhaseUpdate(fiber) {
        var alternate = fiber.alternate;
        return fiber === currentlyRenderingFiber$1 || alternate !== null && alternate === currentlyRenderingFiber$1;
      }
      function enqueueRenderPhaseUpdate(queue, update) {
        didScheduleRenderPhaseUpdateDuringThisPass = didScheduleRenderPhaseUpdate = true;
        var pending = queue.pending;
        if (pending === null) {
          update.next = update;
        } else {
          update.next = pending.next;
          pending.next = update;
        }
        queue.pending = update;
      }
      function entangleTransitionUpdate(root2, queue, lane) {
        if (isTransitionLane(lane)) {
          var queueLanes = queue.lanes;
          queueLanes = intersectLanes(queueLanes, root2.pendingLanes);
          var newQueueLanes = mergeLanes(queueLanes, lane);
          queue.lanes = newQueueLanes;
          markRootEntangled(root2, newQueueLanes);
        }
      }
      function markUpdateInDevTools(fiber, lane, action) {
        {
          markStateUpdateScheduled(fiber, lane);
        }
      }
      var ContextOnlyDispatcher = {
        readContext,
        useCallback: throwInvalidHookError,
        useContext: throwInvalidHookError,
        useEffect: throwInvalidHookError,
        useImperativeHandle: throwInvalidHookError,
        useInsertionEffect: throwInvalidHookError,
        useLayoutEffect: throwInvalidHookError,
        useMemo: throwInvalidHookError,
        useReducer: throwInvalidHookError,
        useRef: throwInvalidHookError,
        useState: throwInvalidHookError,
        useDebugValue: throwInvalidHookError,
        useDeferredValue: throwInvalidHookError,
        useTransition: throwInvalidHookError,
        useMutableSource: throwInvalidHookError,
        useSyncExternalStore: throwInvalidHookError,
        useId: throwInvalidHookError,
        unstable_isNewReconciler: enableNewReconciler
      };
      var HooksDispatcherOnMountInDEV = null;
      var HooksDispatcherOnMountWithHookTypesInDEV = null;
      var HooksDispatcherOnUpdateInDEV = null;
      var HooksDispatcherOnRerenderInDEV = null;
      var InvalidNestedHooksDispatcherOnMountInDEV = null;
      var InvalidNestedHooksDispatcherOnUpdateInDEV = null;
      var InvalidNestedHooksDispatcherOnRerenderInDEV = null;
      {
        var warnInvalidContextAccess = function() {
          error("Context can only be read while React is rendering. " + "In classes, you can read it in the render method or getDerivedStateFromProps. " + "In function components, you can read it directly in the function body, but not " + "inside Hooks like useReducer() or useMemo().");
        };
        var warnInvalidHookAccess = function() {
          error("Do not call Hooks inside useEffect(...), useMemo(...), or other built-in Hooks. " + "You can only call Hooks at the top level of your React function. " + "For more information, see " + "https://reactjs.org/link/rules-of-hooks");
        };
        HooksDispatcherOnMountInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            mountHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountInsertionEffect(create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            return mountLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            mountHookTypesDev();
            checkDepsAreArrayDev(deps);
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            mountHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value, formatterFn) {
            currentHookNameInDev = "useDebugValue";
            mountHookTypesDev();
            return mountDebugValue();
          },
          useDeferredValue: function(value) {
            currentHookNameInDev = "useDeferredValue";
            mountHookTypesDev();
            return mountDeferredValue(value);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            mountHookTypesDev();
            return mountTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = "useMutableSource";
            mountHookTypesDev();
            return mountMutableSource();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            mountHookTypesDev();
            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
          },
          useId: function() {
            currentHookNameInDev = "useId";
            mountHookTypesDev();
            return mountId();
          },
          unstable_isNewReconciler: enableNewReconciler
        };
        HooksDispatcherOnMountWithHookTypesInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return mountCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            return mountEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return mountImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            return mountInsertionEffect(create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return mountLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value, formatterFn) {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
            return mountDebugValue();
          },
          useDeferredValue: function(value) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return mountDeferredValue(value);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return mountTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = "useMutableSource";
            updateHookTypesDev();
            return mountMutableSource();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return mountId();
          },
          unstable_isNewReconciler: enableNewReconciler
        };
        HooksDispatcherOnUpdateInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            return updateEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            return updateInsertionEffect(create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return updateLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(reducer, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return updateRef();
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value, formatterFn) {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
            return updateDebugValue();
          },
          useDeferredValue: function(value) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return updateDeferredValue(value);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return updateTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = "useMutableSource";
            updateHookTypesDev();
            return updateMutableSource();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return updateSyncExternalStore(subscribe, getSnapshot);
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return updateId();
          },
          unstable_isNewReconciler: enableNewReconciler
        };
        HooksDispatcherOnRerenderInDEV = {
          readContext: function(context) {
            return readContext(context);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            updateHookTypesDev();
            return updateEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            updateHookTypesDev();
            return updateInsertionEffect(create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            updateHookTypesDev();
            return updateLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return rerenderReducer(reducer, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            updateHookTypesDev();
            return updateRef();
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnRerenderInDEV;
            try {
              return rerenderState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value, formatterFn) {
            currentHookNameInDev = "useDebugValue";
            updateHookTypesDev();
            return updateDebugValue();
          },
          useDeferredValue: function(value) {
            currentHookNameInDev = "useDeferredValue";
            updateHookTypesDev();
            return rerenderDeferredValue(value);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            updateHookTypesDev();
            return rerenderTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = "useMutableSource";
            updateHookTypesDev();
            return updateMutableSource();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            updateHookTypesDev();
            return updateSyncExternalStore(subscribe, getSnapshot);
          },
          useId: function() {
            currentHookNameInDev = "useId";
            updateHookTypesDev();
            return updateId();
          },
          unstable_isNewReconciler: enableNewReconciler
        };
        InvalidNestedHooksDispatcherOnMountInDEV = {
          readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountInsertionEffect(create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountMemo(create, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountReducer(reducer, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountRef(initialValue);
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            mountHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnMountInDEV;
            try {
              return mountState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value, formatterFn) {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountDebugValue();
          },
          useDeferredValue: function(value) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountDeferredValue(value);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = "useMutableSource";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountMutableSource();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountSyncExternalStore(subscribe, getSnapshot, getServerSnapshot);
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            mountHookTypesDev();
            return mountId();
          },
          unstable_isNewReconciler: enableNewReconciler
        };
        InvalidNestedHooksDispatcherOnUpdateInDEV = {
          readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateInsertionEffect(create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateReducer(reducer, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateRef();
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value, formatterFn) {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateDebugValue();
          },
          useDeferredValue: function(value) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateDeferredValue(value);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = "useMutableSource";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateMutableSource();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateSyncExternalStore(subscribe, getSnapshot);
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateId();
          },
          unstable_isNewReconciler: enableNewReconciler
        };
        InvalidNestedHooksDispatcherOnRerenderInDEV = {
          readContext: function(context) {
            warnInvalidContextAccess();
            return readContext(context);
          },
          useCallback: function(callback, deps) {
            currentHookNameInDev = "useCallback";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateCallback(callback, deps);
          },
          useContext: function(context) {
            currentHookNameInDev = "useContext";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return readContext(context);
          },
          useEffect: function(create, deps) {
            currentHookNameInDev = "useEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateEffect(create, deps);
          },
          useImperativeHandle: function(ref, create, deps) {
            currentHookNameInDev = "useImperativeHandle";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateImperativeHandle(ref, create, deps);
          },
          useInsertionEffect: function(create, deps) {
            currentHookNameInDev = "useInsertionEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateInsertionEffect(create, deps);
          },
          useLayoutEffect: function(create, deps) {
            currentHookNameInDev = "useLayoutEffect";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateLayoutEffect(create, deps);
          },
          useMemo: function(create, deps) {
            currentHookNameInDev = "useMemo";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return updateMemo(create, deps);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useReducer: function(reducer, initialArg, init) {
            currentHookNameInDev = "useReducer";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return rerenderReducer(reducer, initialArg, init);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useRef: function(initialValue) {
            currentHookNameInDev = "useRef";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateRef();
          },
          useState: function(initialState) {
            currentHookNameInDev = "useState";
            warnInvalidHookAccess();
            updateHookTypesDev();
            var prevDispatcher = ReactCurrentDispatcher$1.current;
            ReactCurrentDispatcher$1.current = InvalidNestedHooksDispatcherOnUpdateInDEV;
            try {
              return rerenderState(initialState);
            } finally {
              ReactCurrentDispatcher$1.current = prevDispatcher;
            }
          },
          useDebugValue: function(value, formatterFn) {
            currentHookNameInDev = "useDebugValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateDebugValue();
          },
          useDeferredValue: function(value) {
            currentHookNameInDev = "useDeferredValue";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderDeferredValue(value);
          },
          useTransition: function() {
            currentHookNameInDev = "useTransition";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return rerenderTransition();
          },
          useMutableSource: function(source, getSnapshot, subscribe) {
            currentHookNameInDev = "useMutableSource";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateMutableSource();
          },
          useSyncExternalStore: function(subscribe, getSnapshot, getServerSnapshot) {
            currentHookNameInDev = "useSyncExternalStore";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateSyncExternalStore(subscribe, getSnapshot);
          },
          useId: function() {
            currentHookNameInDev = "useId";
            warnInvalidHookAccess();
            updateHookTypesDev();
            return updateId();
          },
          unstable_isNewReconciler: enableNewReconciler
        };
      }
      var now$1 = Scheduler.unstable_now;
      var commitTime = 0;
      var layoutEffectStartTime = -1;
      var profilerStartTime = -1;
      var passiveEffectStartTime = -1;
      var currentUpdateIsNested = false;
      var nestedUpdateScheduled = false;
      function isCurrentUpdateNested() {
        return currentUpdateIsNested;
      }
      function markNestedUpdateScheduled() {
        {
          nestedUpdateScheduled = true;
        }
      }
      function resetNestedUpdateFlag() {
        {
          currentUpdateIsNested = false;
          nestedUpdateScheduled = false;
        }
      }
      function syncNestedUpdateFlag() {
        {
          currentUpdateIsNested = nestedUpdateScheduled;
          nestedUpdateScheduled = false;
        }
      }
      function getCommitTime() {
        return commitTime;
      }
      function recordCommitTime() {
        commitTime = now$1();
      }
      function startProfilerTimer(fiber) {
        profilerStartTime = now$1();
        if (fiber.actualStartTime < 0) {
          fiber.actualStartTime = now$1();
        }
      }
      function stopProfilerTimerIfRunning(fiber) {
        profilerStartTime = -1;
      }
      function stopProfilerTimerIfRunningAndRecordDelta(fiber, overrideBaseTime) {
        if (profilerStartTime >= 0) {
          var elapsedTime = now$1() - profilerStartTime;
          fiber.actualDuration += elapsedTime;
          if (overrideBaseTime) {
            fiber.selfBaseDuration = elapsedTime;
          }
          profilerStartTime = -1;
        }
      }
      function recordLayoutEffectDuration(fiber) {
        if (layoutEffectStartTime >= 0) {
          var elapsedTime = now$1() - layoutEffectStartTime;
          layoutEffectStartTime = -1;
          var parentFiber = fiber.return;
          while (parentFiber !== null) {
            switch (parentFiber.tag) {
              case HostRoot:
                var root2 = parentFiber.stateNode;
                root2.effectDuration += elapsedTime;
                return;
              case Profiler:
                var parentStateNode = parentFiber.stateNode;
                parentStateNode.effectDuration += elapsedTime;
                return;
            }
            parentFiber = parentFiber.return;
          }
        }
      }
      function recordPassiveEffectDuration(fiber) {
        if (passiveEffectStartTime >= 0) {
          var elapsedTime = now$1() - passiveEffectStartTime;
          passiveEffectStartTime = -1;
          var parentFiber = fiber.return;
          while (parentFiber !== null) {
            switch (parentFiber.tag) {
              case HostRoot:
                var root2 = parentFiber.stateNode;
                if (root2 !== null) {
                  root2.passiveEffectDuration += elapsedTime;
                }
                return;
              case Profiler:
                var parentStateNode = parentFiber.stateNode;
                if (parentStateNode !== null) {
                  parentStateNode.passiveEffectDuration += elapsedTime;
                }
                return;
            }
            parentFiber = parentFiber.return;
          }
        }
      }
      function startLayoutEffectTimer() {
        layoutEffectStartTime = now$1();
      }
      function startPassiveEffectTimer() {
        passiveEffectStartTime = now$1();
      }
      function transferActualDuration(fiber) {
        var child = fiber.child;
        while (child) {
          fiber.actualDuration += child.actualDuration;
          child = child.sibling;
        }
      }
      function resolveDefaultProps(Component, baseProps) {
        if (Component && Component.defaultProps) {
          var props = assign({}, baseProps);
          var defaultProps = Component.defaultProps;
          for (var propName in defaultProps) {
            if (props[propName] === undefined) {
              props[propName] = defaultProps[propName];
            }
          }
          return props;
        }
        return baseProps;
      }
      var fakeInternalInstance = {};
      var didWarnAboutStateAssignmentForComponent;
      var didWarnAboutUninitializedState;
      var didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate;
      var didWarnAboutLegacyLifecyclesAndDerivedState;
      var didWarnAboutUndefinedDerivedState;
      var warnOnUndefinedDerivedState;
      var warnOnInvalidCallback;
      var didWarnAboutDirectlyAssigningPropsToState;
      var didWarnAboutContextTypeAndContextTypes;
      var didWarnAboutInvalidateContextType;
      var didWarnAboutLegacyContext$1;
      {
        didWarnAboutStateAssignmentForComponent = new Set;
        didWarnAboutUninitializedState = new Set;
        didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate = new Set;
        didWarnAboutLegacyLifecyclesAndDerivedState = new Set;
        didWarnAboutDirectlyAssigningPropsToState = new Set;
        didWarnAboutUndefinedDerivedState = new Set;
        didWarnAboutContextTypeAndContextTypes = new Set;
        didWarnAboutInvalidateContextType = new Set;
        didWarnAboutLegacyContext$1 = new Set;
        var didWarnOnInvalidCallback = new Set;
        warnOnInvalidCallback = function(callback, callerName) {
          if (callback === null || typeof callback === "function") {
            return;
          }
          var key = callerName + "_" + callback;
          if (!didWarnOnInvalidCallback.has(key)) {
            didWarnOnInvalidCallback.add(key);
            error("%s(...): Expected the last optional `callback` argument to be a " + "function. Instead received: %s.", callerName, callback);
          }
        };
        warnOnUndefinedDerivedState = function(type, partialState) {
          if (partialState === undefined) {
            var componentName = getComponentNameFromType(type) || "Component";
            if (!didWarnAboutUndefinedDerivedState.has(componentName)) {
              didWarnAboutUndefinedDerivedState.add(componentName);
              error("%s.getDerivedStateFromProps(): A valid state object (or null) must be returned. " + "You have returned undefined.", componentName);
            }
          }
        };
        Object.defineProperty(fakeInternalInstance, "_processChildContext", {
          enumerable: false,
          value: function() {
            throw new Error("_processChildContext is not available in React 16+. This likely " + "means you have multiple copies of React and are attempting to nest " + "a React 15 tree inside a React 16 tree using " + "unstable_renderSubtreeIntoContainer, which isn't supported. Try " + "to make sure you have only one copy of React (and ideally, switch " + "to ReactDOM.createPortal).");
          }
        });
        Object.freeze(fakeInternalInstance);
      }
      function applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, nextProps) {
        var prevState = workInProgress2.memoizedState;
        var partialState = getDerivedStateFromProps(nextProps, prevState);
        {
          if (workInProgress2.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(true);
            try {
              partialState = getDerivedStateFromProps(nextProps, prevState);
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          warnOnUndefinedDerivedState(ctor, partialState);
        }
        var memoizedState = partialState === null || partialState === undefined ? prevState : assign({}, prevState, partialState);
        workInProgress2.memoizedState = memoizedState;
        if (workInProgress2.lanes === NoLanes) {
          var updateQueue = workInProgress2.updateQueue;
          updateQueue.baseState = memoizedState;
        }
      }
      var classComponentUpdater = {
        isMounted,
        enqueueSetState: function(inst, payload, callback) {
          var fiber = get(inst);
          var eventTime = requestEventTime();
          var lane = requestUpdateLane(fiber);
          var update = createUpdate(eventTime, lane);
          update.payload = payload;
          if (callback !== undefined && callback !== null) {
            {
              warnOnInvalidCallback(callback, "setState");
            }
            update.callback = callback;
          }
          var root2 = enqueueUpdate(fiber, update, lane);
          if (root2 !== null) {
            scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
            entangleTransitions(root2, fiber, lane);
          }
          {
            markStateUpdateScheduled(fiber, lane);
          }
        },
        enqueueReplaceState: function(inst, payload, callback) {
          var fiber = get(inst);
          var eventTime = requestEventTime();
          var lane = requestUpdateLane(fiber);
          var update = createUpdate(eventTime, lane);
          update.tag = ReplaceState;
          update.payload = payload;
          if (callback !== undefined && callback !== null) {
            {
              warnOnInvalidCallback(callback, "replaceState");
            }
            update.callback = callback;
          }
          var root2 = enqueueUpdate(fiber, update, lane);
          if (root2 !== null) {
            scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
            entangleTransitions(root2, fiber, lane);
          }
          {
            markStateUpdateScheduled(fiber, lane);
          }
        },
        enqueueForceUpdate: function(inst, callback) {
          var fiber = get(inst);
          var eventTime = requestEventTime();
          var lane = requestUpdateLane(fiber);
          var update = createUpdate(eventTime, lane);
          update.tag = ForceUpdate;
          if (callback !== undefined && callback !== null) {
            {
              warnOnInvalidCallback(callback, "forceUpdate");
            }
            update.callback = callback;
          }
          var root2 = enqueueUpdate(fiber, update, lane);
          if (root2 !== null) {
            scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
            entangleTransitions(root2, fiber, lane);
          }
          {
            markForceUpdateScheduled(fiber, lane);
          }
        }
      };
      function checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) {
        var instance = workInProgress2.stateNode;
        if (typeof instance.shouldComponentUpdate === "function") {
          var shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
          {
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                shouldUpdate = instance.shouldComponentUpdate(newProps, newState, nextContext);
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            if (shouldUpdate === undefined) {
              error("%s.shouldComponentUpdate(): Returned undefined instead of a " + "boolean value. Make sure to return true or false.", getComponentNameFromType(ctor) || "Component");
            }
          }
          return shouldUpdate;
        }
        if (ctor.prototype && ctor.prototype.isPureReactComponent) {
          return !shallowEqual(oldProps, newProps) || !shallowEqual(oldState, newState);
        }
        return true;
      }
      function checkClassInstance(workInProgress2, ctor, newProps) {
        var instance = workInProgress2.stateNode;
        {
          var name = getComponentNameFromType(ctor) || "Component";
          var renderPresent = instance.render;
          if (!renderPresent) {
            if (ctor.prototype && typeof ctor.prototype.render === "function") {
              error("%s(...): No `render` method found on the returned component " + "instance: did you accidentally return an object from the constructor?", name);
            } else {
              error("%s(...): No `render` method found on the returned component " + "instance: you may have forgotten to define `render`.", name);
            }
          }
          if (instance.getInitialState && !instance.getInitialState.isReactClassApproved && !instance.state) {
            error("getInitialState was defined on %s, a plain JavaScript class. " + "This is only supported for classes created using React.createClass. " + "Did you mean to define a state property instead?", name);
          }
          if (instance.getDefaultProps && !instance.getDefaultProps.isReactClassApproved) {
            error("getDefaultProps was defined on %s, a plain JavaScript class. " + "This is only supported for classes created using React.createClass. " + "Use a static property to define defaultProps instead.", name);
          }
          if (instance.propTypes) {
            error("propTypes was defined as an instance property on %s. Use a static " + "property to define propTypes instead.", name);
          }
          if (instance.contextType) {
            error("contextType was defined as an instance property on %s. Use a static " + "property to define contextType instead.", name);
          }
          {
            if (ctor.childContextTypes && !didWarnAboutLegacyContext$1.has(ctor) && (workInProgress2.mode & StrictLegacyMode) === NoMode) {
              didWarnAboutLegacyContext$1.add(ctor);
              error("%s uses the legacy childContextTypes API which is no longer " + "supported and will be removed in the next major release. Use " + `React.createContext() instead

.` + "Learn more about this warning here: https://reactjs.org/link/legacy-context", name);
            }
            if (ctor.contextTypes && !didWarnAboutLegacyContext$1.has(ctor) && (workInProgress2.mode & StrictLegacyMode) === NoMode) {
              didWarnAboutLegacyContext$1.add(ctor);
              error("%s uses the legacy contextTypes API which is no longer supported " + "and will be removed in the next major release. Use " + `React.createContext() with static contextType instead.

` + "Learn more about this warning here: https://reactjs.org/link/legacy-context", name);
            }
            if (instance.contextTypes) {
              error("contextTypes was defined as an instance property on %s. Use a static " + "property to define contextTypes instead.", name);
            }
            if (ctor.contextType && ctor.contextTypes && !didWarnAboutContextTypeAndContextTypes.has(ctor)) {
              didWarnAboutContextTypeAndContextTypes.add(ctor);
              error("%s declares both contextTypes and contextType static properties. " + "The legacy contextTypes property will be ignored.", name);
            }
          }
          if (typeof instance.componentShouldUpdate === "function") {
            error("%s has a method called " + "componentShouldUpdate(). Did you mean shouldComponentUpdate()? " + "The name is phrased as a question because the function is " + "expected to return a value.", name);
          }
          if (ctor.prototype && ctor.prototype.isPureReactComponent && typeof instance.shouldComponentUpdate !== "undefined") {
            error("%s has a method called shouldComponentUpdate(). " + "shouldComponentUpdate should not be used when extending React.PureComponent. " + "Please extend React.Component if shouldComponentUpdate is used.", getComponentNameFromType(ctor) || "A pure component");
          }
          if (typeof instance.componentDidUnmount === "function") {
            error("%s has a method called " + "componentDidUnmount(). But there is no such lifecycle method. " + "Did you mean componentWillUnmount()?", name);
          }
          if (typeof instance.componentDidReceiveProps === "function") {
            error("%s has a method called " + "componentDidReceiveProps(). But there is no such lifecycle method. " + "If you meant to update the state in response to changing props, " + "use componentWillReceiveProps(). If you meant to fetch data or " + "run side-effects or mutations after React has updated the UI, use componentDidUpdate().", name);
          }
          if (typeof instance.componentWillRecieveProps === "function") {
            error("%s has a method called " + "componentWillRecieveProps(). Did you mean componentWillReceiveProps()?", name);
          }
          if (typeof instance.UNSAFE_componentWillRecieveProps === "function") {
            error("%s has a method called " + "UNSAFE_componentWillRecieveProps(). Did you mean UNSAFE_componentWillReceiveProps()?", name);
          }
          var hasMutatedProps = instance.props !== newProps;
          if (instance.props !== undefined && hasMutatedProps) {
            error("%s(...): When calling super() in `%s`, make sure to pass " + "up the same props that your component's constructor was passed.", name, name);
          }
          if (instance.defaultProps) {
            error("Setting defaultProps as an instance property on %s is not supported and will be ignored." + " Instead, define defaultProps as a static property on %s.", name, name);
          }
          if (typeof instance.getSnapshotBeforeUpdate === "function" && typeof instance.componentDidUpdate !== "function" && !didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.has(ctor)) {
            didWarnAboutGetSnapshotBeforeUpdateWithoutDidUpdate.add(ctor);
            error("%s: getSnapshotBeforeUpdate() should be used with componentDidUpdate(). " + "This component defines getSnapshotBeforeUpdate() only.", getComponentNameFromType(ctor));
          }
          if (typeof instance.getDerivedStateFromProps === "function") {
            error("%s: getDerivedStateFromProps() is defined as an instance method " + "and will be ignored. Instead, declare it as a static method.", name);
          }
          if (typeof instance.getDerivedStateFromError === "function") {
            error("%s: getDerivedStateFromError() is defined as an instance method " + "and will be ignored. Instead, declare it as a static method.", name);
          }
          if (typeof ctor.getSnapshotBeforeUpdate === "function") {
            error("%s: getSnapshotBeforeUpdate() is defined as a static method " + "and will be ignored. Instead, declare it as an instance method.", name);
          }
          var _state = instance.state;
          if (_state && (typeof _state !== "object" || isArray(_state))) {
            error("%s.state: must be set to an object or null", name);
          }
          if (typeof instance.getChildContext === "function" && typeof ctor.childContextTypes !== "object") {
            error("%s.getChildContext(): childContextTypes must be defined in order to " + "use getChildContext().", name);
          }
        }
      }
      function adoptClassInstance(workInProgress2, instance) {
        instance.updater = classComponentUpdater;
        workInProgress2.stateNode = instance;
        set(instance, workInProgress2);
        {
          instance._reactInternalInstance = fakeInternalInstance;
        }
      }
      function constructClassInstance(workInProgress2, ctor, props) {
        var isLegacyContextConsumer = false;
        var unmaskedContext = emptyContextObject;
        var context = emptyContextObject;
        var contextType = ctor.contextType;
        {
          if ("contextType" in ctor) {
            var isValid = contextType === null || contextType !== undefined && contextType.$$typeof === REACT_CONTEXT_TYPE && contextType._context === undefined;
            if (!isValid && !didWarnAboutInvalidateContextType.has(ctor)) {
              didWarnAboutInvalidateContextType.add(ctor);
              var addendum = "";
              if (contextType === undefined) {
                addendum = " However, it is set to undefined. " + "This can be caused by a typo or by mixing up named and default imports. " + "This can also happen due to a circular dependency, so " + "try moving the createContext() call to a separate file.";
              } else if (typeof contextType !== "object") {
                addendum = " However, it is set to a " + typeof contextType + ".";
              } else if (contextType.$$typeof === REACT_PROVIDER_TYPE) {
                addendum = " Did you accidentally pass the Context.Provider instead?";
              } else if (contextType._context !== undefined) {
                addendum = " Did you accidentally pass the Context.Consumer instead?";
              } else {
                addendum = " However, it is set to an object with keys {" + Object.keys(contextType).join(", ") + "}.";
              }
              error("%s defines an invalid contextType. " + "contextType should point to the Context object returned by React.createContext().%s", getComponentNameFromType(ctor) || "Component", addendum);
            }
          }
        }
        if (typeof contextType === "object" && contextType !== null) {
          context = readContext(contextType);
        } else {
          unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
          var contextTypes = ctor.contextTypes;
          isLegacyContextConsumer = contextTypes !== null && contextTypes !== undefined;
          context = isLegacyContextConsumer ? getMaskedContext(workInProgress2, unmaskedContext) : emptyContextObject;
        }
        var instance = new ctor(props, context);
        {
          if (workInProgress2.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(true);
            try {
              instance = new ctor(props, context);
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
        }
        var state = workInProgress2.memoizedState = instance.state !== null && instance.state !== undefined ? instance.state : null;
        adoptClassInstance(workInProgress2, instance);
        {
          if (typeof ctor.getDerivedStateFromProps === "function" && state === null) {
            var componentName = getComponentNameFromType(ctor) || "Component";
            if (!didWarnAboutUninitializedState.has(componentName)) {
              didWarnAboutUninitializedState.add(componentName);
              error("`%s` uses `getDerivedStateFromProps` but its initial state is " + "%s. This is not recommended. Instead, define the initial state by " + "assigning an object to `this.state` in the constructor of `%s`. " + "This ensures that `getDerivedStateFromProps` arguments have a consistent shape.", componentName, instance.state === null ? "null" : "undefined", componentName);
            }
          }
          if (typeof ctor.getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function") {
            var foundWillMountName = null;
            var foundWillReceivePropsName = null;
            var foundWillUpdateName = null;
            if (typeof instance.componentWillMount === "function" && instance.componentWillMount.__suppressDeprecationWarning !== true) {
              foundWillMountName = "componentWillMount";
            } else if (typeof instance.UNSAFE_componentWillMount === "function") {
              foundWillMountName = "UNSAFE_componentWillMount";
            }
            if (typeof instance.componentWillReceiveProps === "function" && instance.componentWillReceiveProps.__suppressDeprecationWarning !== true) {
              foundWillReceivePropsName = "componentWillReceiveProps";
            } else if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
              foundWillReceivePropsName = "UNSAFE_componentWillReceiveProps";
            }
            if (typeof instance.componentWillUpdate === "function" && instance.componentWillUpdate.__suppressDeprecationWarning !== true) {
              foundWillUpdateName = "componentWillUpdate";
            } else if (typeof instance.UNSAFE_componentWillUpdate === "function") {
              foundWillUpdateName = "UNSAFE_componentWillUpdate";
            }
            if (foundWillMountName !== null || foundWillReceivePropsName !== null || foundWillUpdateName !== null) {
              var _componentName = getComponentNameFromType(ctor) || "Component";
              var newApiName = typeof ctor.getDerivedStateFromProps === "function" ? "getDerivedStateFromProps()" : "getSnapshotBeforeUpdate()";
              if (!didWarnAboutLegacyLifecyclesAndDerivedState.has(_componentName)) {
                didWarnAboutLegacyLifecyclesAndDerivedState.add(_componentName);
                error(`Unsafe legacy lifecycles will not be called for components using new component APIs.

` + `%s uses %s but also contains the following legacy lifecycles:%s%s%s

` + `The above lifecycles should be removed. Learn more about this warning here:
` + "https://reactjs.org/link/unsafe-component-lifecycles", _componentName, newApiName, foundWillMountName !== null ? `
  ` + foundWillMountName : "", foundWillReceivePropsName !== null ? `
  ` + foundWillReceivePropsName : "", foundWillUpdateName !== null ? `
  ` + foundWillUpdateName : "");
              }
            }
          }
        }
        if (isLegacyContextConsumer) {
          cacheContext(workInProgress2, unmaskedContext, context);
        }
        return instance;
      }
      function callComponentWillMount(workInProgress2, instance) {
        var oldState = instance.state;
        if (typeof instance.componentWillMount === "function") {
          instance.componentWillMount();
        }
        if (typeof instance.UNSAFE_componentWillMount === "function") {
          instance.UNSAFE_componentWillMount();
        }
        if (oldState !== instance.state) {
          {
            error("%s.componentWillMount(): Assigning directly to this.state is " + "deprecated (except inside a component's " + "constructor). Use setState instead.", getComponentNameFromFiber(workInProgress2) || "Component");
          }
          classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
        }
      }
      function callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext) {
        var oldState = instance.state;
        if (typeof instance.componentWillReceiveProps === "function") {
          instance.componentWillReceiveProps(newProps, nextContext);
        }
        if (typeof instance.UNSAFE_componentWillReceiveProps === "function") {
          instance.UNSAFE_componentWillReceiveProps(newProps, nextContext);
        }
        if (instance.state !== oldState) {
          {
            var componentName = getComponentNameFromFiber(workInProgress2) || "Component";
            if (!didWarnAboutStateAssignmentForComponent.has(componentName)) {
              didWarnAboutStateAssignmentForComponent.add(componentName);
              error("%s.componentWillReceiveProps(): Assigning directly to " + "this.state is deprecated (except inside a component's " + "constructor). Use setState instead.", componentName);
            }
          }
          classComponentUpdater.enqueueReplaceState(instance, instance.state, null);
        }
      }
      function mountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
        {
          checkClassInstance(workInProgress2, ctor, newProps);
        }
        var instance = workInProgress2.stateNode;
        instance.props = newProps;
        instance.state = workInProgress2.memoizedState;
        instance.refs = {};
        initializeUpdateQueue(workInProgress2);
        var contextType = ctor.contextType;
        if (typeof contextType === "object" && contextType !== null) {
          instance.context = readContext(contextType);
        } else {
          var unmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
          instance.context = getMaskedContext(workInProgress2, unmaskedContext);
        }
        {
          if (instance.state === newProps) {
            var componentName = getComponentNameFromType(ctor) || "Component";
            if (!didWarnAboutDirectlyAssigningPropsToState.has(componentName)) {
              didWarnAboutDirectlyAssigningPropsToState.add(componentName);
              error("%s: It is not recommended to assign props directly to state " + "because updates to props won't be reflected in state. " + "In most cases, it is better to use props directly.", componentName);
            }
          }
          if (workInProgress2.mode & StrictLegacyMode) {
            ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, instance);
          }
          {
            ReactStrictModeWarnings.recordUnsafeLifecycleWarnings(workInProgress2, instance);
          }
        }
        instance.state = workInProgress2.memoizedState;
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        if (typeof getDerivedStateFromProps === "function") {
          applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
          instance.state = workInProgress2.memoizedState;
        }
        if (typeof ctor.getDerivedStateFromProps !== "function" && typeof instance.getSnapshotBeforeUpdate !== "function" && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
          callComponentWillMount(workInProgress2, instance);
          processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
          instance.state = workInProgress2.memoizedState;
        }
        if (typeof instance.componentDidMount === "function") {
          var fiberFlags = Update;
          {
            fiberFlags |= LayoutStatic;
          }
          if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
            fiberFlags |= MountLayoutDev;
          }
          workInProgress2.flags |= fiberFlags;
        }
      }
      function resumeMountClassInstance(workInProgress2, ctor, newProps, renderLanes2) {
        var instance = workInProgress2.stateNode;
        var oldProps = workInProgress2.memoizedProps;
        instance.props = oldProps;
        var oldContext = instance.context;
        var contextType = ctor.contextType;
        var nextContext = emptyContextObject;
        if (typeof contextType === "object" && contextType !== null) {
          nextContext = readContext(contextType);
        } else {
          var nextLegacyUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
          nextContext = getMaskedContext(workInProgress2, nextLegacyUnmaskedContext);
        }
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
        if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
          if (oldProps !== newProps || oldContext !== nextContext) {
            callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
          }
        }
        resetHasForceUpdateBeforeProcessing();
        var oldState = workInProgress2.memoizedState;
        var newState = instance.state = oldState;
        processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
        newState = workInProgress2.memoizedState;
        if (oldProps === newProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing()) {
          if (typeof instance.componentDidMount === "function") {
            var fiberFlags = Update;
            {
              fiberFlags |= LayoutStatic;
            }
            if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
              fiberFlags |= MountLayoutDev;
            }
            workInProgress2.flags |= fiberFlags;
          }
          return false;
        }
        if (typeof getDerivedStateFromProps === "function") {
          applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
          newState = workInProgress2.memoizedState;
        }
        var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext);
        if (shouldUpdate) {
          if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillMount === "function" || typeof instance.componentWillMount === "function")) {
            if (typeof instance.componentWillMount === "function") {
              instance.componentWillMount();
            }
            if (typeof instance.UNSAFE_componentWillMount === "function") {
              instance.UNSAFE_componentWillMount();
            }
          }
          if (typeof instance.componentDidMount === "function") {
            var _fiberFlags = Update;
            {
              _fiberFlags |= LayoutStatic;
            }
            if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
              _fiberFlags |= MountLayoutDev;
            }
            workInProgress2.flags |= _fiberFlags;
          }
        } else {
          if (typeof instance.componentDidMount === "function") {
            var _fiberFlags2 = Update;
            {
              _fiberFlags2 |= LayoutStatic;
            }
            if ((workInProgress2.mode & StrictEffectsMode) !== NoMode) {
              _fiberFlags2 |= MountLayoutDev;
            }
            workInProgress2.flags |= _fiberFlags2;
          }
          workInProgress2.memoizedProps = newProps;
          workInProgress2.memoizedState = newState;
        }
        instance.props = newProps;
        instance.state = newState;
        instance.context = nextContext;
        return shouldUpdate;
      }
      function updateClassInstance(current2, workInProgress2, ctor, newProps, renderLanes2) {
        var instance = workInProgress2.stateNode;
        cloneUpdateQueue(current2, workInProgress2);
        var unresolvedOldProps = workInProgress2.memoizedProps;
        var oldProps = workInProgress2.type === workInProgress2.elementType ? unresolvedOldProps : resolveDefaultProps(workInProgress2.type, unresolvedOldProps);
        instance.props = oldProps;
        var unresolvedNewProps = workInProgress2.pendingProps;
        var oldContext = instance.context;
        var contextType = ctor.contextType;
        var nextContext = emptyContextObject;
        if (typeof contextType === "object" && contextType !== null) {
          nextContext = readContext(contextType);
        } else {
          var nextUnmaskedContext = getUnmaskedContext(workInProgress2, ctor, true);
          nextContext = getMaskedContext(workInProgress2, nextUnmaskedContext);
        }
        var getDerivedStateFromProps = ctor.getDerivedStateFromProps;
        var hasNewLifecycles = typeof getDerivedStateFromProps === "function" || typeof instance.getSnapshotBeforeUpdate === "function";
        if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillReceiveProps === "function" || typeof instance.componentWillReceiveProps === "function")) {
          if (unresolvedOldProps !== unresolvedNewProps || oldContext !== nextContext) {
            callComponentWillReceiveProps(workInProgress2, instance, newProps, nextContext);
          }
        }
        resetHasForceUpdateBeforeProcessing();
        var oldState = workInProgress2.memoizedState;
        var newState = instance.state = oldState;
        processUpdateQueue(workInProgress2, newProps, instance, renderLanes2);
        newState = workInProgress2.memoizedState;
        if (unresolvedOldProps === unresolvedNewProps && oldState === newState && !hasContextChanged() && !checkHasForceUpdateAfterProcessing() && !enableLazyContextPropagation) {
          if (typeof instance.componentDidUpdate === "function") {
            if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
              workInProgress2.flags |= Update;
            }
          }
          if (typeof instance.getSnapshotBeforeUpdate === "function") {
            if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
              workInProgress2.flags |= Snapshot;
            }
          }
          return false;
        }
        if (typeof getDerivedStateFromProps === "function") {
          applyDerivedStateFromProps(workInProgress2, ctor, getDerivedStateFromProps, newProps);
          newState = workInProgress2.memoizedState;
        }
        var shouldUpdate = checkHasForceUpdateAfterProcessing() || checkShouldComponentUpdate(workInProgress2, ctor, oldProps, newProps, oldState, newState, nextContext) || enableLazyContextPropagation;
        if (shouldUpdate) {
          if (!hasNewLifecycles && (typeof instance.UNSAFE_componentWillUpdate === "function" || typeof instance.componentWillUpdate === "function")) {
            if (typeof instance.componentWillUpdate === "function") {
              instance.componentWillUpdate(newProps, newState, nextContext);
            }
            if (typeof instance.UNSAFE_componentWillUpdate === "function") {
              instance.UNSAFE_componentWillUpdate(newProps, newState, nextContext);
            }
          }
          if (typeof instance.componentDidUpdate === "function") {
            workInProgress2.flags |= Update;
          }
          if (typeof instance.getSnapshotBeforeUpdate === "function") {
            workInProgress2.flags |= Snapshot;
          }
        } else {
          if (typeof instance.componentDidUpdate === "function") {
            if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
              workInProgress2.flags |= Update;
            }
          }
          if (typeof instance.getSnapshotBeforeUpdate === "function") {
            if (unresolvedOldProps !== current2.memoizedProps || oldState !== current2.memoizedState) {
              workInProgress2.flags |= Snapshot;
            }
          }
          workInProgress2.memoizedProps = newProps;
          workInProgress2.memoizedState = newState;
        }
        instance.props = newProps;
        instance.state = newState;
        instance.context = nextContext;
        return shouldUpdate;
      }
      function createCapturedValueAtFiber(value, source) {
        return {
          value,
          source,
          stack: getStackByFiberInDevAndProd(source),
          digest: null
        };
      }
      function createCapturedValue(value, digest, stack) {
        return {
          value,
          source: null,
          stack: stack != null ? stack : null,
          digest: digest != null ? digest : null
        };
      }
      function showErrorDialog(boundary, errorInfo) {
        return true;
      }
      function logCapturedError(boundary, errorInfo) {
        try {
          var logError = showErrorDialog(boundary, errorInfo);
          if (logError === false) {
            return;
          }
          var error2 = errorInfo.value;
          if (true) {
            var source = errorInfo.source;
            var stack = errorInfo.stack;
            var componentStack = stack !== null ? stack : "";
            if (error2 != null && error2._suppressLogging) {
              if (boundary.tag === ClassComponent) {
                return;
              }
              console["error"](error2);
            }
            var componentName = source ? getComponentNameFromFiber(source) : null;
            var componentNameMessage = componentName ? "The above error occurred in the <" + componentName + "> component:" : "The above error occurred in one of your React components:";
            var errorBoundaryMessage;
            if (boundary.tag === HostRoot) {
              errorBoundaryMessage = `Consider adding an error boundary to your tree to customize error handling behavior.
` + "Visit https://reactjs.org/link/error-boundaries to learn more about error boundaries.";
            } else {
              var errorBoundaryName = getComponentNameFromFiber(boundary) || "Anonymous";
              errorBoundaryMessage = "React will try to recreate this component tree from scratch " + ("using the error boundary you provided, " + errorBoundaryName + ".");
            }
            var combinedMessage = componentNameMessage + `
` + componentStack + `

` + ("" + errorBoundaryMessage);
            console["error"](combinedMessage);
          } else {}
        } catch (e) {
          setTimeout(function() {
            throw e;
          });
        }
      }
      var PossiblyWeakMap$1 = typeof WeakMap === "function" ? WeakMap : Map;
      function createRootErrorUpdate(fiber, errorInfo, lane) {
        var update = createUpdate(NoTimestamp, lane);
        update.tag = CaptureUpdate;
        update.payload = {
          element: null
        };
        var error2 = errorInfo.value;
        update.callback = function() {
          onUncaughtError(error2);
          logCapturedError(fiber, errorInfo);
        };
        return update;
      }
      function createClassErrorUpdate(fiber, errorInfo, lane) {
        var update = createUpdate(NoTimestamp, lane);
        update.tag = CaptureUpdate;
        var getDerivedStateFromError = fiber.type.getDerivedStateFromError;
        if (typeof getDerivedStateFromError === "function") {
          var error$1 = errorInfo.value;
          update.payload = function() {
            return getDerivedStateFromError(error$1);
          };
          update.callback = function() {
            {
              markFailedErrorBoundaryForHotReloading(fiber);
            }
            logCapturedError(fiber, errorInfo);
          };
        }
        var inst = fiber.stateNode;
        if (inst !== null && typeof inst.componentDidCatch === "function") {
          update.callback = function callback() {
            {
              markFailedErrorBoundaryForHotReloading(fiber);
            }
            logCapturedError(fiber, errorInfo);
            if (typeof getDerivedStateFromError !== "function") {
              markLegacyErrorBoundaryAsFailed(this);
            }
            var error$12 = errorInfo.value;
            var stack = errorInfo.stack;
            this.componentDidCatch(error$12, {
              componentStack: stack !== null ? stack : ""
            });
            {
              if (typeof getDerivedStateFromError !== "function") {
                if (!includesSomeLane(fiber.lanes, SyncLane)) {
                  error("%s: Error boundaries should implement getDerivedStateFromError(). " + "In that method, return a state update to display an error message or fallback UI.", getComponentNameFromFiber(fiber) || "Unknown");
                }
              }
            }
          };
        }
        return update;
      }
      function attachPingListener(root2, wakeable, lanes) {
        var pingCache = root2.pingCache;
        var threadIDs;
        if (pingCache === null) {
          pingCache = root2.pingCache = new PossiblyWeakMap$1;
          threadIDs = new Set;
          pingCache.set(wakeable, threadIDs);
        } else {
          threadIDs = pingCache.get(wakeable);
          if (threadIDs === undefined) {
            threadIDs = new Set;
            pingCache.set(wakeable, threadIDs);
          }
        }
        if (!threadIDs.has(lanes)) {
          threadIDs.add(lanes);
          var ping = pingSuspendedRoot.bind(null, root2, wakeable, lanes);
          {
            if (isDevToolsPresent) {
              restorePendingUpdaters(root2, lanes);
            }
          }
          wakeable.then(ping, ping);
        }
      }
      function attachRetryListener(suspenseBoundary, root2, wakeable, lanes) {
        var wakeables = suspenseBoundary.updateQueue;
        if (wakeables === null) {
          var updateQueue = new Set;
          updateQueue.add(wakeable);
          suspenseBoundary.updateQueue = updateQueue;
        } else {
          wakeables.add(wakeable);
        }
      }
      function resetSuspendedComponent(sourceFiber, rootRenderLanes) {
        var tag = sourceFiber.tag;
        if ((sourceFiber.mode & ConcurrentMode) === NoMode && (tag === FunctionComponent || tag === ForwardRef || tag === SimpleMemoComponent)) {
          var currentSource = sourceFiber.alternate;
          if (currentSource) {
            sourceFiber.updateQueue = currentSource.updateQueue;
            sourceFiber.memoizedState = currentSource.memoizedState;
            sourceFiber.lanes = currentSource.lanes;
          } else {
            sourceFiber.updateQueue = null;
            sourceFiber.memoizedState = null;
          }
        }
      }
      function getNearestSuspenseBoundaryToCapture(returnFiber) {
        var node = returnFiber;
        do {
          if (node.tag === SuspenseComponent && shouldCaptureSuspense(node)) {
            return node;
          }
          node = node.return;
        } while (node !== null);
        return null;
      }
      function markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes) {
        if ((suspenseBoundary.mode & ConcurrentMode) === NoMode) {
          if (suspenseBoundary === returnFiber) {
            suspenseBoundary.flags |= ShouldCapture;
          } else {
            suspenseBoundary.flags |= DidCapture;
            sourceFiber.flags |= ForceUpdateForLegacySuspense;
            sourceFiber.flags &= ~(LifecycleEffectMask | Incomplete);
            if (sourceFiber.tag === ClassComponent) {
              var currentSourceFiber = sourceFiber.alternate;
              if (currentSourceFiber === null) {
                sourceFiber.tag = IncompleteClassComponent;
              } else {
                var update = createUpdate(NoTimestamp, SyncLane);
                update.tag = ForceUpdate;
                enqueueUpdate(sourceFiber, update, SyncLane);
              }
            }
            sourceFiber.lanes = mergeLanes(sourceFiber.lanes, SyncLane);
          }
          return suspenseBoundary;
        }
        suspenseBoundary.flags |= ShouldCapture;
        suspenseBoundary.lanes = rootRenderLanes;
        return suspenseBoundary;
      }
      function throwException(root2, returnFiber, sourceFiber, value, rootRenderLanes) {
        sourceFiber.flags |= Incomplete;
        {
          if (isDevToolsPresent) {
            restorePendingUpdaters(root2, rootRenderLanes);
          }
        }
        if (value !== null && typeof value === "object" && typeof value.then === "function") {
          var wakeable = value;
          resetSuspendedComponent(sourceFiber);
          {
            if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
              markDidThrowWhileHydratingDEV();
            }
          }
          var suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
          if (suspenseBoundary !== null) {
            suspenseBoundary.flags &= ~ForceClientRender;
            markSuspenseBoundaryShouldCapture(suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes);
            if (suspenseBoundary.mode & ConcurrentMode) {
              attachPingListener(root2, wakeable, rootRenderLanes);
            }
            attachRetryListener(suspenseBoundary, root2, wakeable);
            return;
          } else {
            if (!includesSyncLane(rootRenderLanes)) {
              attachPingListener(root2, wakeable, rootRenderLanes);
              renderDidSuspendDelayIfPossible();
              return;
            }
            var uncaughtSuspenseError = new Error("A component suspended while responding to synchronous input. This " + "will cause the UI to be replaced with a loading indicator. To " + "fix, updates that suspend should be wrapped " + "with startTransition.");
            value = uncaughtSuspenseError;
          }
        } else {
          if (getIsHydrating() && sourceFiber.mode & ConcurrentMode) {
            markDidThrowWhileHydratingDEV();
            var _suspenseBoundary = getNearestSuspenseBoundaryToCapture(returnFiber);
            if (_suspenseBoundary !== null) {
              if ((_suspenseBoundary.flags & ShouldCapture) === NoFlags) {
                _suspenseBoundary.flags |= ForceClientRender;
              }
              markSuspenseBoundaryShouldCapture(_suspenseBoundary, returnFiber, sourceFiber, root2, rootRenderLanes);
              queueHydrationError(createCapturedValueAtFiber(value, sourceFiber));
              return;
            }
          }
        }
        value = createCapturedValueAtFiber(value, sourceFiber);
        renderDidError(value);
        var workInProgress2 = returnFiber;
        do {
          switch (workInProgress2.tag) {
            case HostRoot: {
              var _errorInfo = value;
              workInProgress2.flags |= ShouldCapture;
              var lane = pickArbitraryLane(rootRenderLanes);
              workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
              var update = createRootErrorUpdate(workInProgress2, _errorInfo, lane);
              enqueueCapturedUpdate(workInProgress2, update);
              return;
            }
            case ClassComponent:
              var errorInfo = value;
              var ctor = workInProgress2.type;
              var instance = workInProgress2.stateNode;
              if ((workInProgress2.flags & DidCapture) === NoFlags && (typeof ctor.getDerivedStateFromError === "function" || instance !== null && typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance))) {
                workInProgress2.flags |= ShouldCapture;
                var _lane = pickArbitraryLane(rootRenderLanes);
                workInProgress2.lanes = mergeLanes(workInProgress2.lanes, _lane);
                var _update = createClassErrorUpdate(workInProgress2, errorInfo, _lane);
                enqueueCapturedUpdate(workInProgress2, _update);
                return;
              }
              break;
          }
          workInProgress2 = workInProgress2.return;
        } while (workInProgress2 !== null);
      }
      function getSuspendedCache() {
        {
          return null;
        }
      }
      var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
      var didReceiveUpdate = false;
      var didWarnAboutBadClass;
      var didWarnAboutModulePatternComponent;
      var didWarnAboutContextTypeOnFunctionComponent;
      var didWarnAboutGetDerivedStateOnFunctionComponent;
      var didWarnAboutFunctionRefs;
      var didWarnAboutReassigningProps;
      var didWarnAboutRevealOrder;
      var didWarnAboutTailOptions;
      var didWarnAboutDefaultPropsOnFunctionComponent;
      {
        didWarnAboutBadClass = {};
        didWarnAboutModulePatternComponent = {};
        didWarnAboutContextTypeOnFunctionComponent = {};
        didWarnAboutGetDerivedStateOnFunctionComponent = {};
        didWarnAboutFunctionRefs = {};
        didWarnAboutReassigningProps = false;
        didWarnAboutRevealOrder = {};
        didWarnAboutTailOptions = {};
        didWarnAboutDefaultPropsOnFunctionComponent = {};
      }
      function reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2) {
        if (current2 === null) {
          workInProgress2.child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
        } else {
          workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, nextChildren, renderLanes2);
        }
      }
      function forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2) {
        workInProgress2.child = reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
        workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
      }
      function updateForwardRef(current2, workInProgress2, Component, nextProps, renderLanes2) {
        {
          if (workInProgress2.type !== workInProgress2.elementType) {
            var innerPropTypes = Component.propTypes;
            if (innerPropTypes) {
              checkPropTypes(innerPropTypes, nextProps, "prop", getComponentNameFromType(Component));
            }
          }
        }
        var render2 = Component.render;
        var ref = workInProgress2.ref;
        var nextChildren;
        var hasId;
        prepareToReadContext(workInProgress2, renderLanes2);
        {
          markComponentRenderStarted(workInProgress2);
        }
        {
          ReactCurrentOwner$1.current = workInProgress2;
          setIsRendering(true);
          nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderLanes2);
          hasId = checkDidRenderIdHook();
          if (workInProgress2.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(true);
            try {
              nextChildren = renderWithHooks(current2, workInProgress2, render2, nextProps, ref, renderLanes2);
              hasId = checkDidRenderIdHook();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          setIsRendering(false);
        }
        {
          markComponentRenderStopped();
        }
        if (current2 !== null && !didReceiveUpdate) {
          bailoutHooks(current2, workInProgress2, renderLanes2);
          return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        }
        if (getIsHydrating() && hasId) {
          pushMaterializedTreeId(workInProgress2);
        }
        workInProgress2.flags |= PerformedWork;
        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function updateMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
        if (current2 === null) {
          var type = Component.type;
          if (isSimpleFunctionComponent(type) && Component.compare === null && Component.defaultProps === undefined) {
            var resolvedType = type;
            {
              resolvedType = resolveFunctionForHotReloading(type);
            }
            workInProgress2.tag = SimpleMemoComponent;
            workInProgress2.type = resolvedType;
            {
              validateFunctionComponentInDev(workInProgress2, type);
            }
            return updateSimpleMemoComponent(current2, workInProgress2, resolvedType, nextProps, renderLanes2);
          }
          {
            var innerPropTypes = type.propTypes;
            if (innerPropTypes) {
              checkPropTypes(innerPropTypes, nextProps, "prop", getComponentNameFromType(type));
            }
            if (Component.defaultProps !== undefined) {
              var componentName = getComponentNameFromType(type) || "Unknown";
              if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {
                error("%s: Support for defaultProps will be removed from memo components " + "in a future major release. Use JavaScript default parameters instead.", componentName);
                didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;
              }
            }
          }
          var child = createFiberFromTypeAndProps(Component.type, null, nextProps, workInProgress2, workInProgress2.mode, renderLanes2);
          child.ref = workInProgress2.ref;
          child.return = workInProgress2;
          workInProgress2.child = child;
          return child;
        }
        {
          var _type = Component.type;
          var _innerPropTypes = _type.propTypes;
          if (_innerPropTypes) {
            checkPropTypes(_innerPropTypes, nextProps, "prop", getComponentNameFromType(_type));
          }
        }
        var currentChild = current2.child;
        var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);
        if (!hasScheduledUpdateOrContext) {
          var prevProps = currentChild.memoizedProps;
          var compare = Component.compare;
          compare = compare !== null ? compare : shallowEqual;
          if (compare(prevProps, nextProps) && current2.ref === workInProgress2.ref) {
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
        }
        workInProgress2.flags |= PerformedWork;
        var newChild = createWorkInProgress(currentChild, nextProps);
        newChild.ref = workInProgress2.ref;
        newChild.return = workInProgress2;
        workInProgress2.child = newChild;
        return newChild;
      }
      function updateSimpleMemoComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
        {
          if (workInProgress2.type !== workInProgress2.elementType) {
            var outerMemoType = workInProgress2.elementType;
            if (outerMemoType.$$typeof === REACT_LAZY_TYPE) {
              var lazyComponent = outerMemoType;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                outerMemoType = init(payload);
              } catch (x) {
                outerMemoType = null;
              }
              var outerPropTypes = outerMemoType && outerMemoType.propTypes;
              if (outerPropTypes) {
                checkPropTypes(outerPropTypes, nextProps, "prop", getComponentNameFromType(outerMemoType));
              }
            }
          }
        }
        if (current2 !== null) {
          var prevProps = current2.memoizedProps;
          if (shallowEqual(prevProps, nextProps) && current2.ref === workInProgress2.ref && workInProgress2.type === current2.type) {
            didReceiveUpdate = false;
            workInProgress2.pendingProps = nextProps = prevProps;
            if (!checkScheduledUpdateOrContext(current2, renderLanes2)) {
              workInProgress2.lanes = current2.lanes;
              return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
            } else if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
              didReceiveUpdate = true;
            }
          }
        }
        return updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2);
      }
      function updateOffscreenComponent(current2, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps;
        var nextChildren = nextProps.children;
        var prevState = current2 !== null ? current2.memoizedState : null;
        if (nextProps.mode === "hidden" || enableLegacyHidden) {
          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
            var nextState = {
              baseLanes: NoLanes,
              cachePool: null,
              transitions: null
            };
            workInProgress2.memoizedState = nextState;
            pushRenderLanes(workInProgress2, renderLanes2);
          } else if (!includesSomeLane(renderLanes2, OffscreenLane)) {
            var spawnedCachePool = null;
            var nextBaseLanes;
            if (prevState !== null) {
              var prevBaseLanes = prevState.baseLanes;
              nextBaseLanes = mergeLanes(prevBaseLanes, renderLanes2);
            } else {
              nextBaseLanes = renderLanes2;
            }
            workInProgress2.lanes = workInProgress2.childLanes = laneToLanes(OffscreenLane);
            var _nextState = {
              baseLanes: nextBaseLanes,
              cachePool: spawnedCachePool,
              transitions: null
            };
            workInProgress2.memoizedState = _nextState;
            workInProgress2.updateQueue = null;
            pushRenderLanes(workInProgress2, nextBaseLanes);
            return null;
          } else {
            var _nextState2 = {
              baseLanes: NoLanes,
              cachePool: null,
              transitions: null
            };
            workInProgress2.memoizedState = _nextState2;
            var subtreeRenderLanes2 = prevState !== null ? prevState.baseLanes : renderLanes2;
            pushRenderLanes(workInProgress2, subtreeRenderLanes2);
          }
        } else {
          var _subtreeRenderLanes;
          if (prevState !== null) {
            _subtreeRenderLanes = mergeLanes(prevState.baseLanes, renderLanes2);
            workInProgress2.memoizedState = null;
          } else {
            _subtreeRenderLanes = renderLanes2;
          }
          pushRenderLanes(workInProgress2, _subtreeRenderLanes);
        }
        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function updateFragment(current2, workInProgress2, renderLanes2) {
        var nextChildren = workInProgress2.pendingProps;
        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function updateMode(current2, workInProgress2, renderLanes2) {
        var nextChildren = workInProgress2.pendingProps.children;
        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function updateProfiler(current2, workInProgress2, renderLanes2) {
        {
          workInProgress2.flags |= Update;
          {
            var stateNode = workInProgress2.stateNode;
            stateNode.effectDuration = 0;
            stateNode.passiveEffectDuration = 0;
          }
        }
        var nextProps = workInProgress2.pendingProps;
        var nextChildren = nextProps.children;
        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function markRef(current2, workInProgress2) {
        var ref = workInProgress2.ref;
        if (current2 === null && ref !== null || current2 !== null && current2.ref !== ref) {
          workInProgress2.flags |= Ref;
          {
            workInProgress2.flags |= RefStatic;
          }
        }
      }
      function updateFunctionComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
        {
          if (workInProgress2.type !== workInProgress2.elementType) {
            var innerPropTypes = Component.propTypes;
            if (innerPropTypes) {
              checkPropTypes(innerPropTypes, nextProps, "prop", getComponentNameFromType(Component));
            }
          }
        }
        var context;
        {
          var unmaskedContext = getUnmaskedContext(workInProgress2, Component, true);
          context = getMaskedContext(workInProgress2, unmaskedContext);
        }
        var nextChildren;
        var hasId;
        prepareToReadContext(workInProgress2, renderLanes2);
        {
          markComponentRenderStarted(workInProgress2);
        }
        {
          ReactCurrentOwner$1.current = workInProgress2;
          setIsRendering(true);
          nextChildren = renderWithHooks(current2, workInProgress2, Component, nextProps, context, renderLanes2);
          hasId = checkDidRenderIdHook();
          if (workInProgress2.mode & StrictLegacyMode) {
            setIsStrictModeForDevtools(true);
            try {
              nextChildren = renderWithHooks(current2, workInProgress2, Component, nextProps, context, renderLanes2);
              hasId = checkDidRenderIdHook();
            } finally {
              setIsStrictModeForDevtools(false);
            }
          }
          setIsRendering(false);
        }
        {
          markComponentRenderStopped();
        }
        if (current2 !== null && !didReceiveUpdate) {
          bailoutHooks(current2, workInProgress2, renderLanes2);
          return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        }
        if (getIsHydrating() && hasId) {
          pushMaterializedTreeId(workInProgress2);
        }
        workInProgress2.flags |= PerformedWork;
        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function updateClassComponent(current2, workInProgress2, Component, nextProps, renderLanes2) {
        {
          switch (shouldError(workInProgress2)) {
            case false: {
              var _instance = workInProgress2.stateNode;
              var ctor = workInProgress2.type;
              var tempInstance = new ctor(workInProgress2.memoizedProps, _instance.context);
              var state = tempInstance.state;
              _instance.updater.enqueueSetState(_instance, state, null);
              break;
            }
            case true: {
              workInProgress2.flags |= DidCapture;
              workInProgress2.flags |= ShouldCapture;
              var error$1 = new Error("Simulated error coming from DevTools");
              var lane = pickArbitraryLane(renderLanes2);
              workInProgress2.lanes = mergeLanes(workInProgress2.lanes, lane);
              var update = createClassErrorUpdate(workInProgress2, createCapturedValueAtFiber(error$1, workInProgress2), lane);
              enqueueCapturedUpdate(workInProgress2, update);
              break;
            }
          }
          if (workInProgress2.type !== workInProgress2.elementType) {
            var innerPropTypes = Component.propTypes;
            if (innerPropTypes) {
              checkPropTypes(innerPropTypes, nextProps, "prop", getComponentNameFromType(Component));
            }
          }
        }
        var hasContext;
        if (isContextProvider(Component)) {
          hasContext = true;
          pushContextProvider(workInProgress2);
        } else {
          hasContext = false;
        }
        prepareToReadContext(workInProgress2, renderLanes2);
        var instance = workInProgress2.stateNode;
        var shouldUpdate;
        if (instance === null) {
          resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2);
          constructClassInstance(workInProgress2, Component, nextProps);
          mountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
          shouldUpdate = true;
        } else if (current2 === null) {
          shouldUpdate = resumeMountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
        } else {
          shouldUpdate = updateClassInstance(current2, workInProgress2, Component, nextProps, renderLanes2);
        }
        var nextUnitOfWork = finishClassComponent(current2, workInProgress2, Component, shouldUpdate, hasContext, renderLanes2);
        {
          var inst = workInProgress2.stateNode;
          if (shouldUpdate && inst.props !== nextProps) {
            if (!didWarnAboutReassigningProps) {
              error("It looks like %s is reassigning its own `this.props` while rendering. " + "This is not supported and can lead to confusing bugs.", getComponentNameFromFiber(workInProgress2) || "a component");
            }
            didWarnAboutReassigningProps = true;
          }
        }
        return nextUnitOfWork;
      }
      function finishClassComponent(current2, workInProgress2, Component, shouldUpdate, hasContext, renderLanes2) {
        markRef(current2, workInProgress2);
        var didCaptureError = (workInProgress2.flags & DidCapture) !== NoFlags;
        if (!shouldUpdate && !didCaptureError) {
          if (hasContext) {
            invalidateContextProvider(workInProgress2, Component, false);
          }
          return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
        }
        var instance = workInProgress2.stateNode;
        ReactCurrentOwner$1.current = workInProgress2;
        var nextChildren;
        if (didCaptureError && typeof Component.getDerivedStateFromError !== "function") {
          nextChildren = null;
          {
            stopProfilerTimerIfRunning();
          }
        } else {
          {
            markComponentRenderStarted(workInProgress2);
          }
          {
            setIsRendering(true);
            nextChildren = instance.render();
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                instance.render();
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
            setIsRendering(false);
          }
          {
            markComponentRenderStopped();
          }
        }
        workInProgress2.flags |= PerformedWork;
        if (current2 !== null && didCaptureError) {
          forceUnmountCurrentAndReconcile(current2, workInProgress2, nextChildren, renderLanes2);
        } else {
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
        }
        workInProgress2.memoizedState = instance.state;
        if (hasContext) {
          invalidateContextProvider(workInProgress2, Component, true);
        }
        return workInProgress2.child;
      }
      function pushHostRootContext(workInProgress2) {
        var root2 = workInProgress2.stateNode;
        if (root2.pendingContext) {
          pushTopLevelContextObject(workInProgress2, root2.pendingContext, root2.pendingContext !== root2.context);
        } else if (root2.context) {
          pushTopLevelContextObject(workInProgress2, root2.context, false);
        }
        pushHostContainer(workInProgress2, root2.containerInfo);
      }
      function updateHostRoot(current2, workInProgress2, renderLanes2) {
        pushHostRootContext(workInProgress2);
        if (current2 === null) {
          throw new Error("Should have a current fiber. This is a bug in React.");
        }
        var nextProps = workInProgress2.pendingProps;
        var prevState = workInProgress2.memoizedState;
        var prevChildren = prevState.element;
        cloneUpdateQueue(current2, workInProgress2);
        processUpdateQueue(workInProgress2, nextProps, null, renderLanes2);
        var nextState = workInProgress2.memoizedState;
        var root2 = workInProgress2.stateNode;
        var nextChildren = nextState.element;
        if (prevState.isDehydrated) {
          var overrideState = {
            element: nextChildren,
            isDehydrated: false,
            cache: nextState.cache,
            pendingSuspenseBoundaries: nextState.pendingSuspenseBoundaries,
            transitions: nextState.transitions
          };
          var updateQueue = workInProgress2.updateQueue;
          updateQueue.baseState = overrideState;
          workInProgress2.memoizedState = overrideState;
          if (workInProgress2.flags & ForceClientRender) {
            var recoverableError = createCapturedValueAtFiber(new Error("There was an error while hydrating. Because the error happened outside " + "of a Suspense boundary, the entire root will switch to " + "client rendering."), workInProgress2);
            return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError);
          } else if (nextChildren !== prevChildren) {
            var _recoverableError = createCapturedValueAtFiber(new Error("This root received an early update, before anything was able " + "hydrate. Switched the entire root to client rendering."), workInProgress2);
            return mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, _recoverableError);
          } else {
            enterHydrationState(workInProgress2);
            var child = mountChildFibers(workInProgress2, null, nextChildren, renderLanes2);
            workInProgress2.child = child;
            var node = child;
            while (node) {
              node.flags = node.flags & ~Placement | Hydrating;
              node = node.sibling;
            }
          }
        } else {
          resetHydrationState();
          if (nextChildren === prevChildren) {
            return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
          }
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
        }
        return workInProgress2.child;
      }
      function mountHostRootWithoutHydrating(current2, workInProgress2, nextChildren, renderLanes2, recoverableError) {
        resetHydrationState();
        queueHydrationError(recoverableError);
        workInProgress2.flags |= ForceClientRender;
        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function updateHostComponent(current2, workInProgress2, renderLanes2) {
        pushHostContext(workInProgress2);
        if (current2 === null) {
          tryToClaimNextHydratableInstance(workInProgress2);
        }
        var type = workInProgress2.type;
        var nextProps = workInProgress2.pendingProps;
        var prevProps = current2 !== null ? current2.memoizedProps : null;
        var nextChildren = nextProps.children;
        var isDirectTextChild = shouldSetTextContent(type, nextProps);
        if (isDirectTextChild) {
          nextChildren = null;
        } else if (prevProps !== null && shouldSetTextContent(type, prevProps)) {
          workInProgress2.flags |= ContentReset;
        }
        markRef(current2, workInProgress2);
        reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
        return workInProgress2.child;
      }
      function updateHostText(current2, workInProgress2) {
        if (current2 === null) {
          tryToClaimNextHydratableInstance(workInProgress2);
        }
        return null;
      }
      function mountLazyComponent(_current, workInProgress2, elementType, renderLanes2) {
        resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
        var props = workInProgress2.pendingProps;
        var lazyComponent = elementType;
        var payload = lazyComponent._payload;
        var init = lazyComponent._init;
        var Component = init(payload);
        workInProgress2.type = Component;
        var resolvedTag = workInProgress2.tag = resolveLazyComponentTag(Component);
        var resolvedProps = resolveDefaultProps(Component, props);
        var child;
        switch (resolvedTag) {
          case FunctionComponent: {
            {
              validateFunctionComponentInDev(workInProgress2, Component);
              workInProgress2.type = Component = resolveFunctionForHotReloading(Component);
            }
            child = updateFunctionComponent(null, workInProgress2, Component, resolvedProps, renderLanes2);
            return child;
          }
          case ClassComponent: {
            {
              workInProgress2.type = Component = resolveClassForHotReloading(Component);
            }
            child = updateClassComponent(null, workInProgress2, Component, resolvedProps, renderLanes2);
            return child;
          }
          case ForwardRef: {
            {
              workInProgress2.type = Component = resolveForwardRefForHotReloading(Component);
            }
            child = updateForwardRef(null, workInProgress2, Component, resolvedProps, renderLanes2);
            return child;
          }
          case MemoComponent: {
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var outerPropTypes = Component.propTypes;
                if (outerPropTypes) {
                  checkPropTypes(outerPropTypes, resolvedProps, "prop", getComponentNameFromType(Component));
                }
              }
            }
            child = updateMemoComponent(null, workInProgress2, Component, resolveDefaultProps(Component.type, resolvedProps), renderLanes2);
            return child;
          }
        }
        var hint = "";
        {
          if (Component !== null && typeof Component === "object" && Component.$$typeof === REACT_LAZY_TYPE) {
            hint = " Did you wrap a component in React.lazy() more than once?";
          }
        }
        throw new Error("Element type is invalid. Received a promise that resolves to: " + Component + ". " + ("Lazy element type must resolve to a class or function." + hint));
      }
      function mountIncompleteClassComponent(_current, workInProgress2, Component, nextProps, renderLanes2) {
        resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
        workInProgress2.tag = ClassComponent;
        var hasContext;
        if (isContextProvider(Component)) {
          hasContext = true;
          pushContextProvider(workInProgress2);
        } else {
          hasContext = false;
        }
        prepareToReadContext(workInProgress2, renderLanes2);
        constructClassInstance(workInProgress2, Component, nextProps);
        mountClassInstance(workInProgress2, Component, nextProps, renderLanes2);
        return finishClassComponent(null, workInProgress2, Component, true, hasContext, renderLanes2);
      }
      function mountIndeterminateComponent(_current, workInProgress2, Component, renderLanes2) {
        resetSuspendedCurrentOnMountInLegacyMode(_current, workInProgress2);
        var props = workInProgress2.pendingProps;
        var context;
        {
          var unmaskedContext = getUnmaskedContext(workInProgress2, Component, false);
          context = getMaskedContext(workInProgress2, unmaskedContext);
        }
        prepareToReadContext(workInProgress2, renderLanes2);
        var value;
        var hasId;
        {
          markComponentRenderStarted(workInProgress2);
        }
        {
          if (Component.prototype && typeof Component.prototype.render === "function") {
            var componentName = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutBadClass[componentName]) {
              error("The <%s /> component appears to have a render method, but doesn't extend React.Component. " + "This is likely to cause errors. Change %s to extend React.Component instead.", componentName, componentName);
              didWarnAboutBadClass[componentName] = true;
            }
          }
          if (workInProgress2.mode & StrictLegacyMode) {
            ReactStrictModeWarnings.recordLegacyContextWarning(workInProgress2, null);
          }
          setIsRendering(true);
          ReactCurrentOwner$1.current = workInProgress2;
          value = renderWithHooks(null, workInProgress2, Component, props, context, renderLanes2);
          hasId = checkDidRenderIdHook();
          setIsRendering(false);
        }
        {
          markComponentRenderStopped();
        }
        workInProgress2.flags |= PerformedWork;
        {
          if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === undefined) {
            var _componentName = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutModulePatternComponent[_componentName]) {
              error("The <%s /> component appears to be a function component that returns a class instance. " + "Change %s to a class that extends React.Component instead. " + "If you can't use a class try assigning the prototype on the function as a workaround. " + "`%s.prototype = React.Component.prototype`. Don't use an arrow function since it " + "cannot be called with `new` by React.", _componentName, _componentName, _componentName);
              didWarnAboutModulePatternComponent[_componentName] = true;
            }
          }
        }
        if (typeof value === "object" && value !== null && typeof value.render === "function" && value.$$typeof === undefined) {
          {
            var _componentName2 = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutModulePatternComponent[_componentName2]) {
              error("The <%s /> component appears to be a function component that returns a class instance. " + "Change %s to a class that extends React.Component instead. " + "If you can't use a class try assigning the prototype on the function as a workaround. " + "`%s.prototype = React.Component.prototype`. Don't use an arrow function since it " + "cannot be called with `new` by React.", _componentName2, _componentName2, _componentName2);
              didWarnAboutModulePatternComponent[_componentName2] = true;
            }
          }
          workInProgress2.tag = ClassComponent;
          workInProgress2.memoizedState = null;
          workInProgress2.updateQueue = null;
          var hasContext = false;
          if (isContextProvider(Component)) {
            hasContext = true;
            pushContextProvider(workInProgress2);
          } else {
            hasContext = false;
          }
          workInProgress2.memoizedState = value.state !== null && value.state !== undefined ? value.state : null;
          initializeUpdateQueue(workInProgress2);
          adoptClassInstance(workInProgress2, value);
          mountClassInstance(workInProgress2, Component, props, renderLanes2);
          return finishClassComponent(null, workInProgress2, Component, true, hasContext, renderLanes2);
        } else {
          workInProgress2.tag = FunctionComponent;
          {
            if (workInProgress2.mode & StrictLegacyMode) {
              setIsStrictModeForDevtools(true);
              try {
                value = renderWithHooks(null, workInProgress2, Component, props, context, renderLanes2);
                hasId = checkDidRenderIdHook();
              } finally {
                setIsStrictModeForDevtools(false);
              }
            }
          }
          if (getIsHydrating() && hasId) {
            pushMaterializedTreeId(workInProgress2);
          }
          reconcileChildren(null, workInProgress2, value, renderLanes2);
          {
            validateFunctionComponentInDev(workInProgress2, Component);
          }
          return workInProgress2.child;
        }
      }
      function validateFunctionComponentInDev(workInProgress2, Component) {
        {
          if (Component) {
            if (Component.childContextTypes) {
              error("%s(...): childContextTypes cannot be defined on a function component.", Component.displayName || Component.name || "Component");
            }
          }
          if (workInProgress2.ref !== null) {
            var info = "";
            var ownerName = getCurrentFiberOwnerNameInDevOrNull();
            if (ownerName) {
              info += `

Check the render method of \`` + ownerName + "`.";
            }
            var warningKey = ownerName || "";
            var debugSource = workInProgress2._debugSource;
            if (debugSource) {
              warningKey = debugSource.fileName + ":" + debugSource.lineNumber;
            }
            if (!didWarnAboutFunctionRefs[warningKey]) {
              didWarnAboutFunctionRefs[warningKey] = true;
              error("Function components cannot be given refs. " + "Attempts to access this ref will fail. " + "Did you mean to use React.forwardRef()?%s", info);
            }
          }
          if (Component.defaultProps !== undefined) {
            var componentName = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutDefaultPropsOnFunctionComponent[componentName]) {
              error("%s: Support for defaultProps will be removed from function components " + "in a future major release. Use JavaScript default parameters instead.", componentName);
              didWarnAboutDefaultPropsOnFunctionComponent[componentName] = true;
            }
          }
          if (typeof Component.getDerivedStateFromProps === "function") {
            var _componentName3 = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3]) {
              error("%s: Function components do not support getDerivedStateFromProps.", _componentName3);
              didWarnAboutGetDerivedStateOnFunctionComponent[_componentName3] = true;
            }
          }
          if (typeof Component.contextType === "object" && Component.contextType !== null) {
            var _componentName4 = getComponentNameFromType(Component) || "Unknown";
            if (!didWarnAboutContextTypeOnFunctionComponent[_componentName4]) {
              error("%s: Function components do not support contextType.", _componentName4);
              didWarnAboutContextTypeOnFunctionComponent[_componentName4] = true;
            }
          }
        }
      }
      var SUSPENDED_MARKER = {
        dehydrated: null,
        treeContext: null,
        retryLane: NoLane
      };
      function mountSuspenseOffscreenState(renderLanes2) {
        return {
          baseLanes: renderLanes2,
          cachePool: getSuspendedCache(),
          transitions: null
        };
      }
      function updateSuspenseOffscreenState(prevOffscreenState, renderLanes2) {
        var cachePool = null;
        return {
          baseLanes: mergeLanes(prevOffscreenState.baseLanes, renderLanes2),
          cachePool,
          transitions: prevOffscreenState.transitions
        };
      }
      function shouldRemainOnFallback(suspenseContext, current2, workInProgress2, renderLanes2) {
        if (current2 !== null) {
          var suspenseState = current2.memoizedState;
          if (suspenseState === null) {
            return false;
          }
        }
        return hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
      }
      function getRemainingWorkInPrimaryTree(current2, renderLanes2) {
        return removeLanes(current2.childLanes, renderLanes2);
      }
      function updateSuspenseComponent(current2, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps;
        {
          if (shouldSuspend(workInProgress2)) {
            workInProgress2.flags |= DidCapture;
          }
        }
        var suspenseContext = suspenseStackCursor.current;
        var showFallback = false;
        var didSuspend = (workInProgress2.flags & DidCapture) !== NoFlags;
        if (didSuspend || shouldRemainOnFallback(suspenseContext, current2)) {
          showFallback = true;
          workInProgress2.flags &= ~DidCapture;
        } else {
          if (current2 === null || current2.memoizedState !== null) {
            {
              suspenseContext = addSubtreeSuspenseContext(suspenseContext, InvisibleParentSuspenseContext);
            }
          }
        }
        suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
        pushSuspenseContext(workInProgress2, suspenseContext);
        if (current2 === null) {
          tryToClaimNextHydratableInstance(workInProgress2);
          var suspenseState = workInProgress2.memoizedState;
          if (suspenseState !== null) {
            var dehydrated = suspenseState.dehydrated;
            if (dehydrated !== null) {
              return mountDehydratedSuspenseComponent(workInProgress2, dehydrated);
            }
          }
          var nextPrimaryChildren = nextProps.children;
          var nextFallbackChildren = nextProps.fallback;
          if (showFallback) {
            var fallbackFragment = mountSuspenseFallbackChildren(workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
            var primaryChildFragment = workInProgress2.child;
            primaryChildFragment.memoizedState = mountSuspenseOffscreenState(renderLanes2);
            workInProgress2.memoizedState = SUSPENDED_MARKER;
            return fallbackFragment;
          } else {
            return mountSuspensePrimaryChildren(workInProgress2, nextPrimaryChildren);
          }
        } else {
          var prevState = current2.memoizedState;
          if (prevState !== null) {
            var _dehydrated = prevState.dehydrated;
            if (_dehydrated !== null) {
              return updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, _dehydrated, prevState, renderLanes2);
            }
          }
          if (showFallback) {
            var _nextFallbackChildren = nextProps.fallback;
            var _nextPrimaryChildren = nextProps.children;
            var fallbackChildFragment = updateSuspenseFallbackChildren(current2, workInProgress2, _nextPrimaryChildren, _nextFallbackChildren, renderLanes2);
            var _primaryChildFragment2 = workInProgress2.child;
            var prevOffscreenState = current2.child.memoizedState;
            _primaryChildFragment2.memoizedState = prevOffscreenState === null ? mountSuspenseOffscreenState(renderLanes2) : updateSuspenseOffscreenState(prevOffscreenState, renderLanes2);
            _primaryChildFragment2.childLanes = getRemainingWorkInPrimaryTree(current2, renderLanes2);
            workInProgress2.memoizedState = SUSPENDED_MARKER;
            return fallbackChildFragment;
          } else {
            var _nextPrimaryChildren2 = nextProps.children;
            var _primaryChildFragment3 = updateSuspensePrimaryChildren(current2, workInProgress2, _nextPrimaryChildren2, renderLanes2);
            workInProgress2.memoizedState = null;
            return _primaryChildFragment3;
          }
        }
      }
      function mountSuspensePrimaryChildren(workInProgress2, primaryChildren, renderLanes2) {
        var mode = workInProgress2.mode;
        var primaryChildProps = {
          mode: "visible",
          children: primaryChildren
        };
        var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
        primaryChildFragment.return = workInProgress2;
        workInProgress2.child = primaryChildFragment;
        return primaryChildFragment;
      }
      function mountSuspenseFallbackChildren(workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
        var mode = workInProgress2.mode;
        var progressedPrimaryFragment = workInProgress2.child;
        var primaryChildProps = {
          mode: "hidden",
          children: primaryChildren
        };
        var primaryChildFragment;
        var fallbackChildFragment;
        if ((mode & ConcurrentMode) === NoMode && progressedPrimaryFragment !== null) {
          primaryChildFragment = progressedPrimaryFragment;
          primaryChildFragment.childLanes = NoLanes;
          primaryChildFragment.pendingProps = primaryChildProps;
          if (workInProgress2.mode & ProfileMode) {
            primaryChildFragment.actualDuration = 0;
            primaryChildFragment.actualStartTime = -1;
            primaryChildFragment.selfBaseDuration = 0;
            primaryChildFragment.treeBaseDuration = 0;
          }
          fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
        } else {
          primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, mode);
          fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
        }
        primaryChildFragment.return = workInProgress2;
        fallbackChildFragment.return = workInProgress2;
        primaryChildFragment.sibling = fallbackChildFragment;
        workInProgress2.child = primaryChildFragment;
        return fallbackChildFragment;
      }
      function mountWorkInProgressOffscreenFiber(offscreenProps, mode, renderLanes2) {
        return createFiberFromOffscreen(offscreenProps, mode, NoLanes, null);
      }
      function updateWorkInProgressOffscreenFiber(current2, offscreenProps) {
        return createWorkInProgress(current2, offscreenProps);
      }
      function updateSuspensePrimaryChildren(current2, workInProgress2, primaryChildren, renderLanes2) {
        var currentPrimaryChildFragment = current2.child;
        var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
        var primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, {
          mode: "visible",
          children: primaryChildren
        });
        if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
          primaryChildFragment.lanes = renderLanes2;
        }
        primaryChildFragment.return = workInProgress2;
        primaryChildFragment.sibling = null;
        if (currentFallbackChildFragment !== null) {
          var deletions = workInProgress2.deletions;
          if (deletions === null) {
            workInProgress2.deletions = [currentFallbackChildFragment];
            workInProgress2.flags |= ChildDeletion;
          } else {
            deletions.push(currentFallbackChildFragment);
          }
        }
        workInProgress2.child = primaryChildFragment;
        return primaryChildFragment;
      }
      function updateSuspenseFallbackChildren(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
        var mode = workInProgress2.mode;
        var currentPrimaryChildFragment = current2.child;
        var currentFallbackChildFragment = currentPrimaryChildFragment.sibling;
        var primaryChildProps = {
          mode: "hidden",
          children: primaryChildren
        };
        var primaryChildFragment;
        if ((mode & ConcurrentMode) === NoMode && workInProgress2.child !== currentPrimaryChildFragment) {
          var progressedPrimaryFragment = workInProgress2.child;
          primaryChildFragment = progressedPrimaryFragment;
          primaryChildFragment.childLanes = NoLanes;
          primaryChildFragment.pendingProps = primaryChildProps;
          if (workInProgress2.mode & ProfileMode) {
            primaryChildFragment.actualDuration = 0;
            primaryChildFragment.actualStartTime = -1;
            primaryChildFragment.selfBaseDuration = currentPrimaryChildFragment.selfBaseDuration;
            primaryChildFragment.treeBaseDuration = currentPrimaryChildFragment.treeBaseDuration;
          }
          workInProgress2.deletions = null;
        } else {
          primaryChildFragment = updateWorkInProgressOffscreenFiber(currentPrimaryChildFragment, primaryChildProps);
          primaryChildFragment.subtreeFlags = currentPrimaryChildFragment.subtreeFlags & StaticMask;
        }
        var fallbackChildFragment;
        if (currentFallbackChildFragment !== null) {
          fallbackChildFragment = createWorkInProgress(currentFallbackChildFragment, fallbackChildren);
        } else {
          fallbackChildFragment = createFiberFromFragment(fallbackChildren, mode, renderLanes2, null);
          fallbackChildFragment.flags |= Placement;
        }
        fallbackChildFragment.return = workInProgress2;
        primaryChildFragment.return = workInProgress2;
        primaryChildFragment.sibling = fallbackChildFragment;
        workInProgress2.child = primaryChildFragment;
        return fallbackChildFragment;
      }
      function retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, recoverableError) {
        if (recoverableError !== null) {
          queueHydrationError(recoverableError);
        }
        reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
        var nextProps = workInProgress2.pendingProps;
        var primaryChildren = nextProps.children;
        var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
        primaryChildFragment.flags |= Placement;
        workInProgress2.memoizedState = null;
        return primaryChildFragment;
      }
      function mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, primaryChildren, fallbackChildren, renderLanes2) {
        var fiberMode = workInProgress2.mode;
        var primaryChildProps = {
          mode: "visible",
          children: primaryChildren
        };
        var primaryChildFragment = mountWorkInProgressOffscreenFiber(primaryChildProps, fiberMode);
        var fallbackChildFragment = createFiberFromFragment(fallbackChildren, fiberMode, renderLanes2, null);
        fallbackChildFragment.flags |= Placement;
        primaryChildFragment.return = workInProgress2;
        fallbackChildFragment.return = workInProgress2;
        primaryChildFragment.sibling = fallbackChildFragment;
        workInProgress2.child = primaryChildFragment;
        if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
          reconcileChildFibers(workInProgress2, current2.child, null, renderLanes2);
        }
        return fallbackChildFragment;
      }
      function mountDehydratedSuspenseComponent(workInProgress2, suspenseInstance, renderLanes2) {
        if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
          {
            error("Cannot hydrate Suspense in legacy mode. Switch from " + "ReactDOM.hydrate(element, container) to " + "ReactDOMClient.hydrateRoot(container, <App />)" + ".render(element) or remove the Suspense components from " + "the server rendered components.");
          }
          workInProgress2.lanes = laneToLanes(SyncLane);
        } else if (isSuspenseInstanceFallback(suspenseInstance)) {
          workInProgress2.lanes = laneToLanes(DefaultHydrationLane);
        } else {
          workInProgress2.lanes = laneToLanes(OffscreenLane);
        }
        return null;
      }
      function updateDehydratedSuspenseComponent(current2, workInProgress2, didSuspend, nextProps, suspenseInstance, suspenseState, renderLanes2) {
        if (!didSuspend) {
          warnIfHydrating();
          if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
            return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, null);
          }
          if (isSuspenseInstanceFallback(suspenseInstance)) {
            var digest, message, stack;
            {
              var _getSuspenseInstanceF = getSuspenseInstanceFallbackErrorDetails(suspenseInstance);
              digest = _getSuspenseInstanceF.digest;
              message = _getSuspenseInstanceF.message;
              stack = _getSuspenseInstanceF.stack;
            }
            var error2;
            if (message) {
              error2 = new Error(message);
            } else {
              error2 = new Error("The server could not finish this Suspense boundary, likely " + "due to an error during server rendering. Switched to " + "client rendering.");
            }
            var capturedValue = createCapturedValue(error2, digest, stack);
            return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, capturedValue);
          }
          var hasContextChanged2 = includesSomeLane(renderLanes2, current2.childLanes);
          if (didReceiveUpdate || hasContextChanged2) {
            var root2 = getWorkInProgressRoot();
            if (root2 !== null) {
              var attemptHydrationAtLane = getBumpedLaneForHydration(root2, renderLanes2);
              if (attemptHydrationAtLane !== NoLane && attemptHydrationAtLane !== suspenseState.retryLane) {
                suspenseState.retryLane = attemptHydrationAtLane;
                var eventTime = NoTimestamp;
                enqueueConcurrentRenderForLane(current2, attemptHydrationAtLane);
                scheduleUpdateOnFiber(root2, current2, attemptHydrationAtLane, eventTime);
              }
            }
            renderDidSuspendDelayIfPossible();
            var _capturedValue = createCapturedValue(new Error("This Suspense boundary received an update before it finished " + "hydrating. This caused the boundary to switch to client rendering. " + "The usual way to fix this is to wrap the original update " + "in startTransition."));
            return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue);
          } else if (isSuspenseInstancePending(suspenseInstance)) {
            workInProgress2.flags |= DidCapture;
            workInProgress2.child = current2.child;
            var retry = retryDehydratedSuspenseBoundary.bind(null, current2);
            registerSuspenseInstanceRetry(suspenseInstance, retry);
            return null;
          } else {
            reenterHydrationStateFromDehydratedSuspenseInstance(workInProgress2, suspenseInstance, suspenseState.treeContext);
            var primaryChildren = nextProps.children;
            var primaryChildFragment = mountSuspensePrimaryChildren(workInProgress2, primaryChildren);
            primaryChildFragment.flags |= Hydrating;
            return primaryChildFragment;
          }
        } else {
          if (workInProgress2.flags & ForceClientRender) {
            workInProgress2.flags &= ~ForceClientRender;
            var _capturedValue2 = createCapturedValue(new Error("There was an error while hydrating this Suspense boundary. " + "Switched to client rendering."));
            return retrySuspenseComponentWithoutHydrating(current2, workInProgress2, renderLanes2, _capturedValue2);
          } else if (workInProgress2.memoizedState !== null) {
            workInProgress2.child = current2.child;
            workInProgress2.flags |= DidCapture;
            return null;
          } else {
            var nextPrimaryChildren = nextProps.children;
            var nextFallbackChildren = nextProps.fallback;
            var fallbackChildFragment = mountSuspenseFallbackAfterRetryWithoutHydrating(current2, workInProgress2, nextPrimaryChildren, nextFallbackChildren, renderLanes2);
            var _primaryChildFragment4 = workInProgress2.child;
            _primaryChildFragment4.memoizedState = mountSuspenseOffscreenState(renderLanes2);
            workInProgress2.memoizedState = SUSPENDED_MARKER;
            return fallbackChildFragment;
          }
        }
      }
      function scheduleSuspenseWorkOnFiber(fiber, renderLanes2, propagationRoot) {
        fiber.lanes = mergeLanes(fiber.lanes, renderLanes2);
        var alternate = fiber.alternate;
        if (alternate !== null) {
          alternate.lanes = mergeLanes(alternate.lanes, renderLanes2);
        }
        scheduleContextWorkOnParentPath(fiber.return, renderLanes2, propagationRoot);
      }
      function propagateSuspenseContextChange(workInProgress2, firstChild, renderLanes2) {
        var node = firstChild;
        while (node !== null) {
          if (node.tag === SuspenseComponent) {
            var state = node.memoizedState;
            if (state !== null) {
              scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);
            }
          } else if (node.tag === SuspenseListComponent) {
            scheduleSuspenseWorkOnFiber(node, renderLanes2, workInProgress2);
          } else if (node.child !== null) {
            node.child.return = node;
            node = node.child;
            continue;
          }
          if (node === workInProgress2) {
            return;
          }
          while (node.sibling === null) {
            if (node.return === null || node.return === workInProgress2) {
              return;
            }
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
      }
      function findLastContentRow(firstChild) {
        var row = firstChild;
        var lastContentRow = null;
        while (row !== null) {
          var currentRow = row.alternate;
          if (currentRow !== null && findFirstSuspended(currentRow) === null) {
            lastContentRow = row;
          }
          row = row.sibling;
        }
        return lastContentRow;
      }
      function validateRevealOrder(revealOrder) {
        {
          if (revealOrder !== undefined && revealOrder !== "forwards" && revealOrder !== "backwards" && revealOrder !== "together" && !didWarnAboutRevealOrder[revealOrder]) {
            didWarnAboutRevealOrder[revealOrder] = true;
            if (typeof revealOrder === "string") {
              switch (revealOrder.toLowerCase()) {
                case "together":
                case "forwards":
                case "backwards": {
                  error('"%s" is not a valid value for revealOrder on <SuspenseList />. ' + 'Use lowercase "%s" instead.', revealOrder, revealOrder.toLowerCase());
                  break;
                }
                case "forward":
                case "backward": {
                  error('"%s" is not a valid value for revealOrder on <SuspenseList />. ' + 'React uses the -s suffix in the spelling. Use "%ss" instead.', revealOrder, revealOrder.toLowerCase());
                  break;
                }
                default:
                  error('"%s" is not a supported revealOrder on <SuspenseList />. ' + 'Did you mean "together", "forwards" or "backwards"?', revealOrder);
                  break;
              }
            } else {
              error("%s is not a supported value for revealOrder on <SuspenseList />. " + 'Did you mean "together", "forwards" or "backwards"?', revealOrder);
            }
          }
        }
      }
      function validateTailOptions(tailMode, revealOrder) {
        {
          if (tailMode !== undefined && !didWarnAboutTailOptions[tailMode]) {
            if (tailMode !== "collapsed" && tailMode !== "hidden") {
              didWarnAboutTailOptions[tailMode] = true;
              error('"%s" is not a supported value for tail on <SuspenseList />. ' + 'Did you mean "collapsed" or "hidden"?', tailMode);
            } else if (revealOrder !== "forwards" && revealOrder !== "backwards") {
              didWarnAboutTailOptions[tailMode] = true;
              error('<SuspenseList tail="%s" /> is only valid if revealOrder is ' + '"forwards" or "backwards". ' + 'Did you mean to specify revealOrder="forwards"?', tailMode);
            }
          }
        }
      }
      function validateSuspenseListNestedChild(childSlot, index2) {
        {
          var isAnArray = isArray(childSlot);
          var isIterable = !isAnArray && typeof getIteratorFn(childSlot) === "function";
          if (isAnArray || isIterable) {
            var type = isAnArray ? "array" : "iterable";
            error("A nested %s was passed to row #%s in <SuspenseList />. Wrap it in " + "an additional SuspenseList to configure its revealOrder: " + "<SuspenseList revealOrder=...> ... " + "<SuspenseList revealOrder=...>{%s}</SuspenseList> ... " + "</SuspenseList>", type, index2, type);
            return false;
          }
        }
        return true;
      }
      function validateSuspenseListChildren(children, revealOrder) {
        {
          if ((revealOrder === "forwards" || revealOrder === "backwards") && children !== undefined && children !== null && children !== false) {
            if (isArray(children)) {
              for (var i = 0;i < children.length; i++) {
                if (!validateSuspenseListNestedChild(children[i], i)) {
                  return;
                }
              }
            } else {
              var iteratorFn = getIteratorFn(children);
              if (typeof iteratorFn === "function") {
                var childrenIterator = iteratorFn.call(children);
                if (childrenIterator) {
                  var step = childrenIterator.next();
                  var _i = 0;
                  for (;!step.done; step = childrenIterator.next()) {
                    if (!validateSuspenseListNestedChild(step.value, _i)) {
                      return;
                    }
                    _i++;
                  }
                }
              } else {
                error('A single row was passed to a <SuspenseList revealOrder="%s" />. ' + "This is not useful since it needs multiple rows. " + "Did you mean to pass multiple children or an array?", revealOrder);
              }
            }
          }
        }
      }
      function initSuspenseListRenderState(workInProgress2, isBackwards, tail, lastContentRow, tailMode) {
        var renderState = workInProgress2.memoizedState;
        if (renderState === null) {
          workInProgress2.memoizedState = {
            isBackwards,
            rendering: null,
            renderingStartTime: 0,
            last: lastContentRow,
            tail,
            tailMode
          };
        } else {
          renderState.isBackwards = isBackwards;
          renderState.rendering = null;
          renderState.renderingStartTime = 0;
          renderState.last = lastContentRow;
          renderState.tail = tail;
          renderState.tailMode = tailMode;
        }
      }
      function updateSuspenseListComponent(current2, workInProgress2, renderLanes2) {
        var nextProps = workInProgress2.pendingProps;
        var revealOrder = nextProps.revealOrder;
        var tailMode = nextProps.tail;
        var newChildren = nextProps.children;
        validateRevealOrder(revealOrder);
        validateTailOptions(tailMode, revealOrder);
        validateSuspenseListChildren(newChildren, revealOrder);
        reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
        var suspenseContext = suspenseStackCursor.current;
        var shouldForceFallback = hasSuspenseContext(suspenseContext, ForceSuspenseFallback);
        if (shouldForceFallback) {
          suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
          workInProgress2.flags |= DidCapture;
        } else {
          var didSuspendBefore = current2 !== null && (current2.flags & DidCapture) !== NoFlags;
          if (didSuspendBefore) {
            propagateSuspenseContextChange(workInProgress2, workInProgress2.child, renderLanes2);
          }
          suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
        }
        pushSuspenseContext(workInProgress2, suspenseContext);
        if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
          workInProgress2.memoizedState = null;
        } else {
          switch (revealOrder) {
            case "forwards": {
              var lastContentRow = findLastContentRow(workInProgress2.child);
              var tail;
              if (lastContentRow === null) {
                tail = workInProgress2.child;
                workInProgress2.child = null;
              } else {
                tail = lastContentRow.sibling;
                lastContentRow.sibling = null;
              }
              initSuspenseListRenderState(workInProgress2, false, tail, lastContentRow, tailMode);
              break;
            }
            case "backwards": {
              var _tail = null;
              var row = workInProgress2.child;
              workInProgress2.child = null;
              while (row !== null) {
                var currentRow = row.alternate;
                if (currentRow !== null && findFirstSuspended(currentRow) === null) {
                  workInProgress2.child = row;
                  break;
                }
                var nextRow = row.sibling;
                row.sibling = _tail;
                _tail = row;
                row = nextRow;
              }
              initSuspenseListRenderState(workInProgress2, true, _tail, null, tailMode);
              break;
            }
            case "together": {
              initSuspenseListRenderState(workInProgress2, false, null, null, undefined);
              break;
            }
            default: {
              workInProgress2.memoizedState = null;
            }
          }
        }
        return workInProgress2.child;
      }
      function updatePortalComponent(current2, workInProgress2, renderLanes2) {
        pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
        var nextChildren = workInProgress2.pendingProps;
        if (current2 === null) {
          workInProgress2.child = reconcileChildFibers(workInProgress2, null, nextChildren, renderLanes2);
        } else {
          reconcileChildren(current2, workInProgress2, nextChildren, renderLanes2);
        }
        return workInProgress2.child;
      }
      var hasWarnedAboutUsingNoValuePropOnContextProvider = false;
      function updateContextProvider(current2, workInProgress2, renderLanes2) {
        var providerType = workInProgress2.type;
        var context = providerType._context;
        var newProps = workInProgress2.pendingProps;
        var oldProps = workInProgress2.memoizedProps;
        var newValue = newProps.value;
        {
          if (!("value" in newProps)) {
            if (!hasWarnedAboutUsingNoValuePropOnContextProvider) {
              hasWarnedAboutUsingNoValuePropOnContextProvider = true;
              error("The `value` prop is required for the `<Context.Provider>`. Did you misspell it or forget to pass it?");
            }
          }
          var providerPropTypes = workInProgress2.type.propTypes;
          if (providerPropTypes) {
            checkPropTypes(providerPropTypes, newProps, "prop", "Context.Provider");
          }
        }
        pushProvider(workInProgress2, context, newValue);
        {
          if (oldProps !== null) {
            var oldValue = oldProps.value;
            if (objectIs(oldValue, newValue)) {
              if (oldProps.children === newProps.children && !hasContextChanged()) {
                return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
              }
            } else {
              propagateContextChange(workInProgress2, context, renderLanes2);
            }
          }
        }
        var newChildren = newProps.children;
        reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
        return workInProgress2.child;
      }
      var hasWarnedAboutUsingContextAsConsumer = false;
      function updateContextConsumer(current2, workInProgress2, renderLanes2) {
        var context = workInProgress2.type;
        {
          if (context._context === undefined) {
            if (context !== context.Consumer) {
              if (!hasWarnedAboutUsingContextAsConsumer) {
                hasWarnedAboutUsingContextAsConsumer = true;
                error("Rendering <Context> directly is not supported and will be removed in " + "a future major release. Did you mean to render <Context.Consumer> instead?");
              }
            }
          } else {
            context = context._context;
          }
        }
        var newProps = workInProgress2.pendingProps;
        var render2 = newProps.children;
        {
          if (typeof render2 !== "function") {
            error("A context consumer was rendered with multiple children, or a child " + "that isn't a function. A context consumer expects a single child " + "that is a function. If you did pass a function, make sure there " + "is no trailing or leading whitespace around it.");
          }
        }
        prepareToReadContext(workInProgress2, renderLanes2);
        var newValue = readContext(context);
        {
          markComponentRenderStarted(workInProgress2);
        }
        var newChildren;
        {
          ReactCurrentOwner$1.current = workInProgress2;
          setIsRendering(true);
          newChildren = render2(newValue);
          setIsRendering(false);
        }
        {
          markComponentRenderStopped();
        }
        workInProgress2.flags |= PerformedWork;
        reconcileChildren(current2, workInProgress2, newChildren, renderLanes2);
        return workInProgress2.child;
      }
      function markWorkInProgressReceivedUpdate() {
        didReceiveUpdate = true;
      }
      function resetSuspendedCurrentOnMountInLegacyMode(current2, workInProgress2) {
        if ((workInProgress2.mode & ConcurrentMode) === NoMode) {
          if (current2 !== null) {
            current2.alternate = null;
            workInProgress2.alternate = null;
            workInProgress2.flags |= Placement;
          }
        }
      }
      function bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2) {
        if (current2 !== null) {
          workInProgress2.dependencies = current2.dependencies;
        }
        {
          stopProfilerTimerIfRunning();
        }
        markSkippedUpdateLanes(workInProgress2.lanes);
        if (!includesSomeLane(renderLanes2, workInProgress2.childLanes)) {
          {
            return null;
          }
        }
        cloneChildFibers(current2, workInProgress2);
        return workInProgress2.child;
      }
      function remountFiber(current2, oldWorkInProgress, newWorkInProgress) {
        {
          var returnFiber = oldWorkInProgress.return;
          if (returnFiber === null) {
            throw new Error("Cannot swap the root fiber.");
          }
          current2.alternate = null;
          oldWorkInProgress.alternate = null;
          newWorkInProgress.index = oldWorkInProgress.index;
          newWorkInProgress.sibling = oldWorkInProgress.sibling;
          newWorkInProgress.return = oldWorkInProgress.return;
          newWorkInProgress.ref = oldWorkInProgress.ref;
          if (oldWorkInProgress === returnFiber.child) {
            returnFiber.child = newWorkInProgress;
          } else {
            var prevSibling = returnFiber.child;
            if (prevSibling === null) {
              throw new Error("Expected parent to have a child.");
            }
            while (prevSibling.sibling !== oldWorkInProgress) {
              prevSibling = prevSibling.sibling;
              if (prevSibling === null) {
                throw new Error("Expected to find the previous sibling.");
              }
            }
            prevSibling.sibling = newWorkInProgress;
          }
          var deletions = returnFiber.deletions;
          if (deletions === null) {
            returnFiber.deletions = [current2];
            returnFiber.flags |= ChildDeletion;
          } else {
            deletions.push(current2);
          }
          newWorkInProgress.flags |= Placement;
          return newWorkInProgress;
        }
      }
      function checkScheduledUpdateOrContext(current2, renderLanes2) {
        var updateLanes = current2.lanes;
        if (includesSomeLane(updateLanes, renderLanes2)) {
          return true;
        }
        return false;
      }
      function attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2) {
        switch (workInProgress2.tag) {
          case HostRoot:
            pushHostRootContext(workInProgress2);
            var root2 = workInProgress2.stateNode;
            resetHydrationState();
            break;
          case HostComponent:
            pushHostContext(workInProgress2);
            break;
          case ClassComponent: {
            var Component = workInProgress2.type;
            if (isContextProvider(Component)) {
              pushContextProvider(workInProgress2);
            }
            break;
          }
          case HostPortal:
            pushHostContainer(workInProgress2, workInProgress2.stateNode.containerInfo);
            break;
          case ContextProvider: {
            var newValue = workInProgress2.memoizedProps.value;
            var context = workInProgress2.type._context;
            pushProvider(workInProgress2, context, newValue);
            break;
          }
          case Profiler:
            {
              var hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
              if (hasChildWork) {
                workInProgress2.flags |= Update;
              }
              {
                var stateNode = workInProgress2.stateNode;
                stateNode.effectDuration = 0;
                stateNode.passiveEffectDuration = 0;
              }
            }
            break;
          case SuspenseComponent: {
            var state = workInProgress2.memoizedState;
            if (state !== null) {
              if (state.dehydrated !== null) {
                pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                workInProgress2.flags |= DidCapture;
                return null;
              }
              var primaryChildFragment = workInProgress2.child;
              var primaryChildLanes = primaryChildFragment.childLanes;
              if (includesSomeLane(renderLanes2, primaryChildLanes)) {
                return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
              } else {
                pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
                var child = bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
                if (child !== null) {
                  return child.sibling;
                } else {
                  return null;
                }
              }
            } else {
              pushSuspenseContext(workInProgress2, setDefaultShallowSuspenseContext(suspenseStackCursor.current));
            }
            break;
          }
          case SuspenseListComponent: {
            var didSuspendBefore = (current2.flags & DidCapture) !== NoFlags;
            var _hasChildWork = includesSomeLane(renderLanes2, workInProgress2.childLanes);
            if (didSuspendBefore) {
              if (_hasChildWork) {
                return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
              }
              workInProgress2.flags |= DidCapture;
            }
            var renderState = workInProgress2.memoizedState;
            if (renderState !== null) {
              renderState.rendering = null;
              renderState.tail = null;
              renderState.lastEffect = null;
            }
            pushSuspenseContext(workInProgress2, suspenseStackCursor.current);
            if (_hasChildWork) {
              break;
            } else {
              return null;
            }
          }
          case OffscreenComponent:
          case LegacyHiddenComponent: {
            workInProgress2.lanes = NoLanes;
            return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
          }
        }
        return bailoutOnAlreadyFinishedWork(current2, workInProgress2, renderLanes2);
      }
      function beginWork(current2, workInProgress2, renderLanes2) {
        {
          if (workInProgress2._debugNeedsRemount && current2 !== null) {
            return remountFiber(current2, workInProgress2, createFiberFromTypeAndProps(workInProgress2.type, workInProgress2.key, workInProgress2.pendingProps, workInProgress2._debugOwner || null, workInProgress2.mode, workInProgress2.lanes));
          }
        }
        if (current2 !== null) {
          var oldProps = current2.memoizedProps;
          var newProps = workInProgress2.pendingProps;
          if (oldProps !== newProps || hasContextChanged() || workInProgress2.type !== current2.type) {
            didReceiveUpdate = true;
          } else {
            var hasScheduledUpdateOrContext = checkScheduledUpdateOrContext(current2, renderLanes2);
            if (!hasScheduledUpdateOrContext && (workInProgress2.flags & DidCapture) === NoFlags) {
              didReceiveUpdate = false;
              return attemptEarlyBailoutIfNoScheduledUpdate(current2, workInProgress2, renderLanes2);
            }
            if ((current2.flags & ForceUpdateForLegacySuspense) !== NoFlags) {
              didReceiveUpdate = true;
            } else {
              didReceiveUpdate = false;
            }
          }
        } else {
          didReceiveUpdate = false;
          if (getIsHydrating() && isForkedChild(workInProgress2)) {
            var slotIndex = workInProgress2.index;
            var numberOfForks = getForksAtLevel();
            pushTreeId(workInProgress2, numberOfForks, slotIndex);
          }
        }
        workInProgress2.lanes = NoLanes;
        switch (workInProgress2.tag) {
          case IndeterminateComponent: {
            return mountIndeterminateComponent(current2, workInProgress2, workInProgress2.type, renderLanes2);
          }
          case LazyComponent: {
            var elementType = workInProgress2.elementType;
            return mountLazyComponent(current2, workInProgress2, elementType, renderLanes2);
          }
          case FunctionComponent: {
            var Component = workInProgress2.type;
            var unresolvedProps = workInProgress2.pendingProps;
            var resolvedProps = workInProgress2.elementType === Component ? unresolvedProps : resolveDefaultProps(Component, unresolvedProps);
            return updateFunctionComponent(current2, workInProgress2, Component, resolvedProps, renderLanes2);
          }
          case ClassComponent: {
            var _Component = workInProgress2.type;
            var _unresolvedProps = workInProgress2.pendingProps;
            var _resolvedProps = workInProgress2.elementType === _Component ? _unresolvedProps : resolveDefaultProps(_Component, _unresolvedProps);
            return updateClassComponent(current2, workInProgress2, _Component, _resolvedProps, renderLanes2);
          }
          case HostRoot:
            return updateHostRoot(current2, workInProgress2, renderLanes2);
          case HostComponent:
            return updateHostComponent(current2, workInProgress2, renderLanes2);
          case HostText:
            return updateHostText(current2, workInProgress2);
          case SuspenseComponent:
            return updateSuspenseComponent(current2, workInProgress2, renderLanes2);
          case HostPortal:
            return updatePortalComponent(current2, workInProgress2, renderLanes2);
          case ForwardRef: {
            var type = workInProgress2.type;
            var _unresolvedProps2 = workInProgress2.pendingProps;
            var _resolvedProps2 = workInProgress2.elementType === type ? _unresolvedProps2 : resolveDefaultProps(type, _unresolvedProps2);
            return updateForwardRef(current2, workInProgress2, type, _resolvedProps2, renderLanes2);
          }
          case Fragment:
            return updateFragment(current2, workInProgress2, renderLanes2);
          case Mode:
            return updateMode(current2, workInProgress2, renderLanes2);
          case Profiler:
            return updateProfiler(current2, workInProgress2, renderLanes2);
          case ContextProvider:
            return updateContextProvider(current2, workInProgress2, renderLanes2);
          case ContextConsumer:
            return updateContextConsumer(current2, workInProgress2, renderLanes2);
          case MemoComponent: {
            var _type2 = workInProgress2.type;
            var _unresolvedProps3 = workInProgress2.pendingProps;
            var _resolvedProps3 = resolveDefaultProps(_type2, _unresolvedProps3);
            {
              if (workInProgress2.type !== workInProgress2.elementType) {
                var outerPropTypes = _type2.propTypes;
                if (outerPropTypes) {
                  checkPropTypes(outerPropTypes, _resolvedProps3, "prop", getComponentNameFromType(_type2));
                }
              }
            }
            _resolvedProps3 = resolveDefaultProps(_type2.type, _resolvedProps3);
            return updateMemoComponent(current2, workInProgress2, _type2, _resolvedProps3, renderLanes2);
          }
          case SimpleMemoComponent: {
            return updateSimpleMemoComponent(current2, workInProgress2, workInProgress2.type, workInProgress2.pendingProps, renderLanes2);
          }
          case IncompleteClassComponent: {
            var _Component2 = workInProgress2.type;
            var _unresolvedProps4 = workInProgress2.pendingProps;
            var _resolvedProps4 = workInProgress2.elementType === _Component2 ? _unresolvedProps4 : resolveDefaultProps(_Component2, _unresolvedProps4);
            return mountIncompleteClassComponent(current2, workInProgress2, _Component2, _resolvedProps4, renderLanes2);
          }
          case SuspenseListComponent: {
            return updateSuspenseListComponent(current2, workInProgress2, renderLanes2);
          }
          case ScopeComponent: {
            break;
          }
          case OffscreenComponent: {
            return updateOffscreenComponent(current2, workInProgress2, renderLanes2);
          }
        }
        throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in " + "React. Please file an issue.");
      }
      function markUpdate(workInProgress2) {
        workInProgress2.flags |= Update;
      }
      function markRef$1(workInProgress2) {
        workInProgress2.flags |= Ref;
        {
          workInProgress2.flags |= RefStatic;
        }
      }
      var appendAllChildren;
      var updateHostContainer;
      var updateHostComponent$1;
      var updateHostText$1;
      {
        appendAllChildren = function(parent, workInProgress2, needsVisibilityToggle, isHidden) {
          var node = workInProgress2.child;
          while (node !== null) {
            if (node.tag === HostComponent || node.tag === HostText) {
              appendInitialChild(parent, node.stateNode);
            } else if (node.tag === HostPortal)
              ;
            else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }
            if (node === workInProgress2) {
              return;
            }
            while (node.sibling === null) {
              if (node.return === null || node.return === workInProgress2) {
                return;
              }
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
        };
        updateHostContainer = function(current2, workInProgress2) {};
        updateHostComponent$1 = function(current2, workInProgress2, type, newProps, rootContainerInstance) {
          var oldProps = current2.memoizedProps;
          if (oldProps === newProps) {
            return;
          }
          var instance = workInProgress2.stateNode;
          var currentHostContext = getHostContext();
          var updatePayload = prepareUpdate(instance, type, oldProps, newProps, rootContainerInstance, currentHostContext);
          workInProgress2.updateQueue = updatePayload;
          if (updatePayload) {
            markUpdate(workInProgress2);
          }
        };
        updateHostText$1 = function(current2, workInProgress2, oldText, newText) {
          if (oldText !== newText) {
            markUpdate(workInProgress2);
          }
        };
      }
      function cutOffTailIfNeeded(renderState, hasRenderedATailFallback) {
        if (getIsHydrating()) {
          return;
        }
        switch (renderState.tailMode) {
          case "hidden": {
            var tailNode = renderState.tail;
            var lastTailNode = null;
            while (tailNode !== null) {
              if (tailNode.alternate !== null) {
                lastTailNode = tailNode;
              }
              tailNode = tailNode.sibling;
            }
            if (lastTailNode === null) {
              renderState.tail = null;
            } else {
              lastTailNode.sibling = null;
            }
            break;
          }
          case "collapsed": {
            var _tailNode = renderState.tail;
            var _lastTailNode = null;
            while (_tailNode !== null) {
              if (_tailNode.alternate !== null) {
                _lastTailNode = _tailNode;
              }
              _tailNode = _tailNode.sibling;
            }
            if (_lastTailNode === null) {
              if (!hasRenderedATailFallback && renderState.tail !== null) {
                renderState.tail.sibling = null;
              } else {
                renderState.tail = null;
              }
            } else {
              _lastTailNode.sibling = null;
            }
            break;
          }
        }
      }
      function bubbleProperties(completedWork) {
        var didBailout = completedWork.alternate !== null && completedWork.alternate.child === completedWork.child;
        var newChildLanes = NoLanes;
        var subtreeFlags = NoFlags;
        if (!didBailout) {
          if ((completedWork.mode & ProfileMode) !== NoMode) {
            var actualDuration = completedWork.actualDuration;
            var treeBaseDuration = completedWork.selfBaseDuration;
            var child = completedWork.child;
            while (child !== null) {
              newChildLanes = mergeLanes(newChildLanes, mergeLanes(child.lanes, child.childLanes));
              subtreeFlags |= child.subtreeFlags;
              subtreeFlags |= child.flags;
              actualDuration += child.actualDuration;
              treeBaseDuration += child.treeBaseDuration;
              child = child.sibling;
            }
            completedWork.actualDuration = actualDuration;
            completedWork.treeBaseDuration = treeBaseDuration;
          } else {
            var _child = completedWork.child;
            while (_child !== null) {
              newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child.lanes, _child.childLanes));
              subtreeFlags |= _child.subtreeFlags;
              subtreeFlags |= _child.flags;
              _child.return = completedWork;
              _child = _child.sibling;
            }
          }
          completedWork.subtreeFlags |= subtreeFlags;
        } else {
          if ((completedWork.mode & ProfileMode) !== NoMode) {
            var _treeBaseDuration = completedWork.selfBaseDuration;
            var _child2 = completedWork.child;
            while (_child2 !== null) {
              newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child2.lanes, _child2.childLanes));
              subtreeFlags |= _child2.subtreeFlags & StaticMask;
              subtreeFlags |= _child2.flags & StaticMask;
              _treeBaseDuration += _child2.treeBaseDuration;
              _child2 = _child2.sibling;
            }
            completedWork.treeBaseDuration = _treeBaseDuration;
          } else {
            var _child3 = completedWork.child;
            while (_child3 !== null) {
              newChildLanes = mergeLanes(newChildLanes, mergeLanes(_child3.lanes, _child3.childLanes));
              subtreeFlags |= _child3.subtreeFlags & StaticMask;
              subtreeFlags |= _child3.flags & StaticMask;
              _child3.return = completedWork;
              _child3 = _child3.sibling;
            }
          }
          completedWork.subtreeFlags |= subtreeFlags;
        }
        completedWork.childLanes = newChildLanes;
        return didBailout;
      }
      function completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState) {
        if (hasUnhydratedTailNodes() && (workInProgress2.mode & ConcurrentMode) !== NoMode && (workInProgress2.flags & DidCapture) === NoFlags) {
          warnIfUnhydratedTailNodes(workInProgress2);
          resetHydrationState();
          workInProgress2.flags |= ForceClientRender | Incomplete | ShouldCapture;
          return false;
        }
        var wasHydrated = popHydrationState(workInProgress2);
        if (nextState !== null && nextState.dehydrated !== null) {
          if (current2 === null) {
            if (!wasHydrated) {
              throw new Error("A dehydrated suspense component was completed without a hydrated node. " + "This is probably a bug in React.");
            }
            prepareToHydrateHostSuspenseInstance(workInProgress2);
            bubbleProperties(workInProgress2);
            {
              if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                var isTimedOutSuspense = nextState !== null;
                if (isTimedOutSuspense) {
                  var primaryChildFragment = workInProgress2.child;
                  if (primaryChildFragment !== null) {
                    workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                  }
                }
              }
            }
            return false;
          } else {
            resetHydrationState();
            if ((workInProgress2.flags & DidCapture) === NoFlags) {
              workInProgress2.memoizedState = null;
            }
            workInProgress2.flags |= Update;
            bubbleProperties(workInProgress2);
            {
              if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                var _isTimedOutSuspense = nextState !== null;
                if (_isTimedOutSuspense) {
                  var _primaryChildFragment = workInProgress2.child;
                  if (_primaryChildFragment !== null) {
                    workInProgress2.treeBaseDuration -= _primaryChildFragment.treeBaseDuration;
                  }
                }
              }
            }
            return false;
          }
        } else {
          upgradeHydrationErrorsToRecoverable();
          return true;
        }
      }
      function completeWork(current2, workInProgress2, renderLanes2) {
        var newProps = workInProgress2.pendingProps;
        popTreeContext(workInProgress2);
        switch (workInProgress2.tag) {
          case IndeterminateComponent:
          case LazyComponent:
          case SimpleMemoComponent:
          case FunctionComponent:
          case ForwardRef:
          case Fragment:
          case Mode:
          case Profiler:
          case ContextConsumer:
          case MemoComponent:
            bubbleProperties(workInProgress2);
            return null;
          case ClassComponent: {
            var Component = workInProgress2.type;
            if (isContextProvider(Component)) {
              popContext(workInProgress2);
            }
            bubbleProperties(workInProgress2);
            return null;
          }
          case HostRoot: {
            var fiberRoot = workInProgress2.stateNode;
            popHostContainer(workInProgress2);
            popTopLevelContextObject(workInProgress2);
            resetWorkInProgressVersions();
            if (fiberRoot.pendingContext) {
              fiberRoot.context = fiberRoot.pendingContext;
              fiberRoot.pendingContext = null;
            }
            if (current2 === null || current2.child === null) {
              var wasHydrated = popHydrationState(workInProgress2);
              if (wasHydrated) {
                markUpdate(workInProgress2);
              } else {
                if (current2 !== null) {
                  var prevState = current2.memoizedState;
                  if (!prevState.isDehydrated || (workInProgress2.flags & ForceClientRender) !== NoFlags) {
                    workInProgress2.flags |= Snapshot;
                    upgradeHydrationErrorsToRecoverable();
                  }
                }
              }
            }
            updateHostContainer(current2, workInProgress2);
            bubbleProperties(workInProgress2);
            return null;
          }
          case HostComponent: {
            popHostContext(workInProgress2);
            var rootContainerInstance = getRootHostContainer();
            var type = workInProgress2.type;
            if (current2 !== null && workInProgress2.stateNode != null) {
              updateHostComponent$1(current2, workInProgress2, type, newProps, rootContainerInstance);
              if (current2.ref !== workInProgress2.ref) {
                markRef$1(workInProgress2);
              }
            } else {
              if (!newProps) {
                if (workInProgress2.stateNode === null) {
                  throw new Error("We must have new props for new mounts. This error is likely " + "caused by a bug in React. Please file an issue.");
                }
                bubbleProperties(workInProgress2);
                return null;
              }
              var currentHostContext = getHostContext();
              var _wasHydrated = popHydrationState(workInProgress2);
              if (_wasHydrated) {
                if (prepareToHydrateHostInstance(workInProgress2, rootContainerInstance, currentHostContext)) {
                  markUpdate(workInProgress2);
                }
              } else {
                var instance = createInstance(type, newProps, rootContainerInstance, currentHostContext, workInProgress2);
                appendAllChildren(instance, workInProgress2, false, false);
                workInProgress2.stateNode = instance;
                if (finalizeInitialChildren(instance, type, newProps, rootContainerInstance)) {
                  markUpdate(workInProgress2);
                }
              }
              if (workInProgress2.ref !== null) {
                markRef$1(workInProgress2);
              }
            }
            bubbleProperties(workInProgress2);
            return null;
          }
          case HostText: {
            var newText = newProps;
            if (current2 && workInProgress2.stateNode != null) {
              var oldText = current2.memoizedProps;
              updateHostText$1(current2, workInProgress2, oldText, newText);
            } else {
              if (typeof newText !== "string") {
                if (workInProgress2.stateNode === null) {
                  throw new Error("We must have new props for new mounts. This error is likely " + "caused by a bug in React. Please file an issue.");
                }
              }
              var _rootContainerInstance = getRootHostContainer();
              var _currentHostContext = getHostContext();
              var _wasHydrated2 = popHydrationState(workInProgress2);
              if (_wasHydrated2) {
                if (prepareToHydrateHostTextInstance(workInProgress2)) {
                  markUpdate(workInProgress2);
                }
              } else {
                workInProgress2.stateNode = createTextInstance(newText, _rootContainerInstance, _currentHostContext, workInProgress2);
              }
            }
            bubbleProperties(workInProgress2);
            return null;
          }
          case SuspenseComponent: {
            popSuspenseContext(workInProgress2);
            var nextState = workInProgress2.memoizedState;
            if (current2 === null || current2.memoizedState !== null && current2.memoizedState.dehydrated !== null) {
              var fallthroughToNormalSuspensePath = completeDehydratedSuspenseBoundary(current2, workInProgress2, nextState);
              if (!fallthroughToNormalSuspensePath) {
                if (workInProgress2.flags & ShouldCapture) {
                  return workInProgress2;
                } else {
                  return null;
                }
              }
            }
            if ((workInProgress2.flags & DidCapture) !== NoFlags) {
              workInProgress2.lanes = renderLanes2;
              if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                transferActualDuration(workInProgress2);
              }
              return workInProgress2;
            }
            var nextDidTimeout = nextState !== null;
            var prevDidTimeout = current2 !== null && current2.memoizedState !== null;
            if (nextDidTimeout !== prevDidTimeout) {
              if (nextDidTimeout) {
                var _offscreenFiber2 = workInProgress2.child;
                _offscreenFiber2.flags |= Visibility;
                if ((workInProgress2.mode & ConcurrentMode) !== NoMode) {
                  var hasInvisibleChildContext = current2 === null && (workInProgress2.memoizedProps.unstable_avoidThisFallback !== true || !enableSuspenseAvoidThisFallback);
                  if (hasInvisibleChildContext || hasSuspenseContext(suspenseStackCursor.current, InvisibleParentSuspenseContext)) {
                    renderDidSuspend();
                  } else {
                    renderDidSuspendDelayIfPossible();
                  }
                }
              }
            }
            var wakeables = workInProgress2.updateQueue;
            if (wakeables !== null) {
              workInProgress2.flags |= Update;
            }
            bubbleProperties(workInProgress2);
            {
              if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                if (nextDidTimeout) {
                  var primaryChildFragment = workInProgress2.child;
                  if (primaryChildFragment !== null) {
                    workInProgress2.treeBaseDuration -= primaryChildFragment.treeBaseDuration;
                  }
                }
              }
            }
            return null;
          }
          case HostPortal:
            popHostContainer(workInProgress2);
            updateHostContainer(current2, workInProgress2);
            if (current2 === null) {
              preparePortalMount(workInProgress2.stateNode.containerInfo);
            }
            bubbleProperties(workInProgress2);
            return null;
          case ContextProvider:
            var context = workInProgress2.type._context;
            popProvider(context, workInProgress2);
            bubbleProperties(workInProgress2);
            return null;
          case IncompleteClassComponent: {
            var _Component = workInProgress2.type;
            if (isContextProvider(_Component)) {
              popContext(workInProgress2);
            }
            bubbleProperties(workInProgress2);
            return null;
          }
          case SuspenseListComponent: {
            popSuspenseContext(workInProgress2);
            var renderState = workInProgress2.memoizedState;
            if (renderState === null) {
              bubbleProperties(workInProgress2);
              return null;
            }
            var didSuspendAlready = (workInProgress2.flags & DidCapture) !== NoFlags;
            var renderedTail = renderState.rendering;
            if (renderedTail === null) {
              if (!didSuspendAlready) {
                var cannotBeSuspended = renderHasNotSuspendedYet() && (current2 === null || (current2.flags & DidCapture) === NoFlags);
                if (!cannotBeSuspended) {
                  var row = workInProgress2.child;
                  while (row !== null) {
                    var suspended = findFirstSuspended(row);
                    if (suspended !== null) {
                      didSuspendAlready = true;
                      workInProgress2.flags |= DidCapture;
                      cutOffTailIfNeeded(renderState, false);
                      var newThenables = suspended.updateQueue;
                      if (newThenables !== null) {
                        workInProgress2.updateQueue = newThenables;
                        workInProgress2.flags |= Update;
                      }
                      workInProgress2.subtreeFlags = NoFlags;
                      resetChildFibers(workInProgress2, renderLanes2);
                      pushSuspenseContext(workInProgress2, setShallowSuspenseContext(suspenseStackCursor.current, ForceSuspenseFallback));
                      return workInProgress2.child;
                    }
                    row = row.sibling;
                  }
                }
                if (renderState.tail !== null && now() > getRenderTargetTime()) {
                  workInProgress2.flags |= DidCapture;
                  didSuspendAlready = true;
                  cutOffTailIfNeeded(renderState, false);
                  workInProgress2.lanes = SomeRetryLane;
                }
              } else {
                cutOffTailIfNeeded(renderState, false);
              }
            } else {
              if (!didSuspendAlready) {
                var _suspended = findFirstSuspended(renderedTail);
                if (_suspended !== null) {
                  workInProgress2.flags |= DidCapture;
                  didSuspendAlready = true;
                  var _newThenables = _suspended.updateQueue;
                  if (_newThenables !== null) {
                    workInProgress2.updateQueue = _newThenables;
                    workInProgress2.flags |= Update;
                  }
                  cutOffTailIfNeeded(renderState, true);
                  if (renderState.tail === null && renderState.tailMode === "hidden" && !renderedTail.alternate && !getIsHydrating()) {
                    bubbleProperties(workInProgress2);
                    return null;
                  }
                } else if (now() * 2 - renderState.renderingStartTime > getRenderTargetTime() && renderLanes2 !== OffscreenLane) {
                  workInProgress2.flags |= DidCapture;
                  didSuspendAlready = true;
                  cutOffTailIfNeeded(renderState, false);
                  workInProgress2.lanes = SomeRetryLane;
                }
              }
              if (renderState.isBackwards) {
                renderedTail.sibling = workInProgress2.child;
                workInProgress2.child = renderedTail;
              } else {
                var previousSibling = renderState.last;
                if (previousSibling !== null) {
                  previousSibling.sibling = renderedTail;
                } else {
                  workInProgress2.child = renderedTail;
                }
                renderState.last = renderedTail;
              }
            }
            if (renderState.tail !== null) {
              var next = renderState.tail;
              renderState.rendering = next;
              renderState.tail = next.sibling;
              renderState.renderingStartTime = now();
              next.sibling = null;
              var suspenseContext = suspenseStackCursor.current;
              if (didSuspendAlready) {
                suspenseContext = setShallowSuspenseContext(suspenseContext, ForceSuspenseFallback);
              } else {
                suspenseContext = setDefaultShallowSuspenseContext(suspenseContext);
              }
              pushSuspenseContext(workInProgress2, suspenseContext);
              return next;
            }
            bubbleProperties(workInProgress2);
            return null;
          }
          case ScopeComponent: {
            break;
          }
          case OffscreenComponent:
          case LegacyHiddenComponent: {
            popRenderLanes(workInProgress2);
            var _nextState = workInProgress2.memoizedState;
            var nextIsHidden = _nextState !== null;
            if (current2 !== null) {
              var _prevState = current2.memoizedState;
              var prevIsHidden = _prevState !== null;
              if (prevIsHidden !== nextIsHidden && !enableLegacyHidden) {
                workInProgress2.flags |= Visibility;
              }
            }
            if (!nextIsHidden || (workInProgress2.mode & ConcurrentMode) === NoMode) {
              bubbleProperties(workInProgress2);
            } else {
              if (includesSomeLane(subtreeRenderLanes, OffscreenLane)) {
                bubbleProperties(workInProgress2);
                {
                  if (workInProgress2.subtreeFlags & (Placement | Update)) {
                    workInProgress2.flags |= Visibility;
                  }
                }
              }
            }
            return null;
          }
          case CacheComponent: {
            return null;
          }
          case TracingMarkerComponent: {
            return null;
          }
        }
        throw new Error("Unknown unit of work tag (" + workInProgress2.tag + "). This error is likely caused by a bug in " + "React. Please file an issue.");
      }
      function unwindWork(current2, workInProgress2, renderLanes2) {
        popTreeContext(workInProgress2);
        switch (workInProgress2.tag) {
          case ClassComponent: {
            var Component = workInProgress2.type;
            if (isContextProvider(Component)) {
              popContext(workInProgress2);
            }
            var flags = workInProgress2.flags;
            if (flags & ShouldCapture) {
              workInProgress2.flags = flags & ~ShouldCapture | DidCapture;
              if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                transferActualDuration(workInProgress2);
              }
              return workInProgress2;
            }
            return null;
          }
          case HostRoot: {
            var root2 = workInProgress2.stateNode;
            popHostContainer(workInProgress2);
            popTopLevelContextObject(workInProgress2);
            resetWorkInProgressVersions();
            var _flags = workInProgress2.flags;
            if ((_flags & ShouldCapture) !== NoFlags && (_flags & DidCapture) === NoFlags) {
              workInProgress2.flags = _flags & ~ShouldCapture | DidCapture;
              return workInProgress2;
            }
            return null;
          }
          case HostComponent: {
            popHostContext(workInProgress2);
            return null;
          }
          case SuspenseComponent: {
            popSuspenseContext(workInProgress2);
            var suspenseState = workInProgress2.memoizedState;
            if (suspenseState !== null && suspenseState.dehydrated !== null) {
              if (workInProgress2.alternate === null) {
                throw new Error("Threw in newly mounted dehydrated component. This is likely a bug in " + "React. Please file an issue.");
              }
              resetHydrationState();
            }
            var _flags2 = workInProgress2.flags;
            if (_flags2 & ShouldCapture) {
              workInProgress2.flags = _flags2 & ~ShouldCapture | DidCapture;
              if ((workInProgress2.mode & ProfileMode) !== NoMode) {
                transferActualDuration(workInProgress2);
              }
              return workInProgress2;
            }
            return null;
          }
          case SuspenseListComponent: {
            popSuspenseContext(workInProgress2);
            return null;
          }
          case HostPortal:
            popHostContainer(workInProgress2);
            return null;
          case ContextProvider:
            var context = workInProgress2.type._context;
            popProvider(context, workInProgress2);
            return null;
          case OffscreenComponent:
          case LegacyHiddenComponent:
            popRenderLanes(workInProgress2);
            return null;
          case CacheComponent:
            return null;
          default:
            return null;
        }
      }
      function unwindInterruptedWork(current2, interruptedWork, renderLanes2) {
        popTreeContext(interruptedWork);
        switch (interruptedWork.tag) {
          case ClassComponent: {
            var childContextTypes = interruptedWork.type.childContextTypes;
            if (childContextTypes !== null && childContextTypes !== undefined) {
              popContext(interruptedWork);
            }
            break;
          }
          case HostRoot: {
            var root2 = interruptedWork.stateNode;
            popHostContainer(interruptedWork);
            popTopLevelContextObject(interruptedWork);
            resetWorkInProgressVersions();
            break;
          }
          case HostComponent: {
            popHostContext(interruptedWork);
            break;
          }
          case HostPortal:
            popHostContainer(interruptedWork);
            break;
          case SuspenseComponent:
            popSuspenseContext(interruptedWork);
            break;
          case SuspenseListComponent:
            popSuspenseContext(interruptedWork);
            break;
          case ContextProvider:
            var context = interruptedWork.type._context;
            popProvider(context, interruptedWork);
            break;
          case OffscreenComponent:
          case LegacyHiddenComponent:
            popRenderLanes(interruptedWork);
            break;
        }
      }
      var didWarnAboutUndefinedSnapshotBeforeUpdate = null;
      {
        didWarnAboutUndefinedSnapshotBeforeUpdate = new Set;
      }
      var offscreenSubtreeIsHidden = false;
      var offscreenSubtreeWasHidden = false;
      var PossiblyWeakSet = typeof WeakSet === "function" ? WeakSet : Set;
      var nextEffect = null;
      var inProgressLanes = null;
      var inProgressRoot = null;
      function reportUncaughtErrorInDEV(error2) {
        {
          invokeGuardedCallback(null, function() {
            throw error2;
          });
          clearCaughtError();
        }
      }
      var callComponentWillUnmountWithTimer = function(current2, instance) {
        instance.props = current2.memoizedProps;
        instance.state = current2.memoizedState;
        if (current2.mode & ProfileMode) {
          try {
            startLayoutEffectTimer();
            instance.componentWillUnmount();
          } finally {
            recordLayoutEffectDuration(current2);
          }
        } else {
          instance.componentWillUnmount();
        }
      };
      function safelyCallCommitHookLayoutEffectListMount(current2, nearestMountedAncestor) {
        try {
          commitHookEffectListMount(Layout, current2);
        } catch (error2) {
          captureCommitPhaseError(current2, nearestMountedAncestor, error2);
        }
      }
      function safelyCallComponentWillUnmount(current2, nearestMountedAncestor, instance) {
        try {
          callComponentWillUnmountWithTimer(current2, instance);
        } catch (error2) {
          captureCommitPhaseError(current2, nearestMountedAncestor, error2);
        }
      }
      function safelyCallComponentDidMount(current2, nearestMountedAncestor, instance) {
        try {
          instance.componentDidMount();
        } catch (error2) {
          captureCommitPhaseError(current2, nearestMountedAncestor, error2);
        }
      }
      function safelyAttachRef(current2, nearestMountedAncestor) {
        try {
          commitAttachRef(current2);
        } catch (error2) {
          captureCommitPhaseError(current2, nearestMountedAncestor, error2);
        }
      }
      function safelyDetachRef(current2, nearestMountedAncestor) {
        var ref = current2.ref;
        if (ref !== null) {
          if (typeof ref === "function") {
            var retVal;
            try {
              if (enableProfilerTimer && enableProfilerCommitHooks && current2.mode & ProfileMode) {
                try {
                  startLayoutEffectTimer();
                  retVal = ref(null);
                } finally {
                  recordLayoutEffectDuration(current2);
                }
              } else {
                retVal = ref(null);
              }
            } catch (error2) {
              captureCommitPhaseError(current2, nearestMountedAncestor, error2);
            }
            {
              if (typeof retVal === "function") {
                error("Unexpected return value from a callback ref in %s. " + "A callback ref should not return a function.", getComponentNameFromFiber(current2));
              }
            }
          } else {
            ref.current = null;
          }
        }
      }
      function safelyCallDestroy(current2, nearestMountedAncestor, destroy) {
        try {
          destroy();
        } catch (error2) {
          captureCommitPhaseError(current2, nearestMountedAncestor, error2);
        }
      }
      var focusedInstanceHandle = null;
      var shouldFireAfterActiveInstanceBlur = false;
      function commitBeforeMutationEffects(root2, firstChild) {
        focusedInstanceHandle = prepareForCommit(root2.containerInfo);
        nextEffect = firstChild;
        commitBeforeMutationEffects_begin();
        var shouldFire = shouldFireAfterActiveInstanceBlur;
        shouldFireAfterActiveInstanceBlur = false;
        focusedInstanceHandle = null;
        return shouldFire;
      }
      function commitBeforeMutationEffects_begin() {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          var child = fiber.child;
          if ((fiber.subtreeFlags & BeforeMutationMask) !== NoFlags && child !== null) {
            child.return = fiber;
            nextEffect = child;
          } else {
            commitBeforeMutationEffects_complete();
          }
        }
      }
      function commitBeforeMutationEffects_complete() {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          setCurrentFiber(fiber);
          try {
            commitBeforeMutationEffectsOnFiber(fiber);
          } catch (error2) {
            captureCommitPhaseError(fiber, fiber.return, error2);
          }
          resetCurrentFiber();
          var sibling = fiber.sibling;
          if (sibling !== null) {
            sibling.return = fiber.return;
            nextEffect = sibling;
            return;
          }
          nextEffect = fiber.return;
        }
      }
      function commitBeforeMutationEffectsOnFiber(finishedWork) {
        var current2 = finishedWork.alternate;
        var flags = finishedWork.flags;
        if ((flags & Snapshot) !== NoFlags) {
          setCurrentFiber(finishedWork);
          switch (finishedWork.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              break;
            }
            case ClassComponent: {
              if (current2 !== null) {
                var prevProps = current2.memoizedProps;
                var prevState = current2.memoizedState;
                var instance = finishedWork.stateNode;
                {
                  if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                    if (instance.props !== finishedWork.memoizedProps) {
                      error("Expected %s props to match memoized props before " + "getSnapshotBeforeUpdate. " + "This might either be because of a bug in React, or because " + "a component reassigns its own `this.props`. " + "Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                    }
                    if (instance.state !== finishedWork.memoizedState) {
                      error("Expected %s state to match memoized state before " + "getSnapshotBeforeUpdate. " + "This might either be because of a bug in React, or because " + "a component reassigns its own `this.state`. " + "Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                    }
                  }
                }
                var snapshot = instance.getSnapshotBeforeUpdate(finishedWork.elementType === finishedWork.type ? prevProps : resolveDefaultProps(finishedWork.type, prevProps), prevState);
                {
                  var didWarnSet = didWarnAboutUndefinedSnapshotBeforeUpdate;
                  if (snapshot === undefined && !didWarnSet.has(finishedWork.type)) {
                    didWarnSet.add(finishedWork.type);
                    error("%s.getSnapshotBeforeUpdate(): A snapshot value (or null) " + "must be returned. You have returned undefined.", getComponentNameFromFiber(finishedWork));
                  }
                }
                instance.__reactInternalSnapshotBeforeUpdate = snapshot;
              }
              break;
            }
            case HostRoot: {
              {
                var root2 = finishedWork.stateNode;
                clearContainer(root2.containerInfo);
              }
              break;
            }
            case HostComponent:
            case HostText:
            case HostPortal:
            case IncompleteClassComponent:
              break;
            default: {
              throw new Error("This unit of work tag should not have side-effects. This error is " + "likely caused by a bug in React. Please file an issue.");
            }
          }
          resetCurrentFiber();
        }
      }
      function commitHookEffectListUnmount(flags, finishedWork, nearestMountedAncestor) {
        var updateQueue = finishedWork.updateQueue;
        var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
        if (lastEffect !== null) {
          var firstEffect = lastEffect.next;
          var effect = firstEffect;
          do {
            if ((effect.tag & flags) === flags) {
              var destroy = effect.destroy;
              effect.destroy = undefined;
              if (destroy !== undefined) {
                {
                  if ((flags & Passive$1) !== NoFlags$1) {
                    markComponentPassiveEffectUnmountStarted(finishedWork);
                  } else if ((flags & Layout) !== NoFlags$1) {
                    markComponentLayoutEffectUnmountStarted(finishedWork);
                  }
                }
                {
                  if ((flags & Insertion) !== NoFlags$1) {
                    setIsRunningInsertionEffect(true);
                  }
                }
                safelyCallDestroy(finishedWork, nearestMountedAncestor, destroy);
                {
                  if ((flags & Insertion) !== NoFlags$1) {
                    setIsRunningInsertionEffect(false);
                  }
                }
                {
                  if ((flags & Passive$1) !== NoFlags$1) {
                    markComponentPassiveEffectUnmountStopped();
                  } else if ((flags & Layout) !== NoFlags$1) {
                    markComponentLayoutEffectUnmountStopped();
                  }
                }
              }
            }
            effect = effect.next;
          } while (effect !== firstEffect);
        }
      }
      function commitHookEffectListMount(flags, finishedWork) {
        var updateQueue = finishedWork.updateQueue;
        var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;
        if (lastEffect !== null) {
          var firstEffect = lastEffect.next;
          var effect = firstEffect;
          do {
            if ((effect.tag & flags) === flags) {
              {
                if ((flags & Passive$1) !== NoFlags$1) {
                  markComponentPassiveEffectMountStarted(finishedWork);
                } else if ((flags & Layout) !== NoFlags$1) {
                  markComponentLayoutEffectMountStarted(finishedWork);
                }
              }
              var create = effect.create;
              {
                if ((flags & Insertion) !== NoFlags$1) {
                  setIsRunningInsertionEffect(true);
                }
              }
              effect.destroy = create();
              {
                if ((flags & Insertion) !== NoFlags$1) {
                  setIsRunningInsertionEffect(false);
                }
              }
              {
                if ((flags & Passive$1) !== NoFlags$1) {
                  markComponentPassiveEffectMountStopped();
                } else if ((flags & Layout) !== NoFlags$1) {
                  markComponentLayoutEffectMountStopped();
                }
              }
              {
                var destroy = effect.destroy;
                if (destroy !== undefined && typeof destroy !== "function") {
                  var hookName = undefined;
                  if ((effect.tag & Layout) !== NoFlags) {
                    hookName = "useLayoutEffect";
                  } else if ((effect.tag & Insertion) !== NoFlags) {
                    hookName = "useInsertionEffect";
                  } else {
                    hookName = "useEffect";
                  }
                  var addendum = undefined;
                  if (destroy === null) {
                    addendum = " You returned null. If your effect does not require clean " + "up, return undefined (or nothing).";
                  } else if (typeof destroy.then === "function") {
                    addendum = `

It looks like you wrote ` + hookName + "(async () => ...) or returned a Promise. " + "Instead, write the async function inside your effect " + `and call it immediately:

` + hookName + `(() => {
` + `  async function fetchData() {
` + `    // You can await here
` + `    const response = await MyAPI.getData(someId);
` + `    // ...
` + `  }
` + `  fetchData();
` + `}, [someId]); // Or [] if effect doesn't need props or state

` + "Learn more about data fetching with Hooks: https://reactjs.org/link/hooks-data-fetching";
                  } else {
                    addendum = " You returned: " + destroy;
                  }
                  error("%s must not return anything besides a function, " + "which is used for clean-up.%s", hookName, addendum);
                }
              }
            }
            effect = effect.next;
          } while (effect !== firstEffect);
        }
      }
      function commitPassiveEffectDurations(finishedRoot, finishedWork) {
        {
          if ((finishedWork.flags & Update) !== NoFlags) {
            switch (finishedWork.tag) {
              case Profiler: {
                var passiveEffectDuration = finishedWork.stateNode.passiveEffectDuration;
                var _finishedWork$memoize = finishedWork.memoizedProps, id = _finishedWork$memoize.id, onPostCommit = _finishedWork$memoize.onPostCommit;
                var commitTime2 = getCommitTime();
                var phase = finishedWork.alternate === null ? "mount" : "update";
                {
                  if (isCurrentUpdateNested()) {
                    phase = "nested-update";
                  }
                }
                if (typeof onPostCommit === "function") {
                  onPostCommit(id, phase, passiveEffectDuration, commitTime2);
                }
                var parentFiber = finishedWork.return;
                outer:
                  while (parentFiber !== null) {
                    switch (parentFiber.tag) {
                      case HostRoot:
                        var root2 = parentFiber.stateNode;
                        root2.passiveEffectDuration += passiveEffectDuration;
                        break outer;
                      case Profiler:
                        var parentStateNode = parentFiber.stateNode;
                        parentStateNode.passiveEffectDuration += passiveEffectDuration;
                        break outer;
                    }
                    parentFiber = parentFiber.return;
                  }
                break;
              }
            }
          }
        }
      }
      function commitLayoutEffectOnFiber(finishedRoot, current2, finishedWork, committedLanes) {
        if ((finishedWork.flags & LayoutMask) !== NoFlags) {
          switch (finishedWork.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              if (!offscreenSubtreeWasHidden) {
                if (finishedWork.mode & ProfileMode) {
                  try {
                    startLayoutEffectTimer();
                    commitHookEffectListMount(Layout | HasEffect, finishedWork);
                  } finally {
                    recordLayoutEffectDuration(finishedWork);
                  }
                } else {
                  commitHookEffectListMount(Layout | HasEffect, finishedWork);
                }
              }
              break;
            }
            case ClassComponent: {
              var instance = finishedWork.stateNode;
              if (finishedWork.flags & Update) {
                if (!offscreenSubtreeWasHidden) {
                  if (current2 === null) {
                    {
                      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                        if (instance.props !== finishedWork.memoizedProps) {
                          error("Expected %s props to match memoized props before " + "componentDidMount. " + "This might either be because of a bug in React, or because " + "a component reassigns its own `this.props`. " + "Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                        if (instance.state !== finishedWork.memoizedState) {
                          error("Expected %s state to match memoized state before " + "componentDidMount. " + "This might either be because of a bug in React, or because " + "a component reassigns its own `this.state`. " + "Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                      }
                    }
                    if (finishedWork.mode & ProfileMode) {
                      try {
                        startLayoutEffectTimer();
                        instance.componentDidMount();
                      } finally {
                        recordLayoutEffectDuration(finishedWork);
                      }
                    } else {
                      instance.componentDidMount();
                    }
                  } else {
                    var prevProps = finishedWork.elementType === finishedWork.type ? current2.memoizedProps : resolveDefaultProps(finishedWork.type, current2.memoizedProps);
                    var prevState = current2.memoizedState;
                    {
                      if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                        if (instance.props !== finishedWork.memoizedProps) {
                          error("Expected %s props to match memoized props before " + "componentDidUpdate. " + "This might either be because of a bug in React, or because " + "a component reassigns its own `this.props`. " + "Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                        if (instance.state !== finishedWork.memoizedState) {
                          error("Expected %s state to match memoized state before " + "componentDidUpdate. " + "This might either be because of a bug in React, or because " + "a component reassigns its own `this.state`. " + "Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                        }
                      }
                    }
                    if (finishedWork.mode & ProfileMode) {
                      try {
                        startLayoutEffectTimer();
                        instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                      } finally {
                        recordLayoutEffectDuration(finishedWork);
                      }
                    } else {
                      instance.componentDidUpdate(prevProps, prevState, instance.__reactInternalSnapshotBeforeUpdate);
                    }
                  }
                }
              }
              var updateQueue = finishedWork.updateQueue;
              if (updateQueue !== null) {
                {
                  if (finishedWork.type === finishedWork.elementType && !didWarnAboutReassigningProps) {
                    if (instance.props !== finishedWork.memoizedProps) {
                      error("Expected %s props to match memoized props before " + "processing the update queue. " + "This might either be because of a bug in React, or because " + "a component reassigns its own `this.props`. " + "Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                    }
                    if (instance.state !== finishedWork.memoizedState) {
                      error("Expected %s state to match memoized state before " + "processing the update queue. " + "This might either be because of a bug in React, or because " + "a component reassigns its own `this.state`. " + "Please file an issue.", getComponentNameFromFiber(finishedWork) || "instance");
                    }
                  }
                }
                commitUpdateQueue(finishedWork, updateQueue, instance);
              }
              break;
            }
            case HostRoot: {
              var _updateQueue = finishedWork.updateQueue;
              if (_updateQueue !== null) {
                var _instance = null;
                if (finishedWork.child !== null) {
                  switch (finishedWork.child.tag) {
                    case HostComponent:
                      _instance = getPublicInstance(finishedWork.child.stateNode);
                      break;
                    case ClassComponent:
                      _instance = finishedWork.child.stateNode;
                      break;
                  }
                }
                commitUpdateQueue(finishedWork, _updateQueue, _instance);
              }
              break;
            }
            case HostComponent: {
              var _instance2 = finishedWork.stateNode;
              if (current2 === null && finishedWork.flags & Update) {
                var type = finishedWork.type;
                var props = finishedWork.memoizedProps;
                commitMount(_instance2, type, props);
              }
              break;
            }
            case HostText: {
              break;
            }
            case HostPortal: {
              break;
            }
            case Profiler: {
              {
                var _finishedWork$memoize2 = finishedWork.memoizedProps, onCommit = _finishedWork$memoize2.onCommit, onRender = _finishedWork$memoize2.onRender;
                var effectDuration = finishedWork.stateNode.effectDuration;
                var commitTime2 = getCommitTime();
                var phase = current2 === null ? "mount" : "update";
                {
                  if (isCurrentUpdateNested()) {
                    phase = "nested-update";
                  }
                }
                if (typeof onRender === "function") {
                  onRender(finishedWork.memoizedProps.id, phase, finishedWork.actualDuration, finishedWork.treeBaseDuration, finishedWork.actualStartTime, commitTime2);
                }
                {
                  if (typeof onCommit === "function") {
                    onCommit(finishedWork.memoizedProps.id, phase, effectDuration, commitTime2);
                  }
                  enqueuePendingPassiveProfilerEffect(finishedWork);
                  var parentFiber = finishedWork.return;
                  outer:
                    while (parentFiber !== null) {
                      switch (parentFiber.tag) {
                        case HostRoot:
                          var root2 = parentFiber.stateNode;
                          root2.effectDuration += effectDuration;
                          break outer;
                        case Profiler:
                          var parentStateNode = parentFiber.stateNode;
                          parentStateNode.effectDuration += effectDuration;
                          break outer;
                      }
                      parentFiber = parentFiber.return;
                    }
                }
              }
              break;
            }
            case SuspenseComponent: {
              commitSuspenseHydrationCallbacks(finishedRoot, finishedWork);
              break;
            }
            case SuspenseListComponent:
            case IncompleteClassComponent:
            case ScopeComponent:
            case OffscreenComponent:
            case LegacyHiddenComponent:
            case TracingMarkerComponent: {
              break;
            }
            default:
              throw new Error("This unit of work tag should not have side-effects. This error is " + "likely caused by a bug in React. Please file an issue.");
          }
        }
        if (!offscreenSubtreeWasHidden) {
          {
            if (finishedWork.flags & Ref) {
              commitAttachRef(finishedWork);
            }
          }
        }
      }
      function reappearLayoutEffectsOnFiber(node) {
        switch (node.tag) {
          case FunctionComponent:
          case ForwardRef:
          case SimpleMemoComponent: {
            if (node.mode & ProfileMode) {
              try {
                startLayoutEffectTimer();
                safelyCallCommitHookLayoutEffectListMount(node, node.return);
              } finally {
                recordLayoutEffectDuration(node);
              }
            } else {
              safelyCallCommitHookLayoutEffectListMount(node, node.return);
            }
            break;
          }
          case ClassComponent: {
            var instance = node.stateNode;
            if (typeof instance.componentDidMount === "function") {
              safelyCallComponentDidMount(node, node.return, instance);
            }
            safelyAttachRef(node, node.return);
            break;
          }
          case HostComponent: {
            safelyAttachRef(node, node.return);
            break;
          }
        }
      }
      function hideOrUnhideAllChildren(finishedWork, isHidden) {
        var hostSubtreeRoot = null;
        {
          var node = finishedWork;
          while (true) {
            if (node.tag === HostComponent) {
              if (hostSubtreeRoot === null) {
                hostSubtreeRoot = node;
                try {
                  var instance = node.stateNode;
                  if (isHidden) {
                    hideInstance(instance);
                  } else {
                    unhideInstance(node.stateNode, node.memoizedProps);
                  }
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
              }
            } else if (node.tag === HostText) {
              if (hostSubtreeRoot === null) {
                try {
                  var _instance3 = node.stateNode;
                  if (isHidden) {
                    hideTextInstance(_instance3);
                  } else {
                    unhideTextInstance(_instance3, node.memoizedProps);
                  }
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
              }
            } else if ((node.tag === OffscreenComponent || node.tag === LegacyHiddenComponent) && node.memoizedState !== null && node !== finishedWork)
              ;
            else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }
            if (node === finishedWork) {
              return;
            }
            while (node.sibling === null) {
              if (node.return === null || node.return === finishedWork) {
                return;
              }
              if (hostSubtreeRoot === node) {
                hostSubtreeRoot = null;
              }
              node = node.return;
            }
            if (hostSubtreeRoot === node) {
              hostSubtreeRoot = null;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
        }
      }
      function commitAttachRef(finishedWork) {
        var ref = finishedWork.ref;
        if (ref !== null) {
          var instance = finishedWork.stateNode;
          var instanceToUse;
          switch (finishedWork.tag) {
            case HostComponent:
              instanceToUse = getPublicInstance(instance);
              break;
            default:
              instanceToUse = instance;
          }
          if (typeof ref === "function") {
            var retVal;
            if (finishedWork.mode & ProfileMode) {
              try {
                startLayoutEffectTimer();
                retVal = ref(instanceToUse);
              } finally {
                recordLayoutEffectDuration(finishedWork);
              }
            } else {
              retVal = ref(instanceToUse);
            }
            {
              if (typeof retVal === "function") {
                error("Unexpected return value from a callback ref in %s. " + "A callback ref should not return a function.", getComponentNameFromFiber(finishedWork));
              }
            }
          } else {
            {
              if (!ref.hasOwnProperty("current")) {
                error("Unexpected ref object provided for %s. " + "Use either a ref-setter function or React.createRef().", getComponentNameFromFiber(finishedWork));
              }
            }
            ref.current = instanceToUse;
          }
        }
      }
      function detachFiberMutation(fiber) {
        var alternate = fiber.alternate;
        if (alternate !== null) {
          alternate.return = null;
        }
        fiber.return = null;
      }
      function detachFiberAfterEffects(fiber) {
        var alternate = fiber.alternate;
        if (alternate !== null) {
          fiber.alternate = null;
          detachFiberAfterEffects(alternate);
        }
        {
          fiber.child = null;
          fiber.deletions = null;
          fiber.sibling = null;
          if (fiber.tag === HostComponent) {
            var hostInstance = fiber.stateNode;
            if (hostInstance !== null) {
              detachDeletedInstance(hostInstance);
            }
          }
          fiber.stateNode = null;
          {
            fiber._debugOwner = null;
          }
          {
            fiber.return = null;
            fiber.dependencies = null;
            fiber.memoizedProps = null;
            fiber.memoizedState = null;
            fiber.pendingProps = null;
            fiber.stateNode = null;
            fiber.updateQueue = null;
          }
        }
      }
      function getHostParentFiber(fiber) {
        var parent = fiber.return;
        while (parent !== null) {
          if (isHostParent(parent)) {
            return parent;
          }
          parent = parent.return;
        }
        throw new Error("Expected to find a host parent. This error is likely caused by a bug " + "in React. Please file an issue.");
      }
      function isHostParent(fiber) {
        return fiber.tag === HostComponent || fiber.tag === HostRoot || fiber.tag === HostPortal;
      }
      function getHostSibling(fiber) {
        var node = fiber;
        siblings:
          while (true) {
            while (node.sibling === null) {
              if (node.return === null || isHostParent(node.return)) {
                return null;
              }
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
            while (node.tag !== HostComponent && node.tag !== HostText && node.tag !== DehydratedFragment) {
              if (node.flags & Placement) {
                continue siblings;
              }
              if (node.child === null || node.tag === HostPortal) {
                continue siblings;
              } else {
                node.child.return = node;
                node = node.child;
              }
            }
            if (!(node.flags & Placement)) {
              return node.stateNode;
            }
          }
      }
      function commitPlacement(finishedWork) {
        var parentFiber = getHostParentFiber(finishedWork);
        switch (parentFiber.tag) {
          case HostComponent: {
            var parent = parentFiber.stateNode;
            if (parentFiber.flags & ContentReset) {
              resetTextContent(parent);
              parentFiber.flags &= ~ContentReset;
            }
            var before = getHostSibling(finishedWork);
            insertOrAppendPlacementNode(finishedWork, before, parent);
            break;
          }
          case HostRoot:
          case HostPortal: {
            var _parent = parentFiber.stateNode.containerInfo;
            var _before = getHostSibling(finishedWork);
            insertOrAppendPlacementNodeIntoContainer(finishedWork, _before, _parent);
            break;
          }
          default:
            throw new Error("Invalid host parent fiber. This error is likely caused by a bug " + "in React. Please file an issue.");
        }
      }
      function insertOrAppendPlacementNodeIntoContainer(node, before, parent) {
        var tag = node.tag;
        var isHost = tag === HostComponent || tag === HostText;
        if (isHost) {
          var stateNode = node.stateNode;
          if (before) {
            insertInContainerBefore(parent, stateNode, before);
          } else {
            appendChildToContainer(parent, stateNode);
          }
        } else if (tag === HostPortal)
          ;
        else {
          var child = node.child;
          if (child !== null) {
            insertOrAppendPlacementNodeIntoContainer(child, before, parent);
            var sibling = child.sibling;
            while (sibling !== null) {
              insertOrAppendPlacementNodeIntoContainer(sibling, before, parent);
              sibling = sibling.sibling;
            }
          }
        }
      }
      function insertOrAppendPlacementNode(node, before, parent) {
        var tag = node.tag;
        var isHost = tag === HostComponent || tag === HostText;
        if (isHost) {
          var stateNode = node.stateNode;
          if (before) {
            insertBefore(parent, stateNode, before);
          } else {
            appendChild(parent, stateNode);
          }
        } else if (tag === HostPortal)
          ;
        else {
          var child = node.child;
          if (child !== null) {
            insertOrAppendPlacementNode(child, before, parent);
            var sibling = child.sibling;
            while (sibling !== null) {
              insertOrAppendPlacementNode(sibling, before, parent);
              sibling = sibling.sibling;
            }
          }
        }
      }
      var hostParent = null;
      var hostParentIsContainer = false;
      function commitDeletionEffects(root2, returnFiber, deletedFiber) {
        {
          var parent = returnFiber;
          findParent:
            while (parent !== null) {
              switch (parent.tag) {
                case HostComponent: {
                  hostParent = parent.stateNode;
                  hostParentIsContainer = false;
                  break findParent;
                }
                case HostRoot: {
                  hostParent = parent.stateNode.containerInfo;
                  hostParentIsContainer = true;
                  break findParent;
                }
                case HostPortal: {
                  hostParent = parent.stateNode.containerInfo;
                  hostParentIsContainer = true;
                  break findParent;
                }
              }
              parent = parent.return;
            }
          if (hostParent === null) {
            throw new Error("Expected to find a host parent. This error is likely caused by " + "a bug in React. Please file an issue.");
          }
          commitDeletionEffectsOnFiber(root2, returnFiber, deletedFiber);
          hostParent = null;
          hostParentIsContainer = false;
        }
        detachFiberMutation(deletedFiber);
      }
      function recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, parent) {
        var child = parent.child;
        while (child !== null) {
          commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, child);
          child = child.sibling;
        }
      }
      function commitDeletionEffectsOnFiber(finishedRoot, nearestMountedAncestor, deletedFiber) {
        onCommitUnmount(deletedFiber);
        switch (deletedFiber.tag) {
          case HostComponent: {
            if (!offscreenSubtreeWasHidden) {
              safelyDetachRef(deletedFiber, nearestMountedAncestor);
            }
          }
          case HostText: {
            {
              var prevHostParent = hostParent;
              var prevHostParentIsContainer = hostParentIsContainer;
              hostParent = null;
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              hostParent = prevHostParent;
              hostParentIsContainer = prevHostParentIsContainer;
              if (hostParent !== null) {
                if (hostParentIsContainer) {
                  removeChildFromContainer(hostParent, deletedFiber.stateNode);
                } else {
                  removeChild(hostParent, deletedFiber.stateNode);
                }
              }
            }
            return;
          }
          case DehydratedFragment: {
            {
              if (hostParent !== null) {
                if (hostParentIsContainer) {
                  clearSuspenseBoundaryFromContainer(hostParent, deletedFiber.stateNode);
                } else {
                  clearSuspenseBoundary(hostParent, deletedFiber.stateNode);
                }
              }
            }
            return;
          }
          case HostPortal: {
            {
              var _prevHostParent = hostParent;
              var _prevHostParentIsContainer = hostParentIsContainer;
              hostParent = deletedFiber.stateNode.containerInfo;
              hostParentIsContainer = true;
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              hostParent = _prevHostParent;
              hostParentIsContainer = _prevHostParentIsContainer;
            }
            return;
          }
          case FunctionComponent:
          case ForwardRef:
          case MemoComponent:
          case SimpleMemoComponent: {
            if (!offscreenSubtreeWasHidden) {
              var updateQueue = deletedFiber.updateQueue;
              if (updateQueue !== null) {
                var lastEffect = updateQueue.lastEffect;
                if (lastEffect !== null) {
                  var firstEffect = lastEffect.next;
                  var effect = firstEffect;
                  do {
                    var _effect = effect, destroy = _effect.destroy, tag = _effect.tag;
                    if (destroy !== undefined) {
                      if ((tag & Insertion) !== NoFlags$1) {
                        safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                      } else if ((tag & Layout) !== NoFlags$1) {
                        {
                          markComponentLayoutEffectUnmountStarted(deletedFiber);
                        }
                        if (deletedFiber.mode & ProfileMode) {
                          startLayoutEffectTimer();
                          safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                          recordLayoutEffectDuration(deletedFiber);
                        } else {
                          safelyCallDestroy(deletedFiber, nearestMountedAncestor, destroy);
                        }
                        {
                          markComponentLayoutEffectUnmountStopped();
                        }
                      }
                    }
                    effect = effect.next;
                  } while (effect !== firstEffect);
                }
              }
            }
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            return;
          }
          case ClassComponent: {
            if (!offscreenSubtreeWasHidden) {
              safelyDetachRef(deletedFiber, nearestMountedAncestor);
              var instance = deletedFiber.stateNode;
              if (typeof instance.componentWillUnmount === "function") {
                safelyCallComponentWillUnmount(deletedFiber, nearestMountedAncestor, instance);
              }
            }
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            return;
          }
          case ScopeComponent: {
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            return;
          }
          case OffscreenComponent: {
            if (deletedFiber.mode & ConcurrentMode) {
              var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || deletedFiber.memoizedState !== null;
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
            } else {
              recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            }
            break;
          }
          default: {
            recursivelyTraverseDeletionEffects(finishedRoot, nearestMountedAncestor, deletedFiber);
            return;
          }
        }
      }
      function commitSuspenseCallback(finishedWork) {
        var newState = finishedWork.memoizedState;
      }
      function commitSuspenseHydrationCallbacks(finishedRoot, finishedWork) {
        var newState = finishedWork.memoizedState;
        if (newState === null) {
          var current2 = finishedWork.alternate;
          if (current2 !== null) {
            var prevState = current2.memoizedState;
            if (prevState !== null) {
              var suspenseInstance = prevState.dehydrated;
              if (suspenseInstance !== null) {
                commitHydratedSuspenseInstance(suspenseInstance);
              }
            }
          }
        }
      }
      function attachSuspenseRetryListeners(finishedWork) {
        var wakeables = finishedWork.updateQueue;
        if (wakeables !== null) {
          finishedWork.updateQueue = null;
          var retryCache = finishedWork.stateNode;
          if (retryCache === null) {
            retryCache = finishedWork.stateNode = new PossiblyWeakSet;
          }
          wakeables.forEach(function(wakeable) {
            var retry = resolveRetryWakeable.bind(null, finishedWork, wakeable);
            if (!retryCache.has(wakeable)) {
              retryCache.add(wakeable);
              {
                if (isDevToolsPresent) {
                  if (inProgressLanes !== null && inProgressRoot !== null) {
                    restorePendingUpdaters(inProgressRoot, inProgressLanes);
                  } else {
                    throw Error("Expected finished root and lanes to be set. This is a bug in React.");
                  }
                }
              }
              wakeable.then(retry, retry);
            }
          });
        }
      }
      function commitMutationEffects(root2, finishedWork, committedLanes) {
        inProgressLanes = committedLanes;
        inProgressRoot = root2;
        setCurrentFiber(finishedWork);
        commitMutationEffectsOnFiber(finishedWork, root2);
        setCurrentFiber(finishedWork);
        inProgressLanes = null;
        inProgressRoot = null;
      }
      function recursivelyTraverseMutationEffects(root2, parentFiber, lanes) {
        var deletions = parentFiber.deletions;
        if (deletions !== null) {
          for (var i = 0;i < deletions.length; i++) {
            var childToDelete = deletions[i];
            try {
              commitDeletionEffects(root2, parentFiber, childToDelete);
            } catch (error2) {
              captureCommitPhaseError(childToDelete, parentFiber, error2);
            }
          }
        }
        var prevDebugFiber = getCurrentFiber();
        if (parentFiber.subtreeFlags & MutationMask) {
          var child = parentFiber.child;
          while (child !== null) {
            setCurrentFiber(child);
            commitMutationEffectsOnFiber(child, root2);
            child = child.sibling;
          }
        }
        setCurrentFiber(prevDebugFiber);
      }
      function commitMutationEffectsOnFiber(finishedWork, root2, lanes) {
        var current2 = finishedWork.alternate;
        var flags = finishedWork.flags;
        switch (finishedWork.tag) {
          case FunctionComponent:
          case ForwardRef:
          case MemoComponent:
          case SimpleMemoComponent: {
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & Update) {
              try {
                commitHookEffectListUnmount(Insertion | HasEffect, finishedWork, finishedWork.return);
                commitHookEffectListMount(Insertion | HasEffect, finishedWork);
              } catch (error2) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error2);
              }
              if (finishedWork.mode & ProfileMode) {
                try {
                  startLayoutEffectTimer();
                  commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
                recordLayoutEffectDuration(finishedWork);
              } else {
                try {
                  commitHookEffectListUnmount(Layout | HasEffect, finishedWork, finishedWork.return);
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
              }
            }
            return;
          }
          case ClassComponent: {
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & Ref) {
              if (current2 !== null) {
                safelyDetachRef(current2, current2.return);
              }
            }
            return;
          }
          case HostComponent: {
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & Ref) {
              if (current2 !== null) {
                safelyDetachRef(current2, current2.return);
              }
            }
            {
              if (finishedWork.flags & ContentReset) {
                var instance = finishedWork.stateNode;
                try {
                  resetTextContent(instance);
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
              }
              if (flags & Update) {
                var _instance4 = finishedWork.stateNode;
                if (_instance4 != null) {
                  var newProps = finishedWork.memoizedProps;
                  var oldProps = current2 !== null ? current2.memoizedProps : newProps;
                  var type = finishedWork.type;
                  var updatePayload = finishedWork.updateQueue;
                  finishedWork.updateQueue = null;
                  if (updatePayload !== null) {
                    try {
                      commitUpdate(_instance4, updatePayload, type, oldProps, newProps, finishedWork);
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                  }
                }
              }
            }
            return;
          }
          case HostText: {
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & Update) {
              {
                if (finishedWork.stateNode === null) {
                  throw new Error("This should have a text node initialized. This error is likely " + "caused by a bug in React. Please file an issue.");
                }
                var textInstance = finishedWork.stateNode;
                var newText = finishedWork.memoizedProps;
                var oldText = current2 !== null ? current2.memoizedProps : newText;
                try {
                  commitTextUpdate(textInstance, oldText, newText);
                } catch (error2) {
                  captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                }
              }
            }
            return;
          }
          case HostRoot: {
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & Update) {
              {
                if (current2 !== null) {
                  var prevRootState = current2.memoizedState;
                  if (prevRootState.isDehydrated) {
                    try {
                      commitHydratedContainer(root2.containerInfo);
                    } catch (error2) {
                      captureCommitPhaseError(finishedWork, finishedWork.return, error2);
                    }
                  }
                }
              }
            }
            return;
          }
          case HostPortal: {
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            return;
          }
          case SuspenseComponent: {
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            var offscreenFiber = finishedWork.child;
            if (offscreenFiber.flags & Visibility) {
              var offscreenInstance = offscreenFiber.stateNode;
              var newState = offscreenFiber.memoizedState;
              var isHidden = newState !== null;
              offscreenInstance.isHidden = isHidden;
              if (isHidden) {
                var wasHidden = offscreenFiber.alternate !== null && offscreenFiber.alternate.memoizedState !== null;
                if (!wasHidden) {
                  markCommitTimeOfFallback();
                }
              }
            }
            if (flags & Update) {
              try {
                commitSuspenseCallback(finishedWork);
              } catch (error2) {
                captureCommitPhaseError(finishedWork, finishedWork.return, error2);
              }
              attachSuspenseRetryListeners(finishedWork);
            }
            return;
          }
          case OffscreenComponent: {
            var _wasHidden = current2 !== null && current2.memoizedState !== null;
            if (finishedWork.mode & ConcurrentMode) {
              var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden || _wasHidden;
              recursivelyTraverseMutationEffects(root2, finishedWork);
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
            } else {
              recursivelyTraverseMutationEffects(root2, finishedWork);
            }
            commitReconciliationEffects(finishedWork);
            if (flags & Visibility) {
              var _offscreenInstance = finishedWork.stateNode;
              var _newState = finishedWork.memoizedState;
              var _isHidden = _newState !== null;
              var offscreenBoundary = finishedWork;
              _offscreenInstance.isHidden = _isHidden;
              {
                if (_isHidden) {
                  if (!_wasHidden) {
                    if ((offscreenBoundary.mode & ConcurrentMode) !== NoMode) {
                      nextEffect = offscreenBoundary;
                      var offscreenChild = offscreenBoundary.child;
                      while (offscreenChild !== null) {
                        nextEffect = offscreenChild;
                        disappearLayoutEffects_begin(offscreenChild);
                        offscreenChild = offscreenChild.sibling;
                      }
                    }
                  }
                }
              }
              {
                hideOrUnhideAllChildren(offscreenBoundary, _isHidden);
              }
            }
            return;
          }
          case SuspenseListComponent: {
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            if (flags & Update) {
              attachSuspenseRetryListeners(finishedWork);
            }
            return;
          }
          case ScopeComponent: {
            return;
          }
          default: {
            recursivelyTraverseMutationEffects(root2, finishedWork);
            commitReconciliationEffects(finishedWork);
            return;
          }
        }
      }
      function commitReconciliationEffects(finishedWork) {
        var flags = finishedWork.flags;
        if (flags & Placement) {
          try {
            commitPlacement(finishedWork);
          } catch (error2) {
            captureCommitPhaseError(finishedWork, finishedWork.return, error2);
          }
          finishedWork.flags &= ~Placement;
        }
        if (flags & Hydrating) {
          finishedWork.flags &= ~Hydrating;
        }
      }
      function commitLayoutEffects(finishedWork, root2, committedLanes) {
        inProgressLanes = committedLanes;
        inProgressRoot = root2;
        nextEffect = finishedWork;
        commitLayoutEffects_begin(finishedWork, root2, committedLanes);
        inProgressLanes = null;
        inProgressRoot = null;
      }
      function commitLayoutEffects_begin(subtreeRoot, root2, committedLanes) {
        var isModernRoot = (subtreeRoot.mode & ConcurrentMode) !== NoMode;
        while (nextEffect !== null) {
          var fiber = nextEffect;
          var firstChild = fiber.child;
          if (fiber.tag === OffscreenComponent && isModernRoot) {
            var isHidden = fiber.memoizedState !== null;
            var newOffscreenSubtreeIsHidden = isHidden || offscreenSubtreeIsHidden;
            if (newOffscreenSubtreeIsHidden) {
              commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);
              continue;
            } else {
              var current2 = fiber.alternate;
              var wasHidden = current2 !== null && current2.memoizedState !== null;
              var newOffscreenSubtreeWasHidden = wasHidden || offscreenSubtreeWasHidden;
              var prevOffscreenSubtreeIsHidden = offscreenSubtreeIsHidden;
              var prevOffscreenSubtreeWasHidden = offscreenSubtreeWasHidden;
              offscreenSubtreeIsHidden = newOffscreenSubtreeIsHidden;
              offscreenSubtreeWasHidden = newOffscreenSubtreeWasHidden;
              if (offscreenSubtreeWasHidden && !prevOffscreenSubtreeWasHidden) {
                nextEffect = fiber;
                reappearLayoutEffects_begin(fiber);
              }
              var child = firstChild;
              while (child !== null) {
                nextEffect = child;
                commitLayoutEffects_begin(child, root2, committedLanes);
                child = child.sibling;
              }
              nextEffect = fiber;
              offscreenSubtreeIsHidden = prevOffscreenSubtreeIsHidden;
              offscreenSubtreeWasHidden = prevOffscreenSubtreeWasHidden;
              commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);
              continue;
            }
          }
          if ((fiber.subtreeFlags & LayoutMask) !== NoFlags && firstChild !== null) {
            firstChild.return = fiber;
            nextEffect = firstChild;
          } else {
            commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes);
          }
        }
      }
      function commitLayoutMountEffects_complete(subtreeRoot, root2, committedLanes) {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          if ((fiber.flags & LayoutMask) !== NoFlags) {
            var current2 = fiber.alternate;
            setCurrentFiber(fiber);
            try {
              commitLayoutEffectOnFiber(root2, current2, fiber, committedLanes);
            } catch (error2) {
              captureCommitPhaseError(fiber, fiber.return, error2);
            }
            resetCurrentFiber();
          }
          if (fiber === subtreeRoot) {
            nextEffect = null;
            return;
          }
          var sibling = fiber.sibling;
          if (sibling !== null) {
            sibling.return = fiber.return;
            nextEffect = sibling;
            return;
          }
          nextEffect = fiber.return;
        }
      }
      function disappearLayoutEffects_begin(subtreeRoot) {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          var firstChild = fiber.child;
          switch (fiber.tag) {
            case FunctionComponent:
            case ForwardRef:
            case MemoComponent:
            case SimpleMemoComponent: {
              if (fiber.mode & ProfileMode) {
                try {
                  startLayoutEffectTimer();
                  commitHookEffectListUnmount(Layout, fiber, fiber.return);
                } finally {
                  recordLayoutEffectDuration(fiber);
                }
              } else {
                commitHookEffectListUnmount(Layout, fiber, fiber.return);
              }
              break;
            }
            case ClassComponent: {
              safelyDetachRef(fiber, fiber.return);
              var instance = fiber.stateNode;
              if (typeof instance.componentWillUnmount === "function") {
                safelyCallComponentWillUnmount(fiber, fiber.return, instance);
              }
              break;
            }
            case HostComponent: {
              safelyDetachRef(fiber, fiber.return);
              break;
            }
            case OffscreenComponent: {
              var isHidden = fiber.memoizedState !== null;
              if (isHidden) {
                disappearLayoutEffects_complete(subtreeRoot);
                continue;
              }
              break;
            }
          }
          if (firstChild !== null) {
            firstChild.return = fiber;
            nextEffect = firstChild;
          } else {
            disappearLayoutEffects_complete(subtreeRoot);
          }
        }
      }
      function disappearLayoutEffects_complete(subtreeRoot) {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          if (fiber === subtreeRoot) {
            nextEffect = null;
            return;
          }
          var sibling = fiber.sibling;
          if (sibling !== null) {
            sibling.return = fiber.return;
            nextEffect = sibling;
            return;
          }
          nextEffect = fiber.return;
        }
      }
      function reappearLayoutEffects_begin(subtreeRoot) {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          var firstChild = fiber.child;
          if (fiber.tag === OffscreenComponent) {
            var isHidden = fiber.memoizedState !== null;
            if (isHidden) {
              reappearLayoutEffects_complete(subtreeRoot);
              continue;
            }
          }
          if (firstChild !== null) {
            firstChild.return = fiber;
            nextEffect = firstChild;
          } else {
            reappearLayoutEffects_complete(subtreeRoot);
          }
        }
      }
      function reappearLayoutEffects_complete(subtreeRoot) {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          setCurrentFiber(fiber);
          try {
            reappearLayoutEffectsOnFiber(fiber);
          } catch (error2) {
            captureCommitPhaseError(fiber, fiber.return, error2);
          }
          resetCurrentFiber();
          if (fiber === subtreeRoot) {
            nextEffect = null;
            return;
          }
          var sibling = fiber.sibling;
          if (sibling !== null) {
            sibling.return = fiber.return;
            nextEffect = sibling;
            return;
          }
          nextEffect = fiber.return;
        }
      }
      function commitPassiveMountEffects(root2, finishedWork, committedLanes, committedTransitions) {
        nextEffect = finishedWork;
        commitPassiveMountEffects_begin(finishedWork, root2, committedLanes, committedTransitions);
      }
      function commitPassiveMountEffects_begin(subtreeRoot, root2, committedLanes, committedTransitions) {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          var firstChild = fiber.child;
          if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && firstChild !== null) {
            firstChild.return = fiber;
            nextEffect = firstChild;
          } else {
            commitPassiveMountEffects_complete(subtreeRoot, root2, committedLanes, committedTransitions);
          }
        }
      }
      function commitPassiveMountEffects_complete(subtreeRoot, root2, committedLanes, committedTransitions) {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          if ((fiber.flags & Passive) !== NoFlags) {
            setCurrentFiber(fiber);
            try {
              commitPassiveMountOnFiber(root2, fiber, committedLanes, committedTransitions);
            } catch (error2) {
              captureCommitPhaseError(fiber, fiber.return, error2);
            }
            resetCurrentFiber();
          }
          if (fiber === subtreeRoot) {
            nextEffect = null;
            return;
          }
          var sibling = fiber.sibling;
          if (sibling !== null) {
            sibling.return = fiber.return;
            nextEffect = sibling;
            return;
          }
          nextEffect = fiber.return;
        }
      }
      function commitPassiveMountOnFiber(finishedRoot, finishedWork, committedLanes, committedTransitions) {
        switch (finishedWork.tag) {
          case FunctionComponent:
          case ForwardRef:
          case SimpleMemoComponent: {
            if (finishedWork.mode & ProfileMode) {
              startPassiveEffectTimer();
              try {
                commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
              } finally {
                recordPassiveEffectDuration(finishedWork);
              }
            } else {
              commitHookEffectListMount(Passive$1 | HasEffect, finishedWork);
            }
            break;
          }
        }
      }
      function commitPassiveUnmountEffects(firstChild) {
        nextEffect = firstChild;
        commitPassiveUnmountEffects_begin();
      }
      function commitPassiveUnmountEffects_begin() {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          var child = fiber.child;
          if ((nextEffect.flags & ChildDeletion) !== NoFlags) {
            var deletions = fiber.deletions;
            if (deletions !== null) {
              for (var i = 0;i < deletions.length; i++) {
                var fiberToDelete = deletions[i];
                nextEffect = fiberToDelete;
                commitPassiveUnmountEffectsInsideOfDeletedTree_begin(fiberToDelete, fiber);
              }
              {
                var previousFiber = fiber.alternate;
                if (previousFiber !== null) {
                  var detachedChild = previousFiber.child;
                  if (detachedChild !== null) {
                    previousFiber.child = null;
                    do {
                      var detachedSibling = detachedChild.sibling;
                      detachedChild.sibling = null;
                      detachedChild = detachedSibling;
                    } while (detachedChild !== null);
                  }
                }
              }
              nextEffect = fiber;
            }
          }
          if ((fiber.subtreeFlags & PassiveMask) !== NoFlags && child !== null) {
            child.return = fiber;
            nextEffect = child;
          } else {
            commitPassiveUnmountEffects_complete();
          }
        }
      }
      function commitPassiveUnmountEffects_complete() {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          if ((fiber.flags & Passive) !== NoFlags) {
            setCurrentFiber(fiber);
            commitPassiveUnmountOnFiber(fiber);
            resetCurrentFiber();
          }
          var sibling = fiber.sibling;
          if (sibling !== null) {
            sibling.return = fiber.return;
            nextEffect = sibling;
            return;
          }
          nextEffect = fiber.return;
        }
      }
      function commitPassiveUnmountOnFiber(finishedWork) {
        switch (finishedWork.tag) {
          case FunctionComponent:
          case ForwardRef:
          case SimpleMemoComponent: {
            if (finishedWork.mode & ProfileMode) {
              startPassiveEffectTimer();
              commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
              recordPassiveEffectDuration(finishedWork);
            } else {
              commitHookEffectListUnmount(Passive$1 | HasEffect, finishedWork, finishedWork.return);
            }
            break;
          }
        }
      }
      function commitPassiveUnmountEffectsInsideOfDeletedTree_begin(deletedSubtreeRoot, nearestMountedAncestor) {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          setCurrentFiber(fiber);
          commitPassiveUnmountInsideDeletedTreeOnFiber(fiber, nearestMountedAncestor);
          resetCurrentFiber();
          var child = fiber.child;
          if (child !== null) {
            child.return = fiber;
            nextEffect = child;
          } else {
            commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot);
          }
        }
      }
      function commitPassiveUnmountEffectsInsideOfDeletedTree_complete(deletedSubtreeRoot) {
        while (nextEffect !== null) {
          var fiber = nextEffect;
          var sibling = fiber.sibling;
          var returnFiber = fiber.return;
          {
            detachFiberAfterEffects(fiber);
            if (fiber === deletedSubtreeRoot) {
              nextEffect = null;
              return;
            }
          }
          if (sibling !== null) {
            sibling.return = returnFiber;
            nextEffect = sibling;
            return;
          }
          nextEffect = returnFiber;
        }
      }
      function commitPassiveUnmountInsideDeletedTreeOnFiber(current2, nearestMountedAncestor) {
        switch (current2.tag) {
          case FunctionComponent:
          case ForwardRef:
          case SimpleMemoComponent: {
            if (current2.mode & ProfileMode) {
              startPassiveEffectTimer();
              commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);
              recordPassiveEffectDuration(current2);
            } else {
              commitHookEffectListUnmount(Passive$1, current2, nearestMountedAncestor);
            }
            break;
          }
        }
      }
      function invokeLayoutEffectMountInDEV(fiber) {
        {
          switch (fiber.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              try {
                commitHookEffectListMount(Layout | HasEffect, fiber);
              } catch (error2) {
                captureCommitPhaseError(fiber, fiber.return, error2);
              }
              break;
            }
            case ClassComponent: {
              var instance = fiber.stateNode;
              try {
                instance.componentDidMount();
              } catch (error2) {
                captureCommitPhaseError(fiber, fiber.return, error2);
              }
              break;
            }
          }
        }
      }
      function invokePassiveEffectMountInDEV(fiber) {
        {
          switch (fiber.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              try {
                commitHookEffectListMount(Passive$1 | HasEffect, fiber);
              } catch (error2) {
                captureCommitPhaseError(fiber, fiber.return, error2);
              }
              break;
            }
          }
        }
      }
      function invokeLayoutEffectUnmountInDEV(fiber) {
        {
          switch (fiber.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              try {
                commitHookEffectListUnmount(Layout | HasEffect, fiber, fiber.return);
              } catch (error2) {
                captureCommitPhaseError(fiber, fiber.return, error2);
              }
              break;
            }
            case ClassComponent: {
              var instance = fiber.stateNode;
              if (typeof instance.componentWillUnmount === "function") {
                safelyCallComponentWillUnmount(fiber, fiber.return, instance);
              }
              break;
            }
          }
        }
      }
      function invokePassiveEffectUnmountInDEV(fiber) {
        {
          switch (fiber.tag) {
            case FunctionComponent:
            case ForwardRef:
            case SimpleMemoComponent: {
              try {
                commitHookEffectListUnmount(Passive$1 | HasEffect, fiber, fiber.return);
              } catch (error2) {
                captureCommitPhaseError(fiber, fiber.return, error2);
              }
            }
          }
        }
      }
      var COMPONENT_TYPE = 0;
      var HAS_PSEUDO_CLASS_TYPE = 1;
      var ROLE_TYPE = 2;
      var TEST_NAME_TYPE = 3;
      var TEXT_TYPE = 4;
      if (typeof Symbol === "function" && Symbol.for) {
        var symbolFor = Symbol.for;
        COMPONENT_TYPE = symbolFor("selector.component");
        HAS_PSEUDO_CLASS_TYPE = symbolFor("selector.has_pseudo_class");
        ROLE_TYPE = symbolFor("selector.role");
        TEST_NAME_TYPE = symbolFor("selector.test_id");
        TEXT_TYPE = symbolFor("selector.text");
      }
      var commitHooks = [];
      function onCommitRoot$1() {
        {
          commitHooks.forEach(function(commitHook) {
            return commitHook();
          });
        }
      }
      var ReactCurrentActQueue = ReactSharedInternals.ReactCurrentActQueue;
      function isLegacyActEnvironment(fiber) {
        {
          var isReactActEnvironmentGlobal = typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : undefined;
          var jestIsDefined = typeof jest !== "undefined";
          return jestIsDefined && isReactActEnvironmentGlobal !== false;
        }
      }
      function isConcurrentActEnvironment() {
        {
          var isReactActEnvironmentGlobal = typeof IS_REACT_ACT_ENVIRONMENT !== "undefined" ? IS_REACT_ACT_ENVIRONMENT : undefined;
          if (!isReactActEnvironmentGlobal && ReactCurrentActQueue.current !== null) {
            error("The current testing environment is not configured to support " + "act(...)");
          }
          return isReactActEnvironmentGlobal;
        }
      }
      var ceil = Math.ceil;
      var { ReactCurrentDispatcher: ReactCurrentDispatcher$2, ReactCurrentOwner: ReactCurrentOwner$2, ReactCurrentBatchConfig: ReactCurrentBatchConfig$3, ReactCurrentActQueue: ReactCurrentActQueue$1 } = ReactSharedInternals;
      var NoContext = 0;
      var BatchedContext = 1;
      var RenderContext = 2;
      var CommitContext = 4;
      var RootInProgress = 0;
      var RootFatalErrored = 1;
      var RootErrored = 2;
      var RootSuspended = 3;
      var RootSuspendedWithDelay = 4;
      var RootCompleted = 5;
      var RootDidNotComplete = 6;
      var executionContext = NoContext;
      var workInProgressRoot = null;
      var workInProgress = null;
      var workInProgressRootRenderLanes = NoLanes;
      var subtreeRenderLanes = NoLanes;
      var subtreeRenderLanesCursor = createCursor(NoLanes);
      var workInProgressRootExitStatus = RootInProgress;
      var workInProgressRootFatalError = null;
      var workInProgressRootIncludedLanes = NoLanes;
      var workInProgressRootSkippedLanes = NoLanes;
      var workInProgressRootInterleavedUpdatedLanes = NoLanes;
      var workInProgressRootPingedLanes = NoLanes;
      var workInProgressRootConcurrentErrors = null;
      var workInProgressRootRecoverableErrors = null;
      var globalMostRecentFallbackTime = 0;
      var FALLBACK_THROTTLE_MS = 500;
      var workInProgressRootRenderTargetTime = Infinity;
      var RENDER_TIMEOUT_MS = 500;
      var workInProgressTransitions = null;
      function resetRenderTimer() {
        workInProgressRootRenderTargetTime = now() + RENDER_TIMEOUT_MS;
      }
      function getRenderTargetTime() {
        return workInProgressRootRenderTargetTime;
      }
      var hasUncaughtError = false;
      var firstUncaughtError = null;
      var legacyErrorBoundariesThatAlreadyFailed = null;
      var rootDoesHavePassiveEffects = false;
      var rootWithPendingPassiveEffects = null;
      var pendingPassiveEffectsLanes = NoLanes;
      var pendingPassiveProfilerEffects = [];
      var pendingPassiveTransitions = null;
      var NESTED_UPDATE_LIMIT = 50;
      var nestedUpdateCount = 0;
      var rootWithNestedUpdates = null;
      var isFlushingPassiveEffects = false;
      var didScheduleUpdateDuringPassiveEffects = false;
      var NESTED_PASSIVE_UPDATE_LIMIT = 50;
      var nestedPassiveUpdateCount = 0;
      var rootWithPassiveNestedUpdates = null;
      var currentEventTime = NoTimestamp;
      var currentEventTransitionLane = NoLanes;
      var isRunningInsertionEffect = false;
      function getWorkInProgressRoot() {
        return workInProgressRoot;
      }
      function requestEventTime() {
        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
          return now();
        }
        if (currentEventTime !== NoTimestamp) {
          return currentEventTime;
        }
        currentEventTime = now();
        return currentEventTime;
      }
      function requestUpdateLane(fiber) {
        var mode = fiber.mode;
        if ((mode & ConcurrentMode) === NoMode) {
          return SyncLane;
        } else if ((executionContext & RenderContext) !== NoContext && workInProgressRootRenderLanes !== NoLanes) {
          return pickArbitraryLane(workInProgressRootRenderLanes);
        }
        var isTransition = requestCurrentTransition() !== NoTransition;
        if (isTransition) {
          if (ReactCurrentBatchConfig$3.transition !== null) {
            var transition = ReactCurrentBatchConfig$3.transition;
            if (!transition._updatedFibers) {
              transition._updatedFibers = new Set;
            }
            transition._updatedFibers.add(fiber);
          }
          if (currentEventTransitionLane === NoLane) {
            currentEventTransitionLane = claimNextTransitionLane();
          }
          return currentEventTransitionLane;
        }
        var updateLane = getCurrentUpdatePriority();
        if (updateLane !== NoLane) {
          return updateLane;
        }
        var eventLane = getCurrentEventPriority();
        return eventLane;
      }
      function requestRetryLane(fiber) {
        var mode = fiber.mode;
        if ((mode & ConcurrentMode) === NoMode) {
          return SyncLane;
        }
        return claimNextRetryLane();
      }
      function scheduleUpdateOnFiber(root2, fiber, lane, eventTime) {
        checkForNestedUpdates();
        {
          if (isRunningInsertionEffect) {
            error("useInsertionEffect must not schedule updates.");
          }
        }
        {
          if (isFlushingPassiveEffects) {
            didScheduleUpdateDuringPassiveEffects = true;
          }
        }
        markRootUpdated(root2, lane, eventTime);
        if ((executionContext & RenderContext) !== NoLanes && root2 === workInProgressRoot) {
          warnAboutRenderPhaseUpdatesInDEV(fiber);
        } else {
          {
            if (isDevToolsPresent) {
              addFiberToLanesMap(root2, fiber, lane);
            }
          }
          warnIfUpdatesNotWrappedWithActDEV(fiber);
          if (root2 === workInProgressRoot) {
            if ((executionContext & RenderContext) === NoContext) {
              workInProgressRootInterleavedUpdatedLanes = mergeLanes(workInProgressRootInterleavedUpdatedLanes, lane);
            }
            if (workInProgressRootExitStatus === RootSuspendedWithDelay) {
              markRootSuspended$1(root2, workInProgressRootRenderLanes);
            }
          }
          ensureRootIsScheduled(root2, eventTime);
          if (lane === SyncLane && executionContext === NoContext && (fiber.mode & ConcurrentMode) === NoMode && !ReactCurrentActQueue$1.isBatchingLegacy) {
            resetRenderTimer();
            flushSyncCallbacksOnlyInLegacyMode();
          }
        }
      }
      function scheduleInitialHydrationOnRoot(root2, lane, eventTime) {
        var current2 = root2.current;
        current2.lanes = lane;
        markRootUpdated(root2, lane, eventTime);
        ensureRootIsScheduled(root2, eventTime);
      }
      function isUnsafeClassRenderPhaseUpdate(fiber) {
        return (executionContext & RenderContext) !== NoContext;
      }
      function ensureRootIsScheduled(root2, currentTime) {
        var existingCallbackNode = root2.callbackNode;
        markStarvedLanesAsExpired(root2, currentTime);
        var nextLanes = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
        if (nextLanes === NoLanes) {
          if (existingCallbackNode !== null) {
            cancelCallback$1(existingCallbackNode);
          }
          root2.callbackNode = null;
          root2.callbackPriority = NoLane;
          return;
        }
        var newCallbackPriority = getHighestPriorityLane(nextLanes);
        var existingCallbackPriority = root2.callbackPriority;
        if (existingCallbackPriority === newCallbackPriority && !(ReactCurrentActQueue$1.current !== null && existingCallbackNode !== fakeActCallbackNode)) {
          {
            if (existingCallbackNode == null && existingCallbackPriority !== SyncLane) {
              error("Expected scheduled callback to exist. This error is likely caused by a bug in React. Please file an issue.");
            }
          }
          return;
        }
        if (existingCallbackNode != null) {
          cancelCallback$1(existingCallbackNode);
        }
        var newCallbackNode;
        if (newCallbackPriority === SyncLane) {
          if (root2.tag === LegacyRoot) {
            if (ReactCurrentActQueue$1.isBatchingLegacy !== null) {
              ReactCurrentActQueue$1.didScheduleLegacyUpdate = true;
            }
            scheduleLegacySyncCallback(performSyncWorkOnRoot.bind(null, root2));
          } else {
            scheduleSyncCallback(performSyncWorkOnRoot.bind(null, root2));
          }
          {
            if (ReactCurrentActQueue$1.current !== null) {
              ReactCurrentActQueue$1.current.push(flushSyncCallbacks);
            } else {
              scheduleMicrotask(function() {
                if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
                  flushSyncCallbacks();
                }
              });
            }
          }
          newCallbackNode = null;
        } else {
          var schedulerPriorityLevel;
          switch (lanesToEventPriority(nextLanes)) {
            case DiscreteEventPriority:
              schedulerPriorityLevel = ImmediatePriority;
              break;
            case ContinuousEventPriority:
              schedulerPriorityLevel = UserBlockingPriority;
              break;
            case DefaultEventPriority:
              schedulerPriorityLevel = NormalPriority;
              break;
            case IdleEventPriority:
              schedulerPriorityLevel = IdlePriority;
              break;
            default:
              schedulerPriorityLevel = NormalPriority;
              break;
          }
          newCallbackNode = scheduleCallback$1(schedulerPriorityLevel, performConcurrentWorkOnRoot.bind(null, root2));
        }
        root2.callbackPriority = newCallbackPriority;
        root2.callbackNode = newCallbackNode;
      }
      function performConcurrentWorkOnRoot(root2, didTimeout) {
        {
          resetNestedUpdateFlag();
        }
        currentEventTime = NoTimestamp;
        currentEventTransitionLane = NoLanes;
        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
          throw new Error("Should not already be working.");
        }
        var originalCallbackNode = root2.callbackNode;
        var didFlushPassiveEffects = flushPassiveEffects();
        if (didFlushPassiveEffects) {
          if (root2.callbackNode !== originalCallbackNode) {
            return null;
          }
        }
        var lanes = getNextLanes(root2, root2 === workInProgressRoot ? workInProgressRootRenderLanes : NoLanes);
        if (lanes === NoLanes) {
          return null;
        }
        var shouldTimeSlice = !includesBlockingLane(root2, lanes) && !includesExpiredLane(root2, lanes) && !didTimeout;
        var exitStatus = shouldTimeSlice ? renderRootConcurrent(root2, lanes) : renderRootSync(root2, lanes);
        if (exitStatus !== RootInProgress) {
          if (exitStatus === RootErrored) {
            var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);
            if (errorRetryLanes !== NoLanes) {
              lanes = errorRetryLanes;
              exitStatus = recoverFromConcurrentError(root2, errorRetryLanes);
            }
          }
          if (exitStatus === RootFatalErrored) {
            var fatalError = workInProgressRootFatalError;
            prepareFreshStack(root2, NoLanes);
            markRootSuspended$1(root2, lanes);
            ensureRootIsScheduled(root2, now());
            throw fatalError;
          }
          if (exitStatus === RootDidNotComplete) {
            markRootSuspended$1(root2, lanes);
          } else {
            var renderWasConcurrent = !includesBlockingLane(root2, lanes);
            var finishedWork = root2.current.alternate;
            if (renderWasConcurrent && !isRenderConsistentWithExternalStores(finishedWork)) {
              exitStatus = renderRootSync(root2, lanes);
              if (exitStatus === RootErrored) {
                var _errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);
                if (_errorRetryLanes !== NoLanes) {
                  lanes = _errorRetryLanes;
                  exitStatus = recoverFromConcurrentError(root2, _errorRetryLanes);
                }
              }
              if (exitStatus === RootFatalErrored) {
                var _fatalError = workInProgressRootFatalError;
                prepareFreshStack(root2, NoLanes);
                markRootSuspended$1(root2, lanes);
                ensureRootIsScheduled(root2, now());
                throw _fatalError;
              }
            }
            root2.finishedWork = finishedWork;
            root2.finishedLanes = lanes;
            finishConcurrentRender(root2, exitStatus, lanes);
          }
        }
        ensureRootIsScheduled(root2, now());
        if (root2.callbackNode === originalCallbackNode) {
          return performConcurrentWorkOnRoot.bind(null, root2);
        }
        return null;
      }
      function recoverFromConcurrentError(root2, errorRetryLanes) {
        var errorsFromFirstAttempt = workInProgressRootConcurrentErrors;
        if (isRootDehydrated(root2)) {
          var rootWorkInProgress = prepareFreshStack(root2, errorRetryLanes);
          rootWorkInProgress.flags |= ForceClientRender;
          {
            errorHydratingContainer(root2.containerInfo);
          }
        }
        var exitStatus = renderRootSync(root2, errorRetryLanes);
        if (exitStatus !== RootErrored) {
          var errorsFromSecondAttempt = workInProgressRootRecoverableErrors;
          workInProgressRootRecoverableErrors = errorsFromFirstAttempt;
          if (errorsFromSecondAttempt !== null) {
            queueRecoverableErrors(errorsFromSecondAttempt);
          }
        }
        return exitStatus;
      }
      function queueRecoverableErrors(errors) {
        if (workInProgressRootRecoverableErrors === null) {
          workInProgressRootRecoverableErrors = errors;
        } else {
          workInProgressRootRecoverableErrors.push.apply(workInProgressRootRecoverableErrors, errors);
        }
      }
      function finishConcurrentRender(root2, exitStatus, lanes) {
        switch (exitStatus) {
          case RootInProgress:
          case RootFatalErrored: {
            throw new Error("Root did not complete. This is a bug in React.");
          }
          case RootErrored: {
            commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
            break;
          }
          case RootSuspended: {
            markRootSuspended$1(root2, lanes);
            if (includesOnlyRetries(lanes) && !shouldForceFlushFallbacksInDEV()) {
              var msUntilTimeout = globalMostRecentFallbackTime + FALLBACK_THROTTLE_MS - now();
              if (msUntilTimeout > 10) {
                var nextLanes = getNextLanes(root2, NoLanes);
                if (nextLanes !== NoLanes) {
                  break;
                }
                var suspendedLanes = root2.suspendedLanes;
                if (!isSubsetOfLanes(suspendedLanes, lanes)) {
                  var eventTime = requestEventTime();
                  markRootPinged(root2, suspendedLanes);
                  break;
                }
                root2.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root2, workInProgressRootRecoverableErrors, workInProgressTransitions), msUntilTimeout);
                break;
              }
            }
            commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
            break;
          }
          case RootSuspendedWithDelay: {
            markRootSuspended$1(root2, lanes);
            if (includesOnlyTransitions(lanes)) {
              break;
            }
            if (!shouldForceFlushFallbacksInDEV()) {
              var mostRecentEventTime = getMostRecentEventTime(root2, lanes);
              var eventTimeMs = mostRecentEventTime;
              var timeElapsedMs = now() - eventTimeMs;
              var _msUntilTimeout = jnd(timeElapsedMs) - timeElapsedMs;
              if (_msUntilTimeout > 10) {
                root2.timeoutHandle = scheduleTimeout(commitRoot.bind(null, root2, workInProgressRootRecoverableErrors, workInProgressTransitions), _msUntilTimeout);
                break;
              }
            }
            commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
            break;
          }
          case RootCompleted: {
            commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
            break;
          }
          default: {
            throw new Error("Unknown root exit status.");
          }
        }
      }
      function isRenderConsistentWithExternalStores(finishedWork) {
        var node = finishedWork;
        while (true) {
          if (node.flags & StoreConsistency) {
            var updateQueue = node.updateQueue;
            if (updateQueue !== null) {
              var checks = updateQueue.stores;
              if (checks !== null) {
                for (var i = 0;i < checks.length; i++) {
                  var check = checks[i];
                  var getSnapshot = check.getSnapshot;
                  var renderedValue = check.value;
                  try {
                    if (!objectIs(getSnapshot(), renderedValue)) {
                      return false;
                    }
                  } catch (error2) {
                    return false;
                  }
                }
              }
            }
          }
          var child = node.child;
          if (node.subtreeFlags & StoreConsistency && child !== null) {
            child.return = node;
            node = child;
            continue;
          }
          if (node === finishedWork) {
            return true;
          }
          while (node.sibling === null) {
            if (node.return === null || node.return === finishedWork) {
              return true;
            }
            node = node.return;
          }
          node.sibling.return = node.return;
          node = node.sibling;
        }
        return true;
      }
      function markRootSuspended$1(root2, suspendedLanes) {
        suspendedLanes = removeLanes(suspendedLanes, workInProgressRootPingedLanes);
        suspendedLanes = removeLanes(suspendedLanes, workInProgressRootInterleavedUpdatedLanes);
        markRootSuspended(root2, suspendedLanes);
      }
      function performSyncWorkOnRoot(root2) {
        {
          syncNestedUpdateFlag();
        }
        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
          throw new Error("Should not already be working.");
        }
        flushPassiveEffects();
        var lanes = getNextLanes(root2, NoLanes);
        if (!includesSomeLane(lanes, SyncLane)) {
          ensureRootIsScheduled(root2, now());
          return null;
        }
        var exitStatus = renderRootSync(root2, lanes);
        if (root2.tag !== LegacyRoot && exitStatus === RootErrored) {
          var errorRetryLanes = getLanesToRetrySynchronouslyOnError(root2);
          if (errorRetryLanes !== NoLanes) {
            lanes = errorRetryLanes;
            exitStatus = recoverFromConcurrentError(root2, errorRetryLanes);
          }
        }
        if (exitStatus === RootFatalErrored) {
          var fatalError = workInProgressRootFatalError;
          prepareFreshStack(root2, NoLanes);
          markRootSuspended$1(root2, lanes);
          ensureRootIsScheduled(root2, now());
          throw fatalError;
        }
        if (exitStatus === RootDidNotComplete) {
          throw new Error("Root did not complete. This is a bug in React.");
        }
        var finishedWork = root2.current.alternate;
        root2.finishedWork = finishedWork;
        root2.finishedLanes = lanes;
        commitRoot(root2, workInProgressRootRecoverableErrors, workInProgressTransitions);
        ensureRootIsScheduled(root2, now());
        return null;
      }
      function flushRoot(root2, lanes) {
        if (lanes !== NoLanes) {
          markRootEntangled(root2, mergeLanes(lanes, SyncLane));
          ensureRootIsScheduled(root2, now());
          if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
            resetRenderTimer();
            flushSyncCallbacks();
          }
        }
      }
      function batchedUpdates$1(fn, a) {
        var prevExecutionContext = executionContext;
        executionContext |= BatchedContext;
        try {
          return fn(a);
        } finally {
          executionContext = prevExecutionContext;
          if (executionContext === NoContext && !ReactCurrentActQueue$1.isBatchingLegacy) {
            resetRenderTimer();
            flushSyncCallbacksOnlyInLegacyMode();
          }
        }
      }
      function discreteUpdates(fn, a, b, c, d) {
        var previousPriority = getCurrentUpdatePriority();
        var prevTransition = ReactCurrentBatchConfig$3.transition;
        try {
          ReactCurrentBatchConfig$3.transition = null;
          setCurrentUpdatePriority(DiscreteEventPriority);
          return fn(a, b, c, d);
        } finally {
          setCurrentUpdatePriority(previousPriority);
          ReactCurrentBatchConfig$3.transition = prevTransition;
          if (executionContext === NoContext) {
            resetRenderTimer();
          }
        }
      }
      function flushSync(fn) {
        if (rootWithPendingPassiveEffects !== null && rootWithPendingPassiveEffects.tag === LegacyRoot && (executionContext & (RenderContext | CommitContext)) === NoContext) {
          flushPassiveEffects();
        }
        var prevExecutionContext = executionContext;
        executionContext |= BatchedContext;
        var prevTransition = ReactCurrentBatchConfig$3.transition;
        var previousPriority = getCurrentUpdatePriority();
        try {
          ReactCurrentBatchConfig$3.transition = null;
          setCurrentUpdatePriority(DiscreteEventPriority);
          if (fn) {
            return fn();
          } else {
            return;
          }
        } finally {
          setCurrentUpdatePriority(previousPriority);
          ReactCurrentBatchConfig$3.transition = prevTransition;
          executionContext = prevExecutionContext;
          if ((executionContext & (RenderContext | CommitContext)) === NoContext) {
            flushSyncCallbacks();
          }
        }
      }
      function isAlreadyRendering() {
        return (executionContext & (RenderContext | CommitContext)) !== NoContext;
      }
      function pushRenderLanes(fiber, lanes) {
        push(subtreeRenderLanesCursor, subtreeRenderLanes, fiber);
        subtreeRenderLanes = mergeLanes(subtreeRenderLanes, lanes);
        workInProgressRootIncludedLanes = mergeLanes(workInProgressRootIncludedLanes, lanes);
      }
      function popRenderLanes(fiber) {
        subtreeRenderLanes = subtreeRenderLanesCursor.current;
        pop(subtreeRenderLanesCursor, fiber);
      }
      function prepareFreshStack(root2, lanes) {
        root2.finishedWork = null;
        root2.finishedLanes = NoLanes;
        var timeoutHandle = root2.timeoutHandle;
        if (timeoutHandle !== noTimeout) {
          root2.timeoutHandle = noTimeout;
          cancelTimeout(timeoutHandle);
        }
        if (workInProgress !== null) {
          var interruptedWork = workInProgress.return;
          while (interruptedWork !== null) {
            var current2 = interruptedWork.alternate;
            unwindInterruptedWork(current2, interruptedWork);
            interruptedWork = interruptedWork.return;
          }
        }
        workInProgressRoot = root2;
        var rootWorkInProgress = createWorkInProgress(root2.current, null);
        workInProgress = rootWorkInProgress;
        workInProgressRootRenderLanes = subtreeRenderLanes = workInProgressRootIncludedLanes = lanes;
        workInProgressRootExitStatus = RootInProgress;
        workInProgressRootFatalError = null;
        workInProgressRootSkippedLanes = NoLanes;
        workInProgressRootInterleavedUpdatedLanes = NoLanes;
        workInProgressRootPingedLanes = NoLanes;
        workInProgressRootConcurrentErrors = null;
        workInProgressRootRecoverableErrors = null;
        finishQueueingConcurrentUpdates();
        {
          ReactStrictModeWarnings.discardPendingWarnings();
        }
        return rootWorkInProgress;
      }
      function handleError(root2, thrownValue) {
        do {
          var erroredWork = workInProgress;
          try {
            resetContextDependencies();
            resetHooksAfterThrow();
            resetCurrentFiber();
            ReactCurrentOwner$2.current = null;
            if (erroredWork === null || erroredWork.return === null) {
              workInProgressRootExitStatus = RootFatalErrored;
              workInProgressRootFatalError = thrownValue;
              workInProgress = null;
              return;
            }
            if (enableProfilerTimer && erroredWork.mode & ProfileMode) {
              stopProfilerTimerIfRunningAndRecordDelta(erroredWork, true);
            }
            if (enableSchedulingProfiler) {
              markComponentRenderStopped();
              if (thrownValue !== null && typeof thrownValue === "object" && typeof thrownValue.then === "function") {
                var wakeable = thrownValue;
                markComponentSuspended(erroredWork, wakeable, workInProgressRootRenderLanes);
              } else {
                markComponentErrored(erroredWork, thrownValue, workInProgressRootRenderLanes);
              }
            }
            throwException(root2, erroredWork.return, erroredWork, thrownValue, workInProgressRootRenderLanes);
            completeUnitOfWork(erroredWork);
          } catch (yetAnotherThrownValue) {
            thrownValue = yetAnotherThrownValue;
            if (workInProgress === erroredWork && erroredWork !== null) {
              erroredWork = erroredWork.return;
              workInProgress = erroredWork;
            } else {
              erroredWork = workInProgress;
            }
            continue;
          }
          return;
        } while (true);
      }
      function pushDispatcher() {
        var prevDispatcher = ReactCurrentDispatcher$2.current;
        ReactCurrentDispatcher$2.current = ContextOnlyDispatcher;
        if (prevDispatcher === null) {
          return ContextOnlyDispatcher;
        } else {
          return prevDispatcher;
        }
      }
      function popDispatcher(prevDispatcher) {
        ReactCurrentDispatcher$2.current = prevDispatcher;
      }
      function markCommitTimeOfFallback() {
        globalMostRecentFallbackTime = now();
      }
      function markSkippedUpdateLanes(lane) {
        workInProgressRootSkippedLanes = mergeLanes(lane, workInProgressRootSkippedLanes);
      }
      function renderDidSuspend() {
        if (workInProgressRootExitStatus === RootInProgress) {
          workInProgressRootExitStatus = RootSuspended;
        }
      }
      function renderDidSuspendDelayIfPossible() {
        if (workInProgressRootExitStatus === RootInProgress || workInProgressRootExitStatus === RootSuspended || workInProgressRootExitStatus === RootErrored) {
          workInProgressRootExitStatus = RootSuspendedWithDelay;
        }
        if (workInProgressRoot !== null && (includesNonIdleWork(workInProgressRootSkippedLanes) || includesNonIdleWork(workInProgressRootInterleavedUpdatedLanes))) {
          markRootSuspended$1(workInProgressRoot, workInProgressRootRenderLanes);
        }
      }
      function renderDidError(error2) {
        if (workInProgressRootExitStatus !== RootSuspendedWithDelay) {
          workInProgressRootExitStatus = RootErrored;
        }
        if (workInProgressRootConcurrentErrors === null) {
          workInProgressRootConcurrentErrors = [error2];
        } else {
          workInProgressRootConcurrentErrors.push(error2);
        }
      }
      function renderHasNotSuspendedYet() {
        return workInProgressRootExitStatus === RootInProgress;
      }
      function renderRootSync(root2, lanes) {
        var prevExecutionContext = executionContext;
        executionContext |= RenderContext;
        var prevDispatcher = pushDispatcher();
        if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
          {
            if (isDevToolsPresent) {
              var memoizedUpdaters = root2.memoizedUpdaters;
              if (memoizedUpdaters.size > 0) {
                restorePendingUpdaters(root2, workInProgressRootRenderLanes);
                memoizedUpdaters.clear();
              }
              movePendingFibersToMemoized(root2, lanes);
            }
          }
          workInProgressTransitions = getTransitionsForLanes();
          prepareFreshStack(root2, lanes);
        }
        {
          markRenderStarted(lanes);
        }
        do {
          try {
            workLoopSync();
            break;
          } catch (thrownValue) {
            handleError(root2, thrownValue);
          }
        } while (true);
        resetContextDependencies();
        executionContext = prevExecutionContext;
        popDispatcher(prevDispatcher);
        if (workInProgress !== null) {
          throw new Error("Cannot commit an incomplete root. This error is likely caused by a " + "bug in React. Please file an issue.");
        }
        {
          markRenderStopped();
        }
        workInProgressRoot = null;
        workInProgressRootRenderLanes = NoLanes;
        return workInProgressRootExitStatus;
      }
      function workLoopSync() {
        while (workInProgress !== null) {
          performUnitOfWork(workInProgress);
        }
      }
      function renderRootConcurrent(root2, lanes) {
        var prevExecutionContext = executionContext;
        executionContext |= RenderContext;
        var prevDispatcher = pushDispatcher();
        if (workInProgressRoot !== root2 || workInProgressRootRenderLanes !== lanes) {
          {
            if (isDevToolsPresent) {
              var memoizedUpdaters = root2.memoizedUpdaters;
              if (memoizedUpdaters.size > 0) {
                restorePendingUpdaters(root2, workInProgressRootRenderLanes);
                memoizedUpdaters.clear();
              }
              movePendingFibersToMemoized(root2, lanes);
            }
          }
          workInProgressTransitions = getTransitionsForLanes();
          resetRenderTimer();
          prepareFreshStack(root2, lanes);
        }
        {
          markRenderStarted(lanes);
        }
        do {
          try {
            workLoopConcurrent();
            break;
          } catch (thrownValue) {
            handleError(root2, thrownValue);
          }
        } while (true);
        resetContextDependencies();
        popDispatcher(prevDispatcher);
        executionContext = prevExecutionContext;
        if (workInProgress !== null) {
          {
            markRenderYielded();
          }
          return RootInProgress;
        } else {
          {
            markRenderStopped();
          }
          workInProgressRoot = null;
          workInProgressRootRenderLanes = NoLanes;
          return workInProgressRootExitStatus;
        }
      }
      function workLoopConcurrent() {
        while (workInProgress !== null && !shouldYield()) {
          performUnitOfWork(workInProgress);
        }
      }
      function performUnitOfWork(unitOfWork) {
        var current2 = unitOfWork.alternate;
        setCurrentFiber(unitOfWork);
        var next;
        if ((unitOfWork.mode & ProfileMode) !== NoMode) {
          startProfilerTimer(unitOfWork);
          next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
          stopProfilerTimerIfRunningAndRecordDelta(unitOfWork, true);
        } else {
          next = beginWork$1(current2, unitOfWork, subtreeRenderLanes);
        }
        resetCurrentFiber();
        unitOfWork.memoizedProps = unitOfWork.pendingProps;
        if (next === null) {
          completeUnitOfWork(unitOfWork);
        } else {
          workInProgress = next;
        }
        ReactCurrentOwner$2.current = null;
      }
      function completeUnitOfWork(unitOfWork) {
        var completedWork = unitOfWork;
        do {
          var current2 = completedWork.alternate;
          var returnFiber = completedWork.return;
          if ((completedWork.flags & Incomplete) === NoFlags) {
            setCurrentFiber(completedWork);
            var next = undefined;
            if ((completedWork.mode & ProfileMode) === NoMode) {
              next = completeWork(current2, completedWork, subtreeRenderLanes);
            } else {
              startProfilerTimer(completedWork);
              next = completeWork(current2, completedWork, subtreeRenderLanes);
              stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
            }
            resetCurrentFiber();
            if (next !== null) {
              workInProgress = next;
              return;
            }
          } else {
            var _next = unwindWork(current2, completedWork);
            if (_next !== null) {
              _next.flags &= HostEffectMask;
              workInProgress = _next;
              return;
            }
            if ((completedWork.mode & ProfileMode) !== NoMode) {
              stopProfilerTimerIfRunningAndRecordDelta(completedWork, false);
              var actualDuration = completedWork.actualDuration;
              var child = completedWork.child;
              while (child !== null) {
                actualDuration += child.actualDuration;
                child = child.sibling;
              }
              completedWork.actualDuration = actualDuration;
            }
            if (returnFiber !== null) {
              returnFiber.flags |= Incomplete;
              returnFiber.subtreeFlags = NoFlags;
              returnFiber.deletions = null;
            } else {
              workInProgressRootExitStatus = RootDidNotComplete;
              workInProgress = null;
              return;
            }
          }
          var siblingFiber = completedWork.sibling;
          if (siblingFiber !== null) {
            workInProgress = siblingFiber;
            return;
          }
          completedWork = returnFiber;
          workInProgress = completedWork;
        } while (completedWork !== null);
        if (workInProgressRootExitStatus === RootInProgress) {
          workInProgressRootExitStatus = RootCompleted;
        }
      }
      function commitRoot(root2, recoverableErrors, transitions) {
        var previousUpdateLanePriority = getCurrentUpdatePriority();
        var prevTransition = ReactCurrentBatchConfig$3.transition;
        try {
          ReactCurrentBatchConfig$3.transition = null;
          setCurrentUpdatePriority(DiscreteEventPriority);
          commitRootImpl(root2, recoverableErrors, transitions, previousUpdateLanePriority);
        } finally {
          ReactCurrentBatchConfig$3.transition = prevTransition;
          setCurrentUpdatePriority(previousUpdateLanePriority);
        }
        return null;
      }
      function commitRootImpl(root2, recoverableErrors, transitions, renderPriorityLevel) {
        do {
          flushPassiveEffects();
        } while (rootWithPendingPassiveEffects !== null);
        flushRenderPhaseStrictModeWarningsInDEV();
        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
          throw new Error("Should not already be working.");
        }
        var finishedWork = root2.finishedWork;
        var lanes = root2.finishedLanes;
        {
          markCommitStarted(lanes);
        }
        if (finishedWork === null) {
          {
            markCommitStopped();
          }
          return null;
        } else {
          {
            if (lanes === NoLanes) {
              error("root.finishedLanes should not be empty during a commit. This is a " + "bug in React.");
            }
          }
        }
        root2.finishedWork = null;
        root2.finishedLanes = NoLanes;
        if (finishedWork === root2.current) {
          throw new Error("Cannot commit the same tree as before. This error is likely caused by " + "a bug in React. Please file an issue.");
        }
        root2.callbackNode = null;
        root2.callbackPriority = NoLane;
        var remainingLanes = mergeLanes(finishedWork.lanes, finishedWork.childLanes);
        markRootFinished(root2, remainingLanes);
        if (root2 === workInProgressRoot) {
          workInProgressRoot = null;
          workInProgress = null;
          workInProgressRootRenderLanes = NoLanes;
        }
        if ((finishedWork.subtreeFlags & PassiveMask) !== NoFlags || (finishedWork.flags & PassiveMask) !== NoFlags) {
          if (!rootDoesHavePassiveEffects) {
            rootDoesHavePassiveEffects = true;
            pendingPassiveTransitions = transitions;
            scheduleCallback$1(NormalPriority, function() {
              flushPassiveEffects();
              return null;
            });
          }
        }
        var subtreeHasEffects = (finishedWork.subtreeFlags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
        var rootHasEffect = (finishedWork.flags & (BeforeMutationMask | MutationMask | LayoutMask | PassiveMask)) !== NoFlags;
        if (subtreeHasEffects || rootHasEffect) {
          var prevTransition = ReactCurrentBatchConfig$3.transition;
          ReactCurrentBatchConfig$3.transition = null;
          var previousPriority = getCurrentUpdatePriority();
          setCurrentUpdatePriority(DiscreteEventPriority);
          var prevExecutionContext = executionContext;
          executionContext |= CommitContext;
          ReactCurrentOwner$2.current = null;
          var shouldFireAfterActiveInstanceBlur2 = commitBeforeMutationEffects(root2, finishedWork);
          {
            recordCommitTime();
          }
          commitMutationEffects(root2, finishedWork, lanes);
          resetAfterCommit(root2.containerInfo);
          root2.current = finishedWork;
          {
            markLayoutEffectsStarted(lanes);
          }
          commitLayoutEffects(finishedWork, root2, lanes);
          {
            markLayoutEffectsStopped();
          }
          requestPaint();
          executionContext = prevExecutionContext;
          setCurrentUpdatePriority(previousPriority);
          ReactCurrentBatchConfig$3.transition = prevTransition;
        } else {
          root2.current = finishedWork;
          {
            recordCommitTime();
          }
        }
        var rootDidHavePassiveEffects = rootDoesHavePassiveEffects;
        if (rootDoesHavePassiveEffects) {
          rootDoesHavePassiveEffects = false;
          rootWithPendingPassiveEffects = root2;
          pendingPassiveEffectsLanes = lanes;
        } else {
          {
            nestedPassiveUpdateCount = 0;
            rootWithPassiveNestedUpdates = null;
          }
        }
        remainingLanes = root2.pendingLanes;
        if (remainingLanes === NoLanes) {
          legacyErrorBoundariesThatAlreadyFailed = null;
        }
        {
          if (!rootDidHavePassiveEffects) {
            commitDoubleInvokeEffectsInDEV(root2.current, false);
          }
        }
        onCommitRoot(finishedWork.stateNode, renderPriorityLevel);
        {
          if (isDevToolsPresent) {
            root2.memoizedUpdaters.clear();
          }
        }
        {
          onCommitRoot$1();
        }
        ensureRootIsScheduled(root2, now());
        if (recoverableErrors !== null) {
          var onRecoverableError = root2.onRecoverableError;
          for (var i = 0;i < recoverableErrors.length; i++) {
            var recoverableError = recoverableErrors[i];
            var componentStack = recoverableError.stack;
            var digest = recoverableError.digest;
            onRecoverableError(recoverableError.value, {
              componentStack,
              digest
            });
          }
        }
        if (hasUncaughtError) {
          hasUncaughtError = false;
          var error$1 = firstUncaughtError;
          firstUncaughtError = null;
          throw error$1;
        }
        if (includesSomeLane(pendingPassiveEffectsLanes, SyncLane) && root2.tag !== LegacyRoot) {
          flushPassiveEffects();
        }
        remainingLanes = root2.pendingLanes;
        if (includesSomeLane(remainingLanes, SyncLane)) {
          {
            markNestedUpdateScheduled();
          }
          if (root2 === rootWithNestedUpdates) {
            nestedUpdateCount++;
          } else {
            nestedUpdateCount = 0;
            rootWithNestedUpdates = root2;
          }
        } else {
          nestedUpdateCount = 0;
        }
        flushSyncCallbacks();
        {
          markCommitStopped();
        }
        return null;
      }
      function flushPassiveEffects() {
        if (rootWithPendingPassiveEffects !== null) {
          var renderPriority = lanesToEventPriority(pendingPassiveEffectsLanes);
          var priority = lowerEventPriority(DefaultEventPriority, renderPriority);
          var prevTransition = ReactCurrentBatchConfig$3.transition;
          var previousPriority = getCurrentUpdatePriority();
          try {
            ReactCurrentBatchConfig$3.transition = null;
            setCurrentUpdatePriority(priority);
            return flushPassiveEffectsImpl();
          } finally {
            setCurrentUpdatePriority(previousPriority);
            ReactCurrentBatchConfig$3.transition = prevTransition;
          }
        }
        return false;
      }
      function enqueuePendingPassiveProfilerEffect(fiber) {
        {
          pendingPassiveProfilerEffects.push(fiber);
          if (!rootDoesHavePassiveEffects) {
            rootDoesHavePassiveEffects = true;
            scheduleCallback$1(NormalPriority, function() {
              flushPassiveEffects();
              return null;
            });
          }
        }
      }
      function flushPassiveEffectsImpl() {
        if (rootWithPendingPassiveEffects === null) {
          return false;
        }
        var transitions = pendingPassiveTransitions;
        pendingPassiveTransitions = null;
        var root2 = rootWithPendingPassiveEffects;
        var lanes = pendingPassiveEffectsLanes;
        rootWithPendingPassiveEffects = null;
        pendingPassiveEffectsLanes = NoLanes;
        if ((executionContext & (RenderContext | CommitContext)) !== NoContext) {
          throw new Error("Cannot flush passive effects while already rendering.");
        }
        {
          isFlushingPassiveEffects = true;
          didScheduleUpdateDuringPassiveEffects = false;
        }
        {
          markPassiveEffectsStarted(lanes);
        }
        var prevExecutionContext = executionContext;
        executionContext |= CommitContext;
        commitPassiveUnmountEffects(root2.current);
        commitPassiveMountEffects(root2, root2.current, lanes, transitions);
        {
          var profilerEffects = pendingPassiveProfilerEffects;
          pendingPassiveProfilerEffects = [];
          for (var i = 0;i < profilerEffects.length; i++) {
            var _fiber = profilerEffects[i];
            commitPassiveEffectDurations(root2, _fiber);
          }
        }
        {
          markPassiveEffectsStopped();
        }
        {
          commitDoubleInvokeEffectsInDEV(root2.current, true);
        }
        executionContext = prevExecutionContext;
        flushSyncCallbacks();
        {
          if (didScheduleUpdateDuringPassiveEffects) {
            if (root2 === rootWithPassiveNestedUpdates) {
              nestedPassiveUpdateCount++;
            } else {
              nestedPassiveUpdateCount = 0;
              rootWithPassiveNestedUpdates = root2;
            }
          } else {
            nestedPassiveUpdateCount = 0;
          }
          isFlushingPassiveEffects = false;
          didScheduleUpdateDuringPassiveEffects = false;
        }
        onPostCommitRoot(root2);
        {
          var stateNode = root2.current.stateNode;
          stateNode.effectDuration = 0;
          stateNode.passiveEffectDuration = 0;
        }
        return true;
      }
      function isAlreadyFailedLegacyErrorBoundary(instance) {
        return legacyErrorBoundariesThatAlreadyFailed !== null && legacyErrorBoundariesThatAlreadyFailed.has(instance);
      }
      function markLegacyErrorBoundaryAsFailed(instance) {
        if (legacyErrorBoundariesThatAlreadyFailed === null) {
          legacyErrorBoundariesThatAlreadyFailed = new Set([instance]);
        } else {
          legacyErrorBoundariesThatAlreadyFailed.add(instance);
        }
      }
      function prepareToThrowUncaughtError(error2) {
        if (!hasUncaughtError) {
          hasUncaughtError = true;
          firstUncaughtError = error2;
        }
      }
      var onUncaughtError = prepareToThrowUncaughtError;
      function captureCommitPhaseErrorOnRoot(rootFiber, sourceFiber, error2) {
        var errorInfo = createCapturedValueAtFiber(error2, sourceFiber);
        var update = createRootErrorUpdate(rootFiber, errorInfo, SyncLane);
        var root2 = enqueueUpdate(rootFiber, update, SyncLane);
        var eventTime = requestEventTime();
        if (root2 !== null) {
          markRootUpdated(root2, SyncLane, eventTime);
          ensureRootIsScheduled(root2, eventTime);
        }
      }
      function captureCommitPhaseError(sourceFiber, nearestMountedAncestor, error$1) {
        {
          reportUncaughtErrorInDEV(error$1);
          setIsRunningInsertionEffect(false);
        }
        if (sourceFiber.tag === HostRoot) {
          captureCommitPhaseErrorOnRoot(sourceFiber, sourceFiber, error$1);
          return;
        }
        var fiber = null;
        {
          fiber = nearestMountedAncestor;
        }
        while (fiber !== null) {
          if (fiber.tag === HostRoot) {
            captureCommitPhaseErrorOnRoot(fiber, sourceFiber, error$1);
            return;
          } else if (fiber.tag === ClassComponent) {
            var ctor = fiber.type;
            var instance = fiber.stateNode;
            if (typeof ctor.getDerivedStateFromError === "function" || typeof instance.componentDidCatch === "function" && !isAlreadyFailedLegacyErrorBoundary(instance)) {
              var errorInfo = createCapturedValueAtFiber(error$1, sourceFiber);
              var update = createClassErrorUpdate(fiber, errorInfo, SyncLane);
              var root2 = enqueueUpdate(fiber, update, SyncLane);
              var eventTime = requestEventTime();
              if (root2 !== null) {
                markRootUpdated(root2, SyncLane, eventTime);
                ensureRootIsScheduled(root2, eventTime);
              }
              return;
            }
          }
          fiber = fiber.return;
        }
        {
          error("Internal React error: Attempted to capture a commit phase error " + "inside a detached tree. This indicates a bug in React. Likely " + "causes include deleting the same fiber more than once, committing an " + `already-finished tree, or an inconsistent return pointer.

` + `Error message:

%s`, error$1);
        }
      }
      function pingSuspendedRoot(root2, wakeable, pingedLanes) {
        var pingCache = root2.pingCache;
        if (pingCache !== null) {
          pingCache.delete(wakeable);
        }
        var eventTime = requestEventTime();
        markRootPinged(root2, pingedLanes);
        warnIfSuspenseResolutionNotWrappedWithActDEV(root2);
        if (workInProgressRoot === root2 && isSubsetOfLanes(workInProgressRootRenderLanes, pingedLanes)) {
          if (workInProgressRootExitStatus === RootSuspendedWithDelay || workInProgressRootExitStatus === RootSuspended && includesOnlyRetries(workInProgressRootRenderLanes) && now() - globalMostRecentFallbackTime < FALLBACK_THROTTLE_MS) {
            prepareFreshStack(root2, NoLanes);
          } else {
            workInProgressRootPingedLanes = mergeLanes(workInProgressRootPingedLanes, pingedLanes);
          }
        }
        ensureRootIsScheduled(root2, eventTime);
      }
      function retryTimedOutBoundary(boundaryFiber, retryLane) {
        if (retryLane === NoLane) {
          retryLane = requestRetryLane(boundaryFiber);
        }
        var eventTime = requestEventTime();
        var root2 = enqueueConcurrentRenderForLane(boundaryFiber, retryLane);
        if (root2 !== null) {
          markRootUpdated(root2, retryLane, eventTime);
          ensureRootIsScheduled(root2, eventTime);
        }
      }
      function retryDehydratedSuspenseBoundary(boundaryFiber) {
        var suspenseState = boundaryFiber.memoizedState;
        var retryLane = NoLane;
        if (suspenseState !== null) {
          retryLane = suspenseState.retryLane;
        }
        retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function resolveRetryWakeable(boundaryFiber, wakeable) {
        var retryLane = NoLane;
        var retryCache;
        switch (boundaryFiber.tag) {
          case SuspenseComponent:
            retryCache = boundaryFiber.stateNode;
            var suspenseState = boundaryFiber.memoizedState;
            if (suspenseState !== null) {
              retryLane = suspenseState.retryLane;
            }
            break;
          case SuspenseListComponent:
            retryCache = boundaryFiber.stateNode;
            break;
          default:
            throw new Error("Pinged unknown suspense boundary type. " + "This is probably a bug in React.");
        }
        if (retryCache !== null) {
          retryCache.delete(wakeable);
        }
        retryTimedOutBoundary(boundaryFiber, retryLane);
      }
      function jnd(timeElapsed) {
        return timeElapsed < 120 ? 120 : timeElapsed < 480 ? 480 : timeElapsed < 1080 ? 1080 : timeElapsed < 1920 ? 1920 : timeElapsed < 3000 ? 3000 : timeElapsed < 4320 ? 4320 : ceil(timeElapsed / 1960) * 1960;
      }
      function checkForNestedUpdates() {
        if (nestedUpdateCount > NESTED_UPDATE_LIMIT) {
          nestedUpdateCount = 0;
          rootWithNestedUpdates = null;
          throw new Error("Maximum update depth exceeded. This can happen when a component " + "repeatedly calls setState inside componentWillUpdate or " + "componentDidUpdate. React limits the number of nested updates to " + "prevent infinite loops.");
        }
        {
          if (nestedPassiveUpdateCount > NESTED_PASSIVE_UPDATE_LIMIT) {
            nestedPassiveUpdateCount = 0;
            rootWithPassiveNestedUpdates = null;
            error("Maximum update depth exceeded. This can happen when a component " + "calls setState inside useEffect, but useEffect either doesn't " + "have a dependency array, or one of the dependencies changes on " + "every render.");
          }
        }
      }
      function flushRenderPhaseStrictModeWarningsInDEV() {
        {
          ReactStrictModeWarnings.flushLegacyContextWarning();
          {
            ReactStrictModeWarnings.flushPendingUnsafeLifecycleWarnings();
          }
        }
      }
      function commitDoubleInvokeEffectsInDEV(fiber, hasPassiveEffects) {
        {
          setCurrentFiber(fiber);
          invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectUnmountInDEV);
          if (hasPassiveEffects) {
            invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectUnmountInDEV);
          }
          invokeEffectsInDev(fiber, MountLayoutDev, invokeLayoutEffectMountInDEV);
          if (hasPassiveEffects) {
            invokeEffectsInDev(fiber, MountPassiveDev, invokePassiveEffectMountInDEV);
          }
          resetCurrentFiber();
        }
      }
      function invokeEffectsInDev(firstChild, fiberFlags, invokeEffectFn) {
        {
          var current2 = firstChild;
          var subtreeRoot = null;
          while (current2 !== null) {
            var primarySubtreeFlag = current2.subtreeFlags & fiberFlags;
            if (current2 !== subtreeRoot && current2.child !== null && primarySubtreeFlag !== NoFlags) {
              current2 = current2.child;
            } else {
              if ((current2.flags & fiberFlags) !== NoFlags) {
                invokeEffectFn(current2);
              }
              if (current2.sibling !== null) {
                current2 = current2.sibling;
              } else {
                current2 = subtreeRoot = current2.return;
              }
            }
          }
        }
      }
      var didWarnStateUpdateForNotYetMountedComponent = null;
      function warnAboutUpdateOnNotYetMountedFiberInDEV(fiber) {
        {
          if ((executionContext & RenderContext) !== NoContext) {
            return;
          }
          if (!(fiber.mode & ConcurrentMode)) {
            return;
          }
          var tag = fiber.tag;
          if (tag !== IndeterminateComponent && tag !== HostRoot && tag !== ClassComponent && tag !== FunctionComponent && tag !== ForwardRef && tag !== MemoComponent && tag !== SimpleMemoComponent) {
            return;
          }
          var componentName = getComponentNameFromFiber(fiber) || "ReactComponent";
          if (didWarnStateUpdateForNotYetMountedComponent !== null) {
            if (didWarnStateUpdateForNotYetMountedComponent.has(componentName)) {
              return;
            }
            didWarnStateUpdateForNotYetMountedComponent.add(componentName);
          } else {
            didWarnStateUpdateForNotYetMountedComponent = new Set([componentName]);
          }
          var previousFiber = current;
          try {
            setCurrentFiber(fiber);
            error("Can't perform a React state update on a component that hasn't mounted yet. " + "This indicates that you have a side-effect in your render function that " + "asynchronously later calls tries to update the component. Move this work to " + "useEffect instead.");
          } finally {
            if (previousFiber) {
              setCurrentFiber(fiber);
            } else {
              resetCurrentFiber();
            }
          }
        }
      }
      var beginWork$1;
      {
        var dummyFiber = null;
        beginWork$1 = function(current2, unitOfWork, lanes) {
          var originalWorkInProgressCopy = assignFiberPropertiesInDEV(dummyFiber, unitOfWork);
          try {
            return beginWork(current2, unitOfWork, lanes);
          } catch (originalError) {
            if (didSuspendOrErrorWhileHydratingDEV() || originalError !== null && typeof originalError === "object" && typeof originalError.then === "function") {
              throw originalError;
            }
            resetContextDependencies();
            resetHooksAfterThrow();
            unwindInterruptedWork(current2, unitOfWork);
            assignFiberPropertiesInDEV(unitOfWork, originalWorkInProgressCopy);
            if (unitOfWork.mode & ProfileMode) {
              startProfilerTimer(unitOfWork);
            }
            invokeGuardedCallback(null, beginWork, null, current2, unitOfWork, lanes);
            if (hasCaughtError()) {
              var replayError = clearCaughtError();
              if (typeof replayError === "object" && replayError !== null && replayError._suppressLogging && typeof originalError === "object" && originalError !== null && !originalError._suppressLogging) {
                originalError._suppressLogging = true;
              }
            }
            throw originalError;
          }
        };
      }
      var didWarnAboutUpdateInRender = false;
      var didWarnAboutUpdateInRenderForAnotherComponent;
      {
        didWarnAboutUpdateInRenderForAnotherComponent = new Set;
      }
      function warnAboutRenderPhaseUpdatesInDEV(fiber) {
        {
          if (isRendering && !getIsUpdatingOpaqueValueInRenderPhaseInDEV()) {
            switch (fiber.tag) {
              case FunctionComponent:
              case ForwardRef:
              case SimpleMemoComponent: {
                var renderingComponentName = workInProgress && getComponentNameFromFiber(workInProgress) || "Unknown";
                var dedupeKey = renderingComponentName;
                if (!didWarnAboutUpdateInRenderForAnotherComponent.has(dedupeKey)) {
                  didWarnAboutUpdateInRenderForAnotherComponent.add(dedupeKey);
                  var setStateComponentName = getComponentNameFromFiber(fiber) || "Unknown";
                  error("Cannot update a component (`%s`) while rendering a " + "different component (`%s`). To locate the bad setState() call inside `%s`, " + "follow the stack trace as described in https://reactjs.org/link/setstate-in-render", setStateComponentName, renderingComponentName, renderingComponentName);
                }
                break;
              }
              case ClassComponent: {
                if (!didWarnAboutUpdateInRender) {
                  error("Cannot update during an existing state transition (such as " + "within `render`). Render methods should be a pure " + "function of props and state.");
                  didWarnAboutUpdateInRender = true;
                }
                break;
              }
            }
          }
        }
      }
      function restorePendingUpdaters(root2, lanes) {
        {
          if (isDevToolsPresent) {
            var memoizedUpdaters = root2.memoizedUpdaters;
            memoizedUpdaters.forEach(function(schedulingFiber) {
              addFiberToLanesMap(root2, schedulingFiber, lanes);
            });
          }
        }
      }
      var fakeActCallbackNode = {};
      function scheduleCallback$1(priorityLevel, callback) {
        {
          var actQueue = ReactCurrentActQueue$1.current;
          if (actQueue !== null) {
            actQueue.push(callback);
            return fakeActCallbackNode;
          } else {
            return scheduleCallback(priorityLevel, callback);
          }
        }
      }
      function cancelCallback$1(callbackNode) {
        if (callbackNode === fakeActCallbackNode) {
          return;
        }
        return cancelCallback(callbackNode);
      }
      function shouldForceFlushFallbacksInDEV() {
        return ReactCurrentActQueue$1.current !== null;
      }
      function warnIfUpdatesNotWrappedWithActDEV(fiber) {
        {
          if (fiber.mode & ConcurrentMode) {
            if (!isConcurrentActEnvironment()) {
              return;
            }
          } else {
            if (!isLegacyActEnvironment()) {
              return;
            }
            if (executionContext !== NoContext) {
              return;
            }
            if (fiber.tag !== FunctionComponent && fiber.tag !== ForwardRef && fiber.tag !== SimpleMemoComponent) {
              return;
            }
          }
          if (ReactCurrentActQueue$1.current === null) {
            var previousFiber = current;
            try {
              setCurrentFiber(fiber);
              error(`An update to %s inside a test was not wrapped in act(...).

` + "When testing, code that causes React state updates should be " + `wrapped into act(...):

` + `act(() => {
` + `  /* fire events that update state */
` + `});
` + `/* assert on the output */

` + "This ensures that you're testing the behavior the user would see " + "in the browser." + " Learn more at https://reactjs.org/link/wrap-tests-with-act", getComponentNameFromFiber(fiber));
            } finally {
              if (previousFiber) {
                setCurrentFiber(fiber);
              } else {
                resetCurrentFiber();
              }
            }
          }
        }
      }
      function warnIfSuspenseResolutionNotWrappedWithActDEV(root2) {
        {
          if (root2.tag !== LegacyRoot && isConcurrentActEnvironment() && ReactCurrentActQueue$1.current === null) {
            error("A suspended resource finished loading inside a test, but the event " + `was not wrapped in act(...).

` + "When testing, code that resolves suspended data should be wrapped " + `into act(...):

` + `act(() => {
` + `  /* finish loading suspended data */
` + `});
` + `/* assert on the output */

` + "This ensures that you're testing the behavior the user would see " + "in the browser." + " Learn more at https://reactjs.org/link/wrap-tests-with-act");
          }
        }
      }
      function setIsRunningInsertionEffect(isRunning) {
        {
          isRunningInsertionEffect = isRunning;
        }
      }
      var resolveFamily = null;
      var failedBoundaries = null;
      var setRefreshHandler = function(handler) {
        {
          resolveFamily = handler;
        }
      };
      function resolveFunctionForHotReloading(type) {
        {
          if (resolveFamily === null) {
            return type;
          }
          var family = resolveFamily(type);
          if (family === undefined) {
            return type;
          }
          return family.current;
        }
      }
      function resolveClassForHotReloading(type) {
        return resolveFunctionForHotReloading(type);
      }
      function resolveForwardRefForHotReloading(type) {
        {
          if (resolveFamily === null) {
            return type;
          }
          var family = resolveFamily(type);
          if (family === undefined) {
            if (type !== null && type !== undefined && typeof type.render === "function") {
              var currentRender = resolveFunctionForHotReloading(type.render);
              if (type.render !== currentRender) {
                var syntheticType = {
                  $$typeof: REACT_FORWARD_REF_TYPE,
                  render: currentRender
                };
                if (type.displayName !== undefined) {
                  syntheticType.displayName = type.displayName;
                }
                return syntheticType;
              }
            }
            return type;
          }
          return family.current;
        }
      }
      function isCompatibleFamilyForHotReloading(fiber, element) {
        {
          if (resolveFamily === null) {
            return false;
          }
          var prevType = fiber.elementType;
          var nextType = element.type;
          var needsCompareFamilies = false;
          var $$typeofNextType = typeof nextType === "object" && nextType !== null ? nextType.$$typeof : null;
          switch (fiber.tag) {
            case ClassComponent: {
              if (typeof nextType === "function") {
                needsCompareFamilies = true;
              }
              break;
            }
            case FunctionComponent: {
              if (typeof nextType === "function") {
                needsCompareFamilies = true;
              } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                needsCompareFamilies = true;
              }
              break;
            }
            case ForwardRef: {
              if ($$typeofNextType === REACT_FORWARD_REF_TYPE) {
                needsCompareFamilies = true;
              } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                needsCompareFamilies = true;
              }
              break;
            }
            case MemoComponent:
            case SimpleMemoComponent: {
              if ($$typeofNextType === REACT_MEMO_TYPE) {
                needsCompareFamilies = true;
              } else if ($$typeofNextType === REACT_LAZY_TYPE) {
                needsCompareFamilies = true;
              }
              break;
            }
            default:
              return false;
          }
          if (needsCompareFamilies) {
            var prevFamily = resolveFamily(prevType);
            if (prevFamily !== undefined && prevFamily === resolveFamily(nextType)) {
              return true;
            }
          }
          return false;
        }
      }
      function markFailedErrorBoundaryForHotReloading(fiber) {
        {
          if (resolveFamily === null) {
            return;
          }
          if (typeof WeakSet !== "function") {
            return;
          }
          if (failedBoundaries === null) {
            failedBoundaries = new WeakSet;
          }
          failedBoundaries.add(fiber);
        }
      }
      var scheduleRefresh = function(root2, update) {
        {
          if (resolveFamily === null) {
            return;
          }
          var { staleFamilies, updatedFamilies } = update;
          flushPassiveEffects();
          flushSync(function() {
            scheduleFibersWithFamiliesRecursively(root2.current, updatedFamilies, staleFamilies);
          });
        }
      };
      var scheduleRoot = function(root2, element) {
        {
          if (root2.context !== emptyContextObject) {
            return;
          }
          flushPassiveEffects();
          flushSync(function() {
            updateContainer(element, root2, null, null);
          });
        }
      };
      function scheduleFibersWithFamiliesRecursively(fiber, updatedFamilies, staleFamilies) {
        {
          var { alternate, child, sibling, tag, type } = fiber;
          var candidateType = null;
          switch (tag) {
            case FunctionComponent:
            case SimpleMemoComponent:
            case ClassComponent:
              candidateType = type;
              break;
            case ForwardRef:
              candidateType = type.render;
              break;
          }
          if (resolveFamily === null) {
            throw new Error("Expected resolveFamily to be set during hot reload.");
          }
          var needsRender = false;
          var needsRemount = false;
          if (candidateType !== null) {
            var family = resolveFamily(candidateType);
            if (family !== undefined) {
              if (staleFamilies.has(family)) {
                needsRemount = true;
              } else if (updatedFamilies.has(family)) {
                if (tag === ClassComponent) {
                  needsRemount = true;
                } else {
                  needsRender = true;
                }
              }
            }
          }
          if (failedBoundaries !== null) {
            if (failedBoundaries.has(fiber) || alternate !== null && failedBoundaries.has(alternate)) {
              needsRemount = true;
            }
          }
          if (needsRemount) {
            fiber._debugNeedsRemount = true;
          }
          if (needsRemount || needsRender) {
            var _root = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (_root !== null) {
              scheduleUpdateOnFiber(_root, fiber, SyncLane, NoTimestamp);
            }
          }
          if (child !== null && !needsRemount) {
            scheduleFibersWithFamiliesRecursively(child, updatedFamilies, staleFamilies);
          }
          if (sibling !== null) {
            scheduleFibersWithFamiliesRecursively(sibling, updatedFamilies, staleFamilies);
          }
        }
      }
      var findHostInstancesForRefresh = function(root2, families) {
        {
          var hostInstances = new Set;
          var types = new Set(families.map(function(family) {
            return family.current;
          }));
          findHostInstancesForMatchingFibersRecursively(root2.current, types, hostInstances);
          return hostInstances;
        }
      };
      function findHostInstancesForMatchingFibersRecursively(fiber, types, hostInstances) {
        {
          var { child, sibling, tag, type } = fiber;
          var candidateType = null;
          switch (tag) {
            case FunctionComponent:
            case SimpleMemoComponent:
            case ClassComponent:
              candidateType = type;
              break;
            case ForwardRef:
              candidateType = type.render;
              break;
          }
          var didMatch = false;
          if (candidateType !== null) {
            if (types.has(candidateType)) {
              didMatch = true;
            }
          }
          if (didMatch) {
            findHostInstancesForFiberShallowly(fiber, hostInstances);
          } else {
            if (child !== null) {
              findHostInstancesForMatchingFibersRecursively(child, types, hostInstances);
            }
          }
          if (sibling !== null) {
            findHostInstancesForMatchingFibersRecursively(sibling, types, hostInstances);
          }
        }
      }
      function findHostInstancesForFiberShallowly(fiber, hostInstances) {
        {
          var foundHostInstances = findChildHostInstancesForFiberShallowly(fiber, hostInstances);
          if (foundHostInstances) {
            return;
          }
          var node = fiber;
          while (true) {
            switch (node.tag) {
              case HostComponent:
                hostInstances.add(node.stateNode);
                return;
              case HostPortal:
                hostInstances.add(node.stateNode.containerInfo);
                return;
              case HostRoot:
                hostInstances.add(node.stateNode.containerInfo);
                return;
            }
            if (node.return === null) {
              throw new Error("Expected to reach root first.");
            }
            node = node.return;
          }
        }
      }
      function findChildHostInstancesForFiberShallowly(fiber, hostInstances) {
        {
          var node = fiber;
          var foundHostInstances = false;
          while (true) {
            if (node.tag === HostComponent) {
              foundHostInstances = true;
              hostInstances.add(node.stateNode);
            } else if (node.child !== null) {
              node.child.return = node;
              node = node.child;
              continue;
            }
            if (node === fiber) {
              return foundHostInstances;
            }
            while (node.sibling === null) {
              if (node.return === null || node.return === fiber) {
                return foundHostInstances;
              }
              node = node.return;
            }
            node.sibling.return = node.return;
            node = node.sibling;
          }
        }
        return false;
      }
      var hasBadMapPolyfill;
      {
        hasBadMapPolyfill = false;
        try {
          var nonExtensibleObject = Object.preventExtensions({});
          new Map([[nonExtensibleObject, null]]);
          new Set([nonExtensibleObject]);
        } catch (e) {
          hasBadMapPolyfill = true;
        }
      }
      function FiberNode(tag, pendingProps, key, mode) {
        this.tag = tag;
        this.key = key;
        this.elementType = null;
        this.type = null;
        this.stateNode = null;
        this.return = null;
        this.child = null;
        this.sibling = null;
        this.index = 0;
        this.ref = null;
        this.pendingProps = pendingProps;
        this.memoizedProps = null;
        this.updateQueue = null;
        this.memoizedState = null;
        this.dependencies = null;
        this.mode = mode;
        this.flags = NoFlags;
        this.subtreeFlags = NoFlags;
        this.deletions = null;
        this.lanes = NoLanes;
        this.childLanes = NoLanes;
        this.alternate = null;
        {
          this.actualDuration = Number.NaN;
          this.actualStartTime = Number.NaN;
          this.selfBaseDuration = Number.NaN;
          this.treeBaseDuration = Number.NaN;
          this.actualDuration = 0;
          this.actualStartTime = -1;
          this.selfBaseDuration = 0;
          this.treeBaseDuration = 0;
        }
        {
          this._debugSource = null;
          this._debugOwner = null;
          this._debugNeedsRemount = false;
          this._debugHookTypes = null;
          if (!hasBadMapPolyfill && typeof Object.preventExtensions === "function") {
            Object.preventExtensions(this);
          }
        }
      }
      var createFiber = function(tag, pendingProps, key, mode) {
        return new FiberNode(tag, pendingProps, key, mode);
      };
      function shouldConstruct$1(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function isSimpleFunctionComponent(type) {
        return typeof type === "function" && !shouldConstruct$1(type) && type.defaultProps === undefined;
      }
      function resolveLazyComponentTag(Component) {
        if (typeof Component === "function") {
          return shouldConstruct$1(Component) ? ClassComponent : FunctionComponent;
        } else if (Component !== undefined && Component !== null) {
          var $$typeof = Component.$$typeof;
          if ($$typeof === REACT_FORWARD_REF_TYPE) {
            return ForwardRef;
          }
          if ($$typeof === REACT_MEMO_TYPE) {
            return MemoComponent;
          }
        }
        return IndeterminateComponent;
      }
      function createWorkInProgress(current2, pendingProps) {
        var workInProgress2 = current2.alternate;
        if (workInProgress2 === null) {
          workInProgress2 = createFiber(current2.tag, pendingProps, current2.key, current2.mode);
          workInProgress2.elementType = current2.elementType;
          workInProgress2.type = current2.type;
          workInProgress2.stateNode = current2.stateNode;
          {
            workInProgress2._debugSource = current2._debugSource;
            workInProgress2._debugOwner = current2._debugOwner;
            workInProgress2._debugHookTypes = current2._debugHookTypes;
          }
          workInProgress2.alternate = current2;
          current2.alternate = workInProgress2;
        } else {
          workInProgress2.pendingProps = pendingProps;
          workInProgress2.type = current2.type;
          workInProgress2.flags = NoFlags;
          workInProgress2.subtreeFlags = NoFlags;
          workInProgress2.deletions = null;
          {
            workInProgress2.actualDuration = 0;
            workInProgress2.actualStartTime = -1;
          }
        }
        workInProgress2.flags = current2.flags & StaticMask;
        workInProgress2.childLanes = current2.childLanes;
        workInProgress2.lanes = current2.lanes;
        workInProgress2.child = current2.child;
        workInProgress2.memoizedProps = current2.memoizedProps;
        workInProgress2.memoizedState = current2.memoizedState;
        workInProgress2.updateQueue = current2.updateQueue;
        var currentDependencies = current2.dependencies;
        workInProgress2.dependencies = currentDependencies === null ? null : {
          lanes: currentDependencies.lanes,
          firstContext: currentDependencies.firstContext
        };
        workInProgress2.sibling = current2.sibling;
        workInProgress2.index = current2.index;
        workInProgress2.ref = current2.ref;
        {
          workInProgress2.selfBaseDuration = current2.selfBaseDuration;
          workInProgress2.treeBaseDuration = current2.treeBaseDuration;
        }
        {
          workInProgress2._debugNeedsRemount = current2._debugNeedsRemount;
          switch (workInProgress2.tag) {
            case IndeterminateComponent:
            case FunctionComponent:
            case SimpleMemoComponent:
              workInProgress2.type = resolveFunctionForHotReloading(current2.type);
              break;
            case ClassComponent:
              workInProgress2.type = resolveClassForHotReloading(current2.type);
              break;
            case ForwardRef:
              workInProgress2.type = resolveForwardRefForHotReloading(current2.type);
              break;
          }
        }
        return workInProgress2;
      }
      function resetWorkInProgress(workInProgress2, renderLanes2) {
        workInProgress2.flags &= StaticMask | Placement;
        var current2 = workInProgress2.alternate;
        if (current2 === null) {
          workInProgress2.childLanes = NoLanes;
          workInProgress2.lanes = renderLanes2;
          workInProgress2.child = null;
          workInProgress2.subtreeFlags = NoFlags;
          workInProgress2.memoizedProps = null;
          workInProgress2.memoizedState = null;
          workInProgress2.updateQueue = null;
          workInProgress2.dependencies = null;
          workInProgress2.stateNode = null;
          {
            workInProgress2.selfBaseDuration = 0;
            workInProgress2.treeBaseDuration = 0;
          }
        } else {
          workInProgress2.childLanes = current2.childLanes;
          workInProgress2.lanes = current2.lanes;
          workInProgress2.child = current2.child;
          workInProgress2.subtreeFlags = NoFlags;
          workInProgress2.deletions = null;
          workInProgress2.memoizedProps = current2.memoizedProps;
          workInProgress2.memoizedState = current2.memoizedState;
          workInProgress2.updateQueue = current2.updateQueue;
          workInProgress2.type = current2.type;
          var currentDependencies = current2.dependencies;
          workInProgress2.dependencies = currentDependencies === null ? null : {
            lanes: currentDependencies.lanes,
            firstContext: currentDependencies.firstContext
          };
          {
            workInProgress2.selfBaseDuration = current2.selfBaseDuration;
            workInProgress2.treeBaseDuration = current2.treeBaseDuration;
          }
        }
        return workInProgress2;
      }
      function createHostRootFiber(tag, isStrictMode, concurrentUpdatesByDefaultOverride) {
        var mode;
        if (tag === ConcurrentRoot) {
          mode = ConcurrentMode;
          if (isStrictMode === true) {
            mode |= StrictLegacyMode;
            {
              mode |= StrictEffectsMode;
            }
          }
        } else {
          mode = NoMode;
        }
        if (isDevToolsPresent) {
          mode |= ProfileMode;
        }
        return createFiber(HostRoot, null, null, mode);
      }
      function createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes) {
        var fiberTag = IndeterminateComponent;
        var resolvedType = type;
        if (typeof type === "function") {
          if (shouldConstruct$1(type)) {
            fiberTag = ClassComponent;
            {
              resolvedType = resolveClassForHotReloading(resolvedType);
            }
          } else {
            {
              resolvedType = resolveFunctionForHotReloading(resolvedType);
            }
          }
        } else if (typeof type === "string") {
          fiberTag = HostComponent;
        } else {
          getTag:
            switch (type) {
              case REACT_FRAGMENT_TYPE:
                return createFiberFromFragment(pendingProps.children, mode, lanes, key);
              case REACT_STRICT_MODE_TYPE:
                fiberTag = Mode;
                mode |= StrictLegacyMode;
                if ((mode & ConcurrentMode) !== NoMode) {
                  mode |= StrictEffectsMode;
                }
                break;
              case REACT_PROFILER_TYPE:
                return createFiberFromProfiler(pendingProps, mode, lanes, key);
              case REACT_SUSPENSE_TYPE:
                return createFiberFromSuspense(pendingProps, mode, lanes, key);
              case REACT_SUSPENSE_LIST_TYPE:
                return createFiberFromSuspenseList(pendingProps, mode, lanes, key);
              case REACT_OFFSCREEN_TYPE:
                return createFiberFromOffscreen(pendingProps, mode, lanes, key);
              case REACT_LEGACY_HIDDEN_TYPE:
              case REACT_SCOPE_TYPE:
              case REACT_CACHE_TYPE:
              case REACT_TRACING_MARKER_TYPE:
              case REACT_DEBUG_TRACING_MODE_TYPE:
              default: {
                if (typeof type === "object" && type !== null) {
                  switch (type.$$typeof) {
                    case REACT_PROVIDER_TYPE:
                      fiberTag = ContextProvider;
                      break getTag;
                    case REACT_CONTEXT_TYPE:
                      fiberTag = ContextConsumer;
                      break getTag;
                    case REACT_FORWARD_REF_TYPE:
                      fiberTag = ForwardRef;
                      {
                        resolvedType = resolveForwardRefForHotReloading(resolvedType);
                      }
                      break getTag;
                    case REACT_MEMO_TYPE:
                      fiberTag = MemoComponent;
                      break getTag;
                    case REACT_LAZY_TYPE:
                      fiberTag = LazyComponent;
                      resolvedType = null;
                      break getTag;
                  }
                }
                var info = "";
                {
                  if (type === undefined || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
                    info += " You likely forgot to export your component from the file " + "it's defined in, or you might have mixed up default and " + "named imports.";
                  }
                  var ownerName = owner ? getComponentNameFromFiber(owner) : null;
                  if (ownerName) {
                    info += `

Check the render method of \`` + ownerName + "`.";
                  }
                }
                throw new Error("Element type is invalid: expected a string (for built-in " + "components) or a class/function (for composite components) " + ("but got: " + (type == null ? type : typeof type) + "." + info));
              }
            }
        }
        var fiber = createFiber(fiberTag, pendingProps, key, mode);
        fiber.elementType = type;
        fiber.type = resolvedType;
        fiber.lanes = lanes;
        {
          fiber._debugOwner = owner;
        }
        return fiber;
      }
      function createFiberFromElement(element, mode, lanes) {
        var owner = null;
        {
          owner = element._owner;
        }
        var type = element.type;
        var key = element.key;
        var pendingProps = element.props;
        var fiber = createFiberFromTypeAndProps(type, key, pendingProps, owner, mode, lanes);
        {
          fiber._debugSource = element._source;
          fiber._debugOwner = element._owner;
        }
        return fiber;
      }
      function createFiberFromFragment(elements, mode, lanes, key) {
        var fiber = createFiber(Fragment, elements, key, mode);
        fiber.lanes = lanes;
        return fiber;
      }
      function createFiberFromProfiler(pendingProps, mode, lanes, key) {
        {
          if (typeof pendingProps.id !== "string") {
            error('Profiler must specify an "id" of type `string` as a prop. Received the type `%s` instead.', typeof pendingProps.id);
          }
        }
        var fiber = createFiber(Profiler, pendingProps, key, mode | ProfileMode);
        fiber.elementType = REACT_PROFILER_TYPE;
        fiber.lanes = lanes;
        {
          fiber.stateNode = {
            effectDuration: 0,
            passiveEffectDuration: 0
          };
        }
        return fiber;
      }
      function createFiberFromSuspense(pendingProps, mode, lanes, key) {
        var fiber = createFiber(SuspenseComponent, pendingProps, key, mode);
        fiber.elementType = REACT_SUSPENSE_TYPE;
        fiber.lanes = lanes;
        return fiber;
      }
      function createFiberFromSuspenseList(pendingProps, mode, lanes, key) {
        var fiber = createFiber(SuspenseListComponent, pendingProps, key, mode);
        fiber.elementType = REACT_SUSPENSE_LIST_TYPE;
        fiber.lanes = lanes;
        return fiber;
      }
      function createFiberFromOffscreen(pendingProps, mode, lanes, key) {
        var fiber = createFiber(OffscreenComponent, pendingProps, key, mode);
        fiber.elementType = REACT_OFFSCREEN_TYPE;
        fiber.lanes = lanes;
        var primaryChildInstance = {
          isHidden: false
        };
        fiber.stateNode = primaryChildInstance;
        return fiber;
      }
      function createFiberFromText(content, mode, lanes) {
        var fiber = createFiber(HostText, content, null, mode);
        fiber.lanes = lanes;
        return fiber;
      }
      function createFiberFromHostInstanceForDeletion() {
        var fiber = createFiber(HostComponent, null, null, NoMode);
        fiber.elementType = "DELETED";
        return fiber;
      }
      function createFiberFromDehydratedFragment(dehydratedNode) {
        var fiber = createFiber(DehydratedFragment, null, null, NoMode);
        fiber.stateNode = dehydratedNode;
        return fiber;
      }
      function createFiberFromPortal(portal, mode, lanes) {
        var pendingProps = portal.children !== null ? portal.children : [];
        var fiber = createFiber(HostPortal, pendingProps, portal.key, mode);
        fiber.lanes = lanes;
        fiber.stateNode = {
          containerInfo: portal.containerInfo,
          pendingChildren: null,
          implementation: portal.implementation
        };
        return fiber;
      }
      function assignFiberPropertiesInDEV(target, source) {
        if (target === null) {
          target = createFiber(IndeterminateComponent, null, null, NoMode);
        }
        target.tag = source.tag;
        target.key = source.key;
        target.elementType = source.elementType;
        target.type = source.type;
        target.stateNode = source.stateNode;
        target.return = source.return;
        target.child = source.child;
        target.sibling = source.sibling;
        target.index = source.index;
        target.ref = source.ref;
        target.pendingProps = source.pendingProps;
        target.memoizedProps = source.memoizedProps;
        target.updateQueue = source.updateQueue;
        target.memoizedState = source.memoizedState;
        target.dependencies = source.dependencies;
        target.mode = source.mode;
        target.flags = source.flags;
        target.subtreeFlags = source.subtreeFlags;
        target.deletions = source.deletions;
        target.lanes = source.lanes;
        target.childLanes = source.childLanes;
        target.alternate = source.alternate;
        {
          target.actualDuration = source.actualDuration;
          target.actualStartTime = source.actualStartTime;
          target.selfBaseDuration = source.selfBaseDuration;
          target.treeBaseDuration = source.treeBaseDuration;
        }
        target._debugSource = source._debugSource;
        target._debugOwner = source._debugOwner;
        target._debugNeedsRemount = source._debugNeedsRemount;
        target._debugHookTypes = source._debugHookTypes;
        return target;
      }
      function FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError) {
        this.tag = tag;
        this.containerInfo = containerInfo;
        this.pendingChildren = null;
        this.current = null;
        this.pingCache = null;
        this.finishedWork = null;
        this.timeoutHandle = noTimeout;
        this.context = null;
        this.pendingContext = null;
        this.callbackNode = null;
        this.callbackPriority = NoLane;
        this.eventTimes = createLaneMap(NoLanes);
        this.expirationTimes = createLaneMap(NoTimestamp);
        this.pendingLanes = NoLanes;
        this.suspendedLanes = NoLanes;
        this.pingedLanes = NoLanes;
        this.expiredLanes = NoLanes;
        this.mutableReadLanes = NoLanes;
        this.finishedLanes = NoLanes;
        this.entangledLanes = NoLanes;
        this.entanglements = createLaneMap(NoLanes);
        this.identifierPrefix = identifierPrefix;
        this.onRecoverableError = onRecoverableError;
        {
          this.mutableSourceEagerHydrationData = null;
        }
        {
          this.effectDuration = 0;
          this.passiveEffectDuration = 0;
        }
        {
          this.memoizedUpdaters = new Set;
          var pendingUpdatersLaneMap = this.pendingUpdatersLaneMap = [];
          for (var _i = 0;_i < TotalLanes; _i++) {
            pendingUpdatersLaneMap.push(new Set);
          }
        }
        {
          switch (tag) {
            case ConcurrentRoot:
              this._debugRootType = hydrate2 ? "hydrateRoot()" : "createRoot()";
              break;
            case LegacyRoot:
              this._debugRootType = hydrate2 ? "hydrate()" : "render()";
              break;
          }
        }
      }
      function createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
        var root2 = new FiberRootNode(containerInfo, tag, hydrate2, identifierPrefix, onRecoverableError);
        var uninitializedFiber = createHostRootFiber(tag, isStrictMode);
        root2.current = uninitializedFiber;
        uninitializedFiber.stateNode = root2;
        {
          var _initialState = {
            element: initialChildren,
            isDehydrated: hydrate2,
            cache: null,
            transitions: null,
            pendingSuspenseBoundaries: null
          };
          uninitializedFiber.memoizedState = _initialState;
        }
        initializeUpdateQueue(uninitializedFiber);
        return root2;
      }
      var ReactVersion = "18.3.1";
      function createPortal(children, containerInfo, implementation) {
        var key = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;
        {
          checkKeyStringCoercion(key);
        }
        return {
          $$typeof: REACT_PORTAL_TYPE,
          key: key == null ? null : "" + key,
          children,
          containerInfo,
          implementation
        };
      }
      var didWarnAboutNestedUpdates;
      var didWarnAboutFindNodeInStrictMode;
      {
        didWarnAboutNestedUpdates = false;
        didWarnAboutFindNodeInStrictMode = {};
      }
      function getContextForSubtree(parentComponent) {
        if (!parentComponent) {
          return emptyContextObject;
        }
        var fiber = get(parentComponent);
        var parentContext = findCurrentUnmaskedContext(fiber);
        if (fiber.tag === ClassComponent) {
          var Component = fiber.type;
          if (isContextProvider(Component)) {
            return processChildContext(fiber, Component, parentContext);
          }
        }
        return parentContext;
      }
      function findHostInstanceWithWarning(component, methodName) {
        {
          var fiber = get(component);
          if (fiber === undefined) {
            if (typeof component.render === "function") {
              throw new Error("Unable to find node on an unmounted component.");
            } else {
              var keys = Object.keys(component).join(",");
              throw new Error("Argument appears to not be a ReactComponent. Keys: " + keys);
            }
          }
          var hostFiber = findCurrentHostFiber(fiber);
          if (hostFiber === null) {
            return null;
          }
          if (hostFiber.mode & StrictLegacyMode) {
            var componentName = getComponentNameFromFiber(fiber) || "Component";
            if (!didWarnAboutFindNodeInStrictMode[componentName]) {
              didWarnAboutFindNodeInStrictMode[componentName] = true;
              var previousFiber = current;
              try {
                setCurrentFiber(hostFiber);
                if (fiber.mode & StrictLegacyMode) {
                  error("%s is deprecated in StrictMode. " + "%s was passed an instance of %s which is inside StrictMode. " + "Instead, add a ref directly to the element you want to reference. " + "Learn more about using refs safely here: " + "https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                } else {
                  error("%s is deprecated in StrictMode. " + "%s was passed an instance of %s which renders StrictMode children. " + "Instead, add a ref directly to the element you want to reference. " + "Learn more about using refs safely here: " + "https://reactjs.org/link/strict-mode-find-node", methodName, methodName, componentName);
                }
              } finally {
                if (previousFiber) {
                  setCurrentFiber(previousFiber);
                } else {
                  resetCurrentFiber();
                }
              }
            }
          }
          return hostFiber.stateNode;
        }
      }
      function createContainer(containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
        var hydrate2 = false;
        var initialChildren = null;
        return createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
      }
      function createHydrationContainer(initialChildren, callback, containerInfo, tag, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError, transitionCallbacks) {
        var hydrate2 = true;
        var root2 = createFiberRoot(containerInfo, tag, hydrate2, initialChildren, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
        root2.context = getContextForSubtree(null);
        var current2 = root2.current;
        var eventTime = requestEventTime();
        var lane = requestUpdateLane(current2);
        var update = createUpdate(eventTime, lane);
        update.callback = callback !== undefined && callback !== null ? callback : null;
        enqueueUpdate(current2, update, lane);
        scheduleInitialHydrationOnRoot(root2, lane, eventTime);
        return root2;
      }
      function updateContainer(element, container, parentComponent, callback) {
        {
          onScheduleRoot(container, element);
        }
        var current$1 = container.current;
        var eventTime = requestEventTime();
        var lane = requestUpdateLane(current$1);
        {
          markRenderScheduled(lane);
        }
        var context = getContextForSubtree(parentComponent);
        if (container.context === null) {
          container.context = context;
        } else {
          container.pendingContext = context;
        }
        {
          if (isRendering && current !== null && !didWarnAboutNestedUpdates) {
            didWarnAboutNestedUpdates = true;
            error("Render methods should be a pure function of props and state; " + "triggering nested component updates from render is not allowed. " + `If necessary, trigger nested updates in componentDidUpdate.

` + "Check the render method of %s.", getComponentNameFromFiber(current) || "Unknown");
          }
        }
        var update = createUpdate(eventTime, lane);
        update.payload = {
          element
        };
        callback = callback === undefined ? null : callback;
        if (callback !== null) {
          {
            if (typeof callback !== "function") {
              error("render(...): Expected the last optional `callback` argument to be a " + "function. Instead received: %s.", callback);
            }
          }
          update.callback = callback;
        }
        var root2 = enqueueUpdate(current$1, update, lane);
        if (root2 !== null) {
          scheduleUpdateOnFiber(root2, current$1, lane, eventTime);
          entangleTransitions(root2, current$1, lane);
        }
        return lane;
      }
      function getPublicRootInstance(container) {
        var containerFiber = container.current;
        if (!containerFiber.child) {
          return null;
        }
        switch (containerFiber.child.tag) {
          case HostComponent:
            return getPublicInstance(containerFiber.child.stateNode);
          default:
            return containerFiber.child.stateNode;
        }
      }
      function attemptSynchronousHydration$1(fiber) {
        switch (fiber.tag) {
          case HostRoot: {
            var root2 = fiber.stateNode;
            if (isRootDehydrated(root2)) {
              var lanes = getHighestPriorityPendingLanes(root2);
              flushRoot(root2, lanes);
            }
            break;
          }
          case SuspenseComponent: {
            flushSync(function() {
              var root3 = enqueueConcurrentRenderForLane(fiber, SyncLane);
              if (root3 !== null) {
                var eventTime = requestEventTime();
                scheduleUpdateOnFiber(root3, fiber, SyncLane, eventTime);
              }
            });
            var retryLane = SyncLane;
            markRetryLaneIfNotHydrated(fiber, retryLane);
            break;
          }
        }
      }
      function markRetryLaneImpl(fiber, retryLane) {
        var suspenseState = fiber.memoizedState;
        if (suspenseState !== null && suspenseState.dehydrated !== null) {
          suspenseState.retryLane = higherPriorityLane(suspenseState.retryLane, retryLane);
        }
      }
      function markRetryLaneIfNotHydrated(fiber, retryLane) {
        markRetryLaneImpl(fiber, retryLane);
        var alternate = fiber.alternate;
        if (alternate) {
          markRetryLaneImpl(alternate, retryLane);
        }
      }
      function attemptContinuousHydration$1(fiber) {
        if (fiber.tag !== SuspenseComponent) {
          return;
        }
        var lane = SelectiveHydrationLane;
        var root2 = enqueueConcurrentRenderForLane(fiber, lane);
        if (root2 !== null) {
          var eventTime = requestEventTime();
          scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
        }
        markRetryLaneIfNotHydrated(fiber, lane);
      }
      function attemptHydrationAtCurrentPriority$1(fiber) {
        if (fiber.tag !== SuspenseComponent) {
          return;
        }
        var lane = requestUpdateLane(fiber);
        var root2 = enqueueConcurrentRenderForLane(fiber, lane);
        if (root2 !== null) {
          var eventTime = requestEventTime();
          scheduleUpdateOnFiber(root2, fiber, lane, eventTime);
        }
        markRetryLaneIfNotHydrated(fiber, lane);
      }
      function findHostInstanceWithNoPortals(fiber) {
        var hostFiber = findCurrentHostFiberWithNoPortals(fiber);
        if (hostFiber === null) {
          return null;
        }
        return hostFiber.stateNode;
      }
      var shouldErrorImpl = function(fiber) {
        return null;
      };
      function shouldError(fiber) {
        return shouldErrorImpl(fiber);
      }
      var shouldSuspendImpl = function(fiber) {
        return false;
      };
      function shouldSuspend(fiber) {
        return shouldSuspendImpl(fiber);
      }
      var overrideHookState = null;
      var overrideHookStateDeletePath = null;
      var overrideHookStateRenamePath = null;
      var overrideProps = null;
      var overridePropsDeletePath = null;
      var overridePropsRenamePath = null;
      var scheduleUpdate = null;
      var setErrorHandler = null;
      var setSuspenseHandler = null;
      {
        var copyWithDeleteImpl = function(obj, path, index2) {
          var key = path[index2];
          var updated = isArray(obj) ? obj.slice() : assign({}, obj);
          if (index2 + 1 === path.length) {
            if (isArray(updated)) {
              updated.splice(key, 1);
            } else {
              delete updated[key];
            }
            return updated;
          }
          updated[key] = copyWithDeleteImpl(obj[key], path, index2 + 1);
          return updated;
        };
        var copyWithDelete = function(obj, path) {
          return copyWithDeleteImpl(obj, path, 0);
        };
        var copyWithRenameImpl = function(obj, oldPath, newPath, index2) {
          var oldKey = oldPath[index2];
          var updated = isArray(obj) ? obj.slice() : assign({}, obj);
          if (index2 + 1 === oldPath.length) {
            var newKey = newPath[index2];
            updated[newKey] = updated[oldKey];
            if (isArray(updated)) {
              updated.splice(oldKey, 1);
            } else {
              delete updated[oldKey];
            }
          } else {
            updated[oldKey] = copyWithRenameImpl(obj[oldKey], oldPath, newPath, index2 + 1);
          }
          return updated;
        };
        var copyWithRename = function(obj, oldPath, newPath) {
          if (oldPath.length !== newPath.length) {
            warn("copyWithRename() expects paths of the same length");
            return;
          } else {
            for (var i = 0;i < newPath.length - 1; i++) {
              if (oldPath[i] !== newPath[i]) {
                warn("copyWithRename() expects paths to be the same except for the deepest key");
                return;
              }
            }
          }
          return copyWithRenameImpl(obj, oldPath, newPath, 0);
        };
        var copyWithSetImpl = function(obj, path, index2, value) {
          if (index2 >= path.length) {
            return value;
          }
          var key = path[index2];
          var updated = isArray(obj) ? obj.slice() : assign({}, obj);
          updated[key] = copyWithSetImpl(obj[key], path, index2 + 1, value);
          return updated;
        };
        var copyWithSet = function(obj, path, value) {
          return copyWithSetImpl(obj, path, 0, value);
        };
        var findHook = function(fiber, id) {
          var currentHook2 = fiber.memoizedState;
          while (currentHook2 !== null && id > 0) {
            currentHook2 = currentHook2.next;
            id--;
          }
          return currentHook2;
        };
        overrideHookState = function(fiber, id, path, value) {
          var hook = findHook(fiber, id);
          if (hook !== null) {
            var newState = copyWithSet(hook.memoizedState, path, value);
            hook.memoizedState = newState;
            hook.baseState = newState;
            fiber.memoizedProps = assign({}, fiber.memoizedProps);
            var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
            }
          }
        };
        overrideHookStateDeletePath = function(fiber, id, path) {
          var hook = findHook(fiber, id);
          if (hook !== null) {
            var newState = copyWithDelete(hook.memoizedState, path);
            hook.memoizedState = newState;
            hook.baseState = newState;
            fiber.memoizedProps = assign({}, fiber.memoizedProps);
            var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
            }
          }
        };
        overrideHookStateRenamePath = function(fiber, id, oldPath, newPath) {
          var hook = findHook(fiber, id);
          if (hook !== null) {
            var newState = copyWithRename(hook.memoizedState, oldPath, newPath);
            hook.memoizedState = newState;
            hook.baseState = newState;
            fiber.memoizedProps = assign({}, fiber.memoizedProps);
            var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
            if (root2 !== null) {
              scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
            }
          }
        };
        overrideProps = function(fiber, path, value) {
          fiber.pendingProps = copyWithSet(fiber.memoizedProps, path, value);
          if (fiber.alternate) {
            fiber.alternate.pendingProps = fiber.pendingProps;
          }
          var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
          if (root2 !== null) {
            scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
          }
        };
        overridePropsDeletePath = function(fiber, path) {
          fiber.pendingProps = copyWithDelete(fiber.memoizedProps, path);
          if (fiber.alternate) {
            fiber.alternate.pendingProps = fiber.pendingProps;
          }
          var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
          if (root2 !== null) {
            scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
          }
        };
        overridePropsRenamePath = function(fiber, oldPath, newPath) {
          fiber.pendingProps = copyWithRename(fiber.memoizedProps, oldPath, newPath);
          if (fiber.alternate) {
            fiber.alternate.pendingProps = fiber.pendingProps;
          }
          var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
          if (root2 !== null) {
            scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
          }
        };
        scheduleUpdate = function(fiber) {
          var root2 = enqueueConcurrentRenderForLane(fiber, SyncLane);
          if (root2 !== null) {
            scheduleUpdateOnFiber(root2, fiber, SyncLane, NoTimestamp);
          }
        };
        setErrorHandler = function(newShouldErrorImpl) {
          shouldErrorImpl = newShouldErrorImpl;
        };
        setSuspenseHandler = function(newShouldSuspendImpl) {
          shouldSuspendImpl = newShouldSuspendImpl;
        };
      }
      function findHostInstanceByFiber(fiber) {
        var hostFiber = findCurrentHostFiber(fiber);
        if (hostFiber === null) {
          return null;
        }
        return hostFiber.stateNode;
      }
      function emptyFindFiberByHostInstance(instance) {
        return null;
      }
      function getCurrentFiberForDevTools() {
        return current;
      }
      function injectIntoDevTools(devToolsConfig) {
        var findFiberByHostInstance = devToolsConfig.findFiberByHostInstance;
        var ReactCurrentDispatcher2 = ReactSharedInternals.ReactCurrentDispatcher;
        return injectInternals({
          bundleType: devToolsConfig.bundleType,
          version: devToolsConfig.version,
          rendererPackageName: devToolsConfig.rendererPackageName,
          rendererConfig: devToolsConfig.rendererConfig,
          overrideHookState,
          overrideHookStateDeletePath,
          overrideHookStateRenamePath,
          overrideProps,
          overridePropsDeletePath,
          overridePropsRenamePath,
          setErrorHandler,
          setSuspenseHandler,
          scheduleUpdate,
          currentDispatcherRef: ReactCurrentDispatcher2,
          findHostInstanceByFiber,
          findFiberByHostInstance: findFiberByHostInstance || emptyFindFiberByHostInstance,
          findHostInstancesForRefresh,
          scheduleRefresh,
          scheduleRoot,
          setRefreshHandler,
          getCurrentFiber: getCurrentFiberForDevTools,
          reconcilerVersion: ReactVersion
        });
      }
      var defaultOnRecoverableError = typeof reportError === "function" ? reportError : function(error2) {
        console["error"](error2);
      };
      function ReactDOMRoot(internalRoot) {
        this._internalRoot = internalRoot;
      }
      ReactDOMHydrationRoot.prototype.render = ReactDOMRoot.prototype.render = function(children) {
        var root2 = this._internalRoot;
        if (root2 === null) {
          throw new Error("Cannot update an unmounted root.");
        }
        {
          if (typeof arguments[1] === "function") {
            error("render(...): does not support the second callback argument. " + "To execute a side effect after rendering, declare it in a component body with useEffect().");
          } else if (isValidContainer(arguments[1])) {
            error("You passed a container to the second argument of root.render(...). " + "You don't need to pass it again since you already passed it to create the root.");
          } else if (typeof arguments[1] !== "undefined") {
            error("You passed a second argument to root.render(...) but it only accepts " + "one argument.");
          }
          var container = root2.containerInfo;
          if (container.nodeType !== COMMENT_NODE) {
            var hostInstance = findHostInstanceWithNoPortals(root2.current);
            if (hostInstance) {
              if (hostInstance.parentNode !== container) {
                error("render(...): It looks like the React-rendered content of the " + "root container was removed without using React. This is not " + "supported and will cause errors. Instead, call " + "root.unmount() to empty a root's container.");
              }
            }
          }
        }
        updateContainer(children, root2, null, null);
      };
      ReactDOMHydrationRoot.prototype.unmount = ReactDOMRoot.prototype.unmount = function() {
        {
          if (typeof arguments[0] === "function") {
            error("unmount(...): does not support a callback argument. " + "To execute a side effect after rendering, declare it in a component body with useEffect().");
          }
        }
        var root2 = this._internalRoot;
        if (root2 !== null) {
          this._internalRoot = null;
          var container = root2.containerInfo;
          {
            if (isAlreadyRendering()) {
              error("Attempted to synchronously unmount a root while React was already " + "rendering. React cannot finish unmounting the root until the " + "current render has completed, which may lead to a race condition.");
            }
          }
          flushSync(function() {
            updateContainer(null, root2, null, null);
          });
          unmarkContainerAsRoot(container);
        }
      };
      function createRoot(container, options2) {
        if (!isValidContainer(container)) {
          throw new Error("createRoot(...): Target container is not a DOM element.");
        }
        warnIfReactDOMContainerInDEV(container);
        var isStrictMode = false;
        var concurrentUpdatesByDefaultOverride = false;
        var identifierPrefix = "";
        var onRecoverableError = defaultOnRecoverableError;
        var transitionCallbacks = null;
        if (options2 !== null && options2 !== undefined) {
          {
            if (options2.hydrate) {
              warn("hydrate through createRoot is deprecated. Use ReactDOMClient.hydrateRoot(container, <App />) instead.");
            } else {
              if (typeof options2 === "object" && options2 !== null && options2.$$typeof === REACT_ELEMENT_TYPE) {
                error("You passed a JSX element to createRoot. You probably meant to " + "call root.render instead. " + `Example usage:

` + `  let root = createRoot(domContainer);
` + "  root.render(<App />);");
              }
            }
          }
          if (options2.unstable_strictMode === true) {
            isStrictMode = true;
          }
          if (options2.identifierPrefix !== undefined) {
            identifierPrefix = options2.identifierPrefix;
          }
          if (options2.onRecoverableError !== undefined) {
            onRecoverableError = options2.onRecoverableError;
          }
          if (options2.transitionCallbacks !== undefined) {
            transitionCallbacks = options2.transitionCallbacks;
          }
        }
        var root2 = createContainer(container, ConcurrentRoot, null, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
        markContainerAsRoot(root2.current, container);
        var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
        listenToAllSupportedEvents(rootContainerElement);
        return new ReactDOMRoot(root2);
      }
      function ReactDOMHydrationRoot(internalRoot) {
        this._internalRoot = internalRoot;
      }
      function scheduleHydration(target) {
        if (target) {
          queueExplicitHydrationTarget(target);
        }
      }
      ReactDOMHydrationRoot.prototype.unstable_scheduleHydration = scheduleHydration;
      function hydrateRoot(container, initialChildren, options2) {
        if (!isValidContainer(container)) {
          throw new Error("hydrateRoot(...): Target container is not a DOM element.");
        }
        warnIfReactDOMContainerInDEV(container);
        {
          if (initialChildren === undefined) {
            error("Must provide initial children as second argument to hydrateRoot. " + "Example usage: hydrateRoot(domContainer, <App />)");
          }
        }
        var hydrationCallbacks = options2 != null ? options2 : null;
        var mutableSources = options2 != null && options2.hydratedSources || null;
        var isStrictMode = false;
        var concurrentUpdatesByDefaultOverride = false;
        var identifierPrefix = "";
        var onRecoverableError = defaultOnRecoverableError;
        if (options2 !== null && options2 !== undefined) {
          if (options2.unstable_strictMode === true) {
            isStrictMode = true;
          }
          if (options2.identifierPrefix !== undefined) {
            identifierPrefix = options2.identifierPrefix;
          }
          if (options2.onRecoverableError !== undefined) {
            onRecoverableError = options2.onRecoverableError;
          }
        }
        var root2 = createHydrationContainer(initialChildren, null, container, ConcurrentRoot, hydrationCallbacks, isStrictMode, concurrentUpdatesByDefaultOverride, identifierPrefix, onRecoverableError);
        markContainerAsRoot(root2.current, container);
        listenToAllSupportedEvents(container);
        if (mutableSources) {
          for (var i = 0;i < mutableSources.length; i++) {
            var mutableSource = mutableSources[i];
            registerMutableSourceForHydration(root2, mutableSource);
          }
        }
        return new ReactDOMHydrationRoot(root2);
      }
      function isValidContainer(node) {
        return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || !disableCommentsAsDOMContainers));
      }
      function isValidContainerLegacy(node) {
        return !!(node && (node.nodeType === ELEMENT_NODE || node.nodeType === DOCUMENT_NODE || node.nodeType === DOCUMENT_FRAGMENT_NODE || node.nodeType === COMMENT_NODE && node.nodeValue === " react-mount-point-unstable "));
      }
      function warnIfReactDOMContainerInDEV(container) {
        {
          if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === "BODY") {
            error("createRoot(): Creating roots directly with document.body is " + "discouraged, since its children are often manipulated by third-party " + "scripts and browser extensions. This may lead to subtle " + "reconciliation issues. Try using a container element created " + "for your app.");
          }
          if (isContainerMarkedAsRoot(container)) {
            if (container._reactRootContainer) {
              error("You are calling ReactDOMClient.createRoot() on a container that was previously " + "passed to ReactDOM.render(). This is not supported.");
            } else {
              error("You are calling ReactDOMClient.createRoot() on a container that " + "has already been passed to createRoot() before. Instead, call " + "root.render() on the existing root instead if you want to update it.");
            }
          }
        }
      }
      var ReactCurrentOwner$3 = ReactSharedInternals.ReactCurrentOwner;
      var topLevelUpdateWarnings;
      {
        topLevelUpdateWarnings = function(container) {
          if (container._reactRootContainer && container.nodeType !== COMMENT_NODE) {
            var hostInstance = findHostInstanceWithNoPortals(container._reactRootContainer.current);
            if (hostInstance) {
              if (hostInstance.parentNode !== container) {
                error("render(...): It looks like the React-rendered content of this " + "container was removed without using React. This is not " + "supported and will cause errors. Instead, call " + "ReactDOM.unmountComponentAtNode to empty a container.");
              }
            }
          }
          var isRootRenderedBySomeReact = !!container._reactRootContainer;
          var rootEl = getReactRootElementInContainer(container);
          var hasNonRootReactChild = !!(rootEl && getInstanceFromNode(rootEl));
          if (hasNonRootReactChild && !isRootRenderedBySomeReact) {
            error("render(...): Replacing React-rendered children with a new root " + "component. If you intended to update the children of this node, " + "you should instead have the existing children update their state " + "and render the new components instead of calling ReactDOM.render.");
          }
          if (container.nodeType === ELEMENT_NODE && container.tagName && container.tagName.toUpperCase() === "BODY") {
            error("render(): Rendering components directly into document.body is " + "discouraged, since its children are often manipulated by third-party " + "scripts and browser extensions. This may lead to subtle " + "reconciliation issues. Try rendering into a container element created " + "for your app.");
          }
        };
      }
      function getReactRootElementInContainer(container) {
        if (!container) {
          return null;
        }
        if (container.nodeType === DOCUMENT_NODE) {
          return container.documentElement;
        } else {
          return container.firstChild;
        }
      }
      function noopOnRecoverableError() {}
      function legacyCreateRootFromDOMContainer(container, initialChildren, parentComponent, callback, isHydrationContainer) {
        if (isHydrationContainer) {
          if (typeof callback === "function") {
            var originalCallback = callback;
            callback = function() {
              var instance = getPublicRootInstance(root2);
              originalCallback.call(instance);
            };
          }
          var root2 = createHydrationContainer(initialChildren, callback, container, LegacyRoot, null, false, false, "", noopOnRecoverableError);
          container._reactRootContainer = root2;
          markContainerAsRoot(root2.current, container);
          var rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
          listenToAllSupportedEvents(rootContainerElement);
          flushSync();
          return root2;
        } else {
          var rootSibling;
          while (rootSibling = container.lastChild) {
            container.removeChild(rootSibling);
          }
          if (typeof callback === "function") {
            var _originalCallback = callback;
            callback = function() {
              var instance = getPublicRootInstance(_root);
              _originalCallback.call(instance);
            };
          }
          var _root = createContainer(container, LegacyRoot, null, false, false, "", noopOnRecoverableError);
          container._reactRootContainer = _root;
          markContainerAsRoot(_root.current, container);
          var _rootContainerElement = container.nodeType === COMMENT_NODE ? container.parentNode : container;
          listenToAllSupportedEvents(_rootContainerElement);
          flushSync(function() {
            updateContainer(initialChildren, _root, parentComponent, callback);
          });
          return _root;
        }
      }
      function warnOnInvalidCallback$1(callback, callerName) {
        {
          if (callback !== null && typeof callback !== "function") {
            error("%s(...): Expected the last optional `callback` argument to be a " + "function. Instead received: %s.", callerName, callback);
          }
        }
      }
      function legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback) {
        {
          topLevelUpdateWarnings(container);
          warnOnInvalidCallback$1(callback === undefined ? null : callback, "render");
        }
        var maybeRoot = container._reactRootContainer;
        var root2;
        if (!maybeRoot) {
          root2 = legacyCreateRootFromDOMContainer(container, children, parentComponent, callback, forceHydrate);
        } else {
          root2 = maybeRoot;
          if (typeof callback === "function") {
            var originalCallback = callback;
            callback = function() {
              var instance = getPublicRootInstance(root2);
              originalCallback.call(instance);
            };
          }
          updateContainer(children, root2, parentComponent, callback);
        }
        return getPublicRootInstance(root2);
      }
      var didWarnAboutFindDOMNode = false;
      function findDOMNode(componentOrElement) {
        {
          if (!didWarnAboutFindDOMNode) {
            didWarnAboutFindDOMNode = true;
            error("findDOMNode is deprecated and will be removed in the next major " + "release. Instead, add a ref directly to the element you want " + "to reference. Learn more about using refs safely here: " + "https://reactjs.org/link/strict-mode-find-node");
          }
          var owner = ReactCurrentOwner$3.current;
          if (owner !== null && owner.stateNode !== null) {
            var warnedAboutRefsInRender = owner.stateNode._warnedAboutRefsInRender;
            if (!warnedAboutRefsInRender) {
              error("%s is accessing findDOMNode inside its render(). " + "render() should be a pure function of props and state. It should " + "never access something that requires stale data from the previous " + "render, such as refs. Move this logic to componentDidMount and " + "componentDidUpdate instead.", getComponentNameFromType(owner.type) || "A component");
            }
            owner.stateNode._warnedAboutRefsInRender = true;
          }
        }
        if (componentOrElement == null) {
          return null;
        }
        if (componentOrElement.nodeType === ELEMENT_NODE) {
          return componentOrElement;
        }
        {
          return findHostInstanceWithWarning(componentOrElement, "findDOMNode");
        }
      }
      function hydrate(element, container, callback) {
        {
          error("ReactDOM.hydrate is no longer supported in React 18. Use hydrateRoot " + "instead. Until you switch to the new API, your app will behave as " + "if it's running React 17. Learn " + "more: https://reactjs.org/link/switch-to-createroot");
        }
        if (!isValidContainerLegacy(container)) {
          throw new Error("Target container is not a DOM element.");
        }
        {
          var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined;
          if (isModernRoot) {
            error("You are calling ReactDOM.hydrate() on a container that was previously " + "passed to ReactDOMClient.createRoot(). This is not supported. " + "Did you mean to call hydrateRoot(container, element)?");
          }
        }
        return legacyRenderSubtreeIntoContainer(null, element, container, true, callback);
      }
      function render(element, container, callback) {
        {
          error("ReactDOM.render is no longer supported in React 18. Use createRoot " + "instead. Until you switch to the new API, your app will behave as " + "if it's running React 17. Learn " + "more: https://reactjs.org/link/switch-to-createroot");
        }
        if (!isValidContainerLegacy(container)) {
          throw new Error("Target container is not a DOM element.");
        }
        {
          var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined;
          if (isModernRoot) {
            error("You are calling ReactDOM.render() on a container that was previously " + "passed to ReactDOMClient.createRoot(). This is not supported. " + "Did you mean to call root.render(element)?");
          }
        }
        return legacyRenderSubtreeIntoContainer(null, element, container, false, callback);
      }
      function unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
        {
          error("ReactDOM.unstable_renderSubtreeIntoContainer() is no longer supported " + "in React 18. Consider using a portal instead. Until you switch to " + "the createRoot API, your app will behave as if it's running React " + "17. Learn more: https://reactjs.org/link/switch-to-createroot");
        }
        if (!isValidContainerLegacy(containerNode)) {
          throw new Error("Target container is not a DOM element.");
        }
        if (parentComponent == null || !has(parentComponent)) {
          throw new Error("parentComponent must be a valid React Component");
        }
        return legacyRenderSubtreeIntoContainer(parentComponent, element, containerNode, false, callback);
      }
      var didWarnAboutUnmountComponentAtNode = false;
      function unmountComponentAtNode(container) {
        {
          if (!didWarnAboutUnmountComponentAtNode) {
            didWarnAboutUnmountComponentAtNode = true;
            error("unmountComponentAtNode is deprecated and will be removed in the " + "next major release. Switch to the createRoot API. Learn " + "more: https://reactjs.org/link/switch-to-createroot");
          }
        }
        if (!isValidContainerLegacy(container)) {
          throw new Error("unmountComponentAtNode(...): Target container is not a DOM element.");
        }
        {
          var isModernRoot = isContainerMarkedAsRoot(container) && container._reactRootContainer === undefined;
          if (isModernRoot) {
            error("You are calling ReactDOM.unmountComponentAtNode() on a container that was previously " + "passed to ReactDOMClient.createRoot(). This is not supported. Did you mean to call root.unmount()?");
          }
        }
        if (container._reactRootContainer) {
          {
            var rootEl = getReactRootElementInContainer(container);
            var renderedByDifferentReact = rootEl && !getInstanceFromNode(rootEl);
            if (renderedByDifferentReact) {
              error("unmountComponentAtNode(): The node you're attempting to unmount " + "was rendered by another copy of React.");
            }
          }
          flushSync(function() {
            legacyRenderSubtreeIntoContainer(null, null, container, false, function() {
              container._reactRootContainer = null;
              unmarkContainerAsRoot(container);
            });
          });
          return true;
        } else {
          {
            var _rootEl = getReactRootElementInContainer(container);
            var hasNonRootReactChild = !!(_rootEl && getInstanceFromNode(_rootEl));
            var isContainerReactRoot = container.nodeType === ELEMENT_NODE && isValidContainerLegacy(container.parentNode) && !!container.parentNode._reactRootContainer;
            if (hasNonRootReactChild) {
              error("unmountComponentAtNode(): The node you're attempting to unmount " + "was rendered by React and is not a top-level container. %s", isContainerReactRoot ? "You may have accidentally passed in a React root node instead " + "of its container." : "Instead, have the parent component update its state and " + "rerender in order to remove this component.");
            }
          }
          return false;
        }
      }
      setAttemptSynchronousHydration(attemptSynchronousHydration$1);
      setAttemptContinuousHydration(attemptContinuousHydration$1);
      setAttemptHydrationAtCurrentPriority(attemptHydrationAtCurrentPriority$1);
      setGetCurrentUpdatePriority(getCurrentUpdatePriority);
      setAttemptHydrationAtPriority(runWithPriority);
      {
        if (typeof Map !== "function" || Map.prototype == null || typeof Map.prototype.forEach !== "function" || typeof Set !== "function" || Set.prototype == null || typeof Set.prototype.clear !== "function" || typeof Set.prototype.forEach !== "function") {
          error("React depends on Map and Set built-in types. Make sure that you load a " + "polyfill in older browsers. https://reactjs.org/link/react-polyfills");
        }
      }
      setRestoreImplementation(restoreControlledState$3);
      setBatchingImplementation(batchedUpdates$1, discreteUpdates, flushSync);
      function createPortal$1(children, container) {
        var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
        if (!isValidContainer(container)) {
          throw new Error("Target container is not a DOM element.");
        }
        return createPortal(children, container, null, key);
      }
      function renderSubtreeIntoContainer(parentComponent, element, containerNode, callback) {
        return unstable_renderSubtreeIntoContainer(parentComponent, element, containerNode, callback);
      }
      var Internals = {
        usingClientEntryPoint: false,
        Events: [getInstanceFromNode, getNodeFromInstance, getFiberCurrentPropsFromNode, enqueueStateRestore, restoreStateIfNeeded, batchedUpdates$1]
      };
      function createRoot$1(container, options2) {
        {
          if (!Internals.usingClientEntryPoint && true) {
            error('You are importing createRoot from "react-dom" which is not supported. ' + 'You should instead import it from "react-dom/client".');
          }
        }
        return createRoot(container, options2);
      }
      function hydrateRoot$1(container, initialChildren, options2) {
        {
          if (!Internals.usingClientEntryPoint && true) {
            error('You are importing hydrateRoot from "react-dom" which is not supported. ' + 'You should instead import it from "react-dom/client".');
          }
        }
        return hydrateRoot(container, initialChildren, options2);
      }
      function flushSync$1(fn) {
        {
          if (isAlreadyRendering()) {
            error("flushSync was called from inside a lifecycle method. React cannot " + "flush when React is already rendering. Consider moving this call to " + "a scheduler task or micro task.");
          }
        }
        return flushSync(fn);
      }
      var foundDevTools = injectIntoDevTools({
        findFiberByHostInstance: getClosestInstanceFromNode,
        bundleType: 1,
        version: ReactVersion,
        rendererPackageName: "react-dom"
      });
      {
        if (!foundDevTools && canUseDOM && window.top === window.self) {
          if (navigator.userAgent.indexOf("Chrome") > -1 && navigator.userAgent.indexOf("Edge") === -1 || navigator.userAgent.indexOf("Firefox") > -1) {
            var protocol = window.location.protocol;
            if (/^(https?|file):$/.test(protocol)) {
              console.info("%cDownload the React DevTools " + "for a better development experience: " + "https://reactjs.org/link/react-devtools" + (protocol === "file:" ? `
You might need to use a local HTTP server (instead of file://): ` + "https://reactjs.org/link/react-devtools-faq" : ""), "font-weight:bold");
            }
          }
        }
      }
      exports.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = Internals;
      exports.createPortal = createPortal$1;
      exports.createRoot = createRoot$1;
      exports.findDOMNode = findDOMNode;
      exports.flushSync = flushSync$1;
      exports.hydrate = hydrate;
      exports.hydrateRoot = hydrateRoot$1;
      exports.render = render;
      exports.unmountComponentAtNode = unmountComponentAtNode;
      exports.unstable_batchedUpdates = batchedUpdates$1;
      exports.unstable_renderSubtreeIntoContainer = renderSubtreeIntoContainer;
      exports.version = ReactVersion;
      if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== "undefined" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === "function") {
        __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error);
      }
    })();
  }
});

// node_modules/react-dom/index.js
var require_react_dom = __commonJS((exports, module) => {
  var react_dom_development = __toESM(require_react_dom_development());
  if (false) {} else {
    module.exports = react_dom_development;
  }
});

// node_modules/react-dom/client.js
var require_client = __commonJS((exports) => {
  var m = __toESM(require_react_dom());
  if (false) {} else {
    i = m.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    exports.createRoot = function(c, o) {
      i.usingClientEntryPoint = true;
      try {
        return m.createRoot(c, o);
      } finally {
        i.usingClientEntryPoint = false;
      }
    };
    exports.hydrateRoot = function(c, h, o) {
      i.usingClientEntryPoint = true;
      try {
        return m.hydrateRoot(c, h, o);
      } finally {
        i.usingClientEntryPoint = false;
      }
    };
  }
  var i;
});

// node_modules/react/cjs/react-jsx-dev-runtime.development.js
var require_react_jsx_dev_runtime_development = __commonJS((exports) => {
  var React = __toESM(require_react());
  if (true) {
    (function() {
      var REACT_ELEMENT_TYPE = Symbol.for("react.element");
      var REACT_PORTAL_TYPE = Symbol.for("react.portal");
      var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
      var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
      var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
      var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
      var REACT_CONTEXT_TYPE = Symbol.for("react.context");
      var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
      var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
      var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
      var REACT_MEMO_TYPE = Symbol.for("react.memo");
      var REACT_LAZY_TYPE = Symbol.for("react.lazy");
      var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
      var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        if (maybeIterable === null || typeof maybeIterable !== "object") {
          return null;
        }
        var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];
        if (typeof maybeIterator === "function") {
          return maybeIterator;
        }
        return null;
      }
      var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
      function error(format) {
        {
          {
            for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1;_key2 < _len2; _key2++) {
              args[_key2 - 1] = arguments[_key2];
            }
            printWarning("error", format, args);
          }
        }
      }
      function printWarning(level, format, args) {
        {
          var ReactDebugCurrentFrame2 = ReactSharedInternals.ReactDebugCurrentFrame;
          var stack = ReactDebugCurrentFrame2.getStackAddendum();
          if (stack !== "") {
            format += "%s";
            args = args.concat([stack]);
          }
          var argsWithFormat = args.map(function(item) {
            return String(item);
          });
          argsWithFormat.unshift("Warning: " + format);
          Function.prototype.apply.call(console[level], console, argsWithFormat);
        }
      }
      var enableScopeAPI = false;
      var enableCacheElement = false;
      var enableTransitionTracing = false;
      var enableLegacyHidden = false;
      var enableDebugTracing = false;
      var REACT_MODULE_REFERENCE;
      {
        REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
      }
      function isValidElementType(type) {
        if (typeof type === "string" || typeof type === "function") {
          return true;
        }
        if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
          return true;
        }
        if (typeof type === "object" && type !== null) {
          if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {
            return true;
          }
        }
        return false;
      }
      function getWrappedName(outerType, innerType, wrapperName) {
        var displayName = outerType.displayName;
        if (displayName) {
          return displayName;
        }
        var functionName = innerType.displayName || innerType.name || "";
        return functionName !== "" ? wrapperName + "(" + functionName + ")" : wrapperName;
      }
      function getContextName(type) {
        return type.displayName || "Context";
      }
      function getComponentNameFromType(type) {
        if (type == null) {
          return null;
        }
        {
          if (typeof type.tag === "number") {
            error("Received an unexpected object in getComponentNameFromType(). " + "This is likely a bug in React. Please file an issue.");
          }
        }
        if (typeof type === "function") {
          return type.displayName || type.name || null;
        }
        if (typeof type === "string") {
          return type;
        }
        switch (type) {
          case REACT_FRAGMENT_TYPE:
            return "Fragment";
          case REACT_PORTAL_TYPE:
            return "Portal";
          case REACT_PROFILER_TYPE:
            return "Profiler";
          case REACT_STRICT_MODE_TYPE:
            return "StrictMode";
          case REACT_SUSPENSE_TYPE:
            return "Suspense";
          case REACT_SUSPENSE_LIST_TYPE:
            return "SuspenseList";
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_CONTEXT_TYPE:
              var context = type;
              return getContextName(context) + ".Consumer";
            case REACT_PROVIDER_TYPE:
              var provider = type;
              return getContextName(provider._context) + ".Provider";
            case REACT_FORWARD_REF_TYPE:
              return getWrappedName(type, type.render, "ForwardRef");
            case REACT_MEMO_TYPE:
              var outerName = type.displayName || null;
              if (outerName !== null) {
                return outerName;
              }
              return getComponentNameFromType(type.type) || "Memo";
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return getComponentNameFromType(init(payload));
              } catch (x) {
                return null;
              }
            }
          }
        }
        return null;
      }
      var assign = Object.assign;
      var disabledDepth = 0;
      var prevLog;
      var prevInfo;
      var prevWarn;
      var prevError;
      var prevGroup;
      var prevGroupCollapsed;
      var prevGroupEnd;
      function disabledLog() {}
      disabledLog.__reactDisabledLog = true;
      function disableLogs() {
        {
          if (disabledDepth === 0) {
            prevLog = console.log;
            prevInfo = console.info;
            prevWarn = console.warn;
            prevError = console.error;
            prevGroup = console.group;
            prevGroupCollapsed = console.groupCollapsed;
            prevGroupEnd = console.groupEnd;
            var props = {
              configurable: true,
              enumerable: true,
              value: disabledLog,
              writable: true
            };
            Object.defineProperties(console, {
              info: props,
              log: props,
              warn: props,
              error: props,
              group: props,
              groupCollapsed: props,
              groupEnd: props
            });
          }
          disabledDepth++;
        }
      }
      function reenableLogs() {
        {
          disabledDepth--;
          if (disabledDepth === 0) {
            var props = {
              configurable: true,
              enumerable: true,
              writable: true
            };
            Object.defineProperties(console, {
              log: assign({}, props, {
                value: prevLog
              }),
              info: assign({}, props, {
                value: prevInfo
              }),
              warn: assign({}, props, {
                value: prevWarn
              }),
              error: assign({}, props, {
                value: prevError
              }),
              group: assign({}, props, {
                value: prevGroup
              }),
              groupCollapsed: assign({}, props, {
                value: prevGroupCollapsed
              }),
              groupEnd: assign({}, props, {
                value: prevGroupEnd
              })
            });
          }
          if (disabledDepth < 0) {
            error("disabledDepth fell below zero. " + "This is a bug in React. Please file an issue.");
          }
        }
      }
      var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;
      var prefix;
      function describeBuiltInComponentFrame(name, source, ownerFn) {
        {
          if (prefix === undefined) {
            try {
              throw Error();
            } catch (x) {
              var match = x.stack.trim().match(/\n( *(at )?)/);
              prefix = match && match[1] || "";
            }
          }
          return `
` + prefix + name;
        }
      }
      var reentry = false;
      var componentFrameCache;
      {
        var PossiblyWeakMap = typeof WeakMap === "function" ? WeakMap : Map;
        componentFrameCache = new PossiblyWeakMap;
      }
      function describeNativeComponentFrame(fn, construct) {
        if (!fn || reentry) {
          return "";
        }
        {
          var frame = componentFrameCache.get(fn);
          if (frame !== undefined) {
            return frame;
          }
        }
        var control;
        reentry = true;
        var previousPrepareStackTrace = Error.prepareStackTrace;
        Error.prepareStackTrace = undefined;
        var previousDispatcher;
        {
          previousDispatcher = ReactCurrentDispatcher.current;
          ReactCurrentDispatcher.current = null;
          disableLogs();
        }
        try {
          if (construct) {
            var Fake = function() {
              throw Error();
            };
            Object.defineProperty(Fake.prototype, "props", {
              set: function() {
                throw Error();
              }
            });
            if (typeof Reflect === "object" && Reflect.construct) {
              try {
                Reflect.construct(Fake, []);
              } catch (x) {
                control = x;
              }
              Reflect.construct(fn, [], Fake);
            } else {
              try {
                Fake.call();
              } catch (x) {
                control = x;
              }
              fn.call(Fake.prototype);
            }
          } else {
            try {
              throw Error();
            } catch (x) {
              control = x;
            }
            fn();
          }
        } catch (sample) {
          if (sample && control && typeof sample.stack === "string") {
            var sampleLines = sample.stack.split(`
`);
            var controlLines = control.stack.split(`
`);
            var s = sampleLines.length - 1;
            var c = controlLines.length - 1;
            while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {
              c--;
            }
            for (;s >= 1 && c >= 0; s--, c--) {
              if (sampleLines[s] !== controlLines[c]) {
                if (s !== 1 || c !== 1) {
                  do {
                    s--;
                    c--;
                    if (c < 0 || sampleLines[s] !== controlLines[c]) {
                      var _frame = `
` + sampleLines[s].replace(" at new ", " at ");
                      if (fn.displayName && _frame.includes("<anonymous>")) {
                        _frame = _frame.replace("<anonymous>", fn.displayName);
                      }
                      {
                        if (typeof fn === "function") {
                          componentFrameCache.set(fn, _frame);
                        }
                      }
                      return _frame;
                    }
                  } while (s >= 1 && c >= 0);
                }
                break;
              }
            }
          }
        } finally {
          reentry = false;
          {
            ReactCurrentDispatcher.current = previousDispatcher;
            reenableLogs();
          }
          Error.prepareStackTrace = previousPrepareStackTrace;
        }
        var name = fn ? fn.displayName || fn.name : "";
        var syntheticFrame = name ? describeBuiltInComponentFrame(name) : "";
        {
          if (typeof fn === "function") {
            componentFrameCache.set(fn, syntheticFrame);
          }
        }
        return syntheticFrame;
      }
      function describeFunctionComponentFrame(fn, source, ownerFn) {
        {
          return describeNativeComponentFrame(fn, false);
        }
      }
      function shouldConstruct(Component) {
        var prototype = Component.prototype;
        return !!(prototype && prototype.isReactComponent);
      }
      function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {
        if (type == null) {
          return "";
        }
        if (typeof type === "function") {
          {
            return describeNativeComponentFrame(type, shouldConstruct(type));
          }
        }
        if (typeof type === "string") {
          return describeBuiltInComponentFrame(type);
        }
        switch (type) {
          case REACT_SUSPENSE_TYPE:
            return describeBuiltInComponentFrame("Suspense");
          case REACT_SUSPENSE_LIST_TYPE:
            return describeBuiltInComponentFrame("SuspenseList");
        }
        if (typeof type === "object") {
          switch (type.$$typeof) {
            case REACT_FORWARD_REF_TYPE:
              return describeFunctionComponentFrame(type.render);
            case REACT_MEMO_TYPE:
              return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);
            case REACT_LAZY_TYPE: {
              var lazyComponent = type;
              var payload = lazyComponent._payload;
              var init = lazyComponent._init;
              try {
                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);
              } catch (x) {}
            }
          }
        }
        return "";
      }
      var hasOwnProperty = Object.prototype.hasOwnProperty;
      var loggedTypeFailures = {};
      var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame.setExtraStackFrame(null);
          }
        }
      }
      function checkPropTypes(typeSpecs, values, location2, componentName, element) {
        {
          var has = Function.call.bind(hasOwnProperty);
          for (var typeSpecName in typeSpecs) {
            if (has(typeSpecs, typeSpecName)) {
              var error$1 = undefined;
              try {
                if (typeof typeSpecs[typeSpecName] !== "function") {
                  var err = Error((componentName || "React class") + ": " + location2 + " type `" + typeSpecName + "` is invalid; " + "it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`." + "This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                  err.name = "Invariant Violation";
                  throw err;
                }
                error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
              } catch (ex) {
                error$1 = ex;
              }
              if (error$1 && !(error$1 instanceof Error)) {
                setCurrentlyValidatingElement(element);
                error("%s: type specification of %s" + " `%s` is invalid; the type checker " + "function must return `null` or an `Error` but returned a %s. " + "You may have forgotten to pass an argument to the type checker " + "creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and " + "shape all require an argument).", componentName || "React class", location2, typeSpecName, typeof error$1);
                setCurrentlyValidatingElement(null);
              }
              if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {
                loggedTypeFailures[error$1.message] = true;
                setCurrentlyValidatingElement(element);
                error("Failed %s type: %s", location2, error$1.message);
                setCurrentlyValidatingElement(null);
              }
            }
          }
        }
      }
      var isArrayImpl = Array.isArray;
      function isArray(a2) {
        return isArrayImpl(a2);
      }
      function typeName(value) {
        {
          var hasToStringTag = typeof Symbol === "function" && Symbol.toStringTag;
          var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || "Object";
          return type;
        }
      }
      function willCoercionThrow(value) {
        {
          try {
            testStringCoercion(value);
            return false;
          } catch (e) {
            return true;
          }
        }
      }
      function testStringCoercion(value) {
        return "" + value;
      }
      function checkKeyStringCoercion(value) {
        {
          if (willCoercionThrow(value)) {
            error("The provided key is an unsupported type %s." + " This value must be coerced to a string before before using it here.", typeName(value));
            return testStringCoercion(value);
          }
        }
      }
      var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;
      var RESERVED_PROPS = {
        key: true,
        ref: true,
        __self: true,
        __source: true
      };
      var specialPropKeyWarningShown;
      var specialPropRefWarningShown;
      var didWarnAboutStringRefs;
      {
        didWarnAboutStringRefs = {};
      }
      function hasValidRef(config) {
        {
          if (hasOwnProperty.call(config, "ref")) {
            var getter = Object.getOwnPropertyDescriptor(config, "ref").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.ref !== undefined;
      }
      function hasValidKey(config) {
        {
          if (hasOwnProperty.call(config, "key")) {
            var getter = Object.getOwnPropertyDescriptor(config, "key").get;
            if (getter && getter.isReactWarning) {
              return false;
            }
          }
        }
        return config.key !== undefined;
      }
      function warnIfStringRefCannotBeAutoConverted(config, self) {
        {
          if (typeof config.ref === "string" && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {
            var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);
            if (!didWarnAboutStringRefs[componentName]) {
              error('Component "%s" contains the string ref "%s". ' + "Support for string refs will be removed in a future major release. " + "This case cannot be automatically converted to an arrow function. " + "We ask you to manually fix this case by using useRef() or createRef() instead. " + "Learn more about using refs safely here: " + "https://reactjs.org/link/strict-mode-string-ref", getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);
              didWarnAboutStringRefs[componentName] = true;
            }
          }
        }
      }
      function defineKeyPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingKey = function() {
            if (!specialPropKeyWarningShown) {
              specialPropKeyWarningShown = true;
              error("%s: `key` is not a prop. Trying to access it will result " + "in `undefined` being returned. If you need to access the same " + "value within the child component, you should pass it as a different " + "prop. (https://reactjs.org/link/special-props)", displayName);
            }
          };
          warnAboutAccessingKey.isReactWarning = true;
          Object.defineProperty(props, "key", {
            get: warnAboutAccessingKey,
            configurable: true
          });
        }
      }
      function defineRefPropWarningGetter(props, displayName) {
        {
          var warnAboutAccessingRef = function() {
            if (!specialPropRefWarningShown) {
              specialPropRefWarningShown = true;
              error("%s: `ref` is not a prop. Trying to access it will result " + "in `undefined` being returned. If you need to access the same " + "value within the child component, you should pass it as a different " + "prop. (https://reactjs.org/link/special-props)", displayName);
            }
          };
          warnAboutAccessingRef.isReactWarning = true;
          Object.defineProperty(props, "ref", {
            get: warnAboutAccessingRef,
            configurable: true
          });
        }
      }
      var ReactElement = function(type, key, ref, self, source, owner, props) {
        var element = {
          $$typeof: REACT_ELEMENT_TYPE,
          type,
          key,
          ref,
          props,
          _owner: owner
        };
        {
          element._store = {};
          Object.defineProperty(element._store, "validated", {
            configurable: false,
            enumerable: false,
            writable: true,
            value: false
          });
          Object.defineProperty(element, "_self", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: self
          });
          Object.defineProperty(element, "_source", {
            configurable: false,
            enumerable: false,
            writable: false,
            value: source
          });
          if (Object.freeze) {
            Object.freeze(element.props);
            Object.freeze(element);
          }
        }
        return element;
      };
      function jsxDEV(type, config, maybeKey, source, self) {
        {
          var propName;
          var props = {};
          var key = null;
          var ref = null;
          if (maybeKey !== undefined) {
            {
              checkKeyStringCoercion(maybeKey);
            }
            key = "" + maybeKey;
          }
          if (hasValidKey(config)) {
            {
              checkKeyStringCoercion(config.key);
            }
            key = "" + config.key;
          }
          if (hasValidRef(config)) {
            ref = config.ref;
            warnIfStringRefCannotBeAutoConverted(config, self);
          }
          for (propName in config) {
            if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {
              props[propName] = config[propName];
            }
          }
          if (type && type.defaultProps) {
            var defaultProps = type.defaultProps;
            for (propName in defaultProps) {
              if (props[propName] === undefined) {
                props[propName] = defaultProps[propName];
              }
            }
          }
          if (key || ref) {
            var displayName = typeof type === "function" ? type.displayName || type.name || "Unknown" : type;
            if (key) {
              defineKeyPropWarningGetter(props, displayName);
            }
            if (ref) {
              defineRefPropWarningGetter(props, displayName);
            }
          }
          return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);
        }
      }
      var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;
      var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;
      function setCurrentlyValidatingElement$1(element) {
        {
          if (element) {
            var owner = element._owner;
            var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);
            ReactDebugCurrentFrame$1.setExtraStackFrame(stack);
          } else {
            ReactDebugCurrentFrame$1.setExtraStackFrame(null);
          }
        }
      }
      var propTypesMisspellWarningShown;
      {
        propTypesMisspellWarningShown = false;
      }
      function isValidElement(object) {
        {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
      }
      function getDeclarationErrorAddendum() {
        {
          if (ReactCurrentOwner$1.current) {
            var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);
            if (name) {
              return `

Check the render method of \`` + name + "`.";
            }
          }
          return "";
        }
      }
      function getSourceInfoErrorAddendum(source) {
        {
          if (source !== undefined) {
            var fileName = source.fileName.replace(/^.*[\\\/]/, "");
            var lineNumber = source.lineNumber;
            return `

Check your code at ` + fileName + ":" + lineNumber + ".";
          }
          return "";
        }
      }
      var ownerHasKeyUseWarning = {};
      function getCurrentComponentErrorInfo(parentType) {
        {
          var info = getDeclarationErrorAddendum();
          if (!info) {
            var parentName = typeof parentType === "string" ? parentType : parentType.displayName || parentType.name;
            if (parentName) {
              info = `

Check the top-level render call using <` + parentName + ">.";
            }
          }
          return info;
        }
      }
      function validateExplicitKey(element, parentType) {
        {
          if (!element._store || element._store.validated || element.key != null) {
            return;
          }
          element._store.validated = true;
          var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);
          if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {
            return;
          }
          ownerHasKeyUseWarning[currentComponentErrorInfo] = true;
          var childOwner = "";
          if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {
            childOwner = " It was passed a child from " + getComponentNameFromType(element._owner.type) + ".";
          }
          setCurrentlyValidatingElement$1(element);
          error('Each child in a list should have a unique "key" prop.' + "%s%s See https://reactjs.org/link/warning-keys for more information.", currentComponentErrorInfo, childOwner);
          setCurrentlyValidatingElement$1(null);
        }
      }
      function validateChildKeys(node, parentType) {
        {
          if (typeof node !== "object") {
            return;
          }
          if (isArray(node)) {
            for (var i = 0;i < node.length; i++) {
              var child = node[i];
              if (isValidElement(child)) {
                validateExplicitKey(child, parentType);
              }
            }
          } else if (isValidElement(node)) {
            if (node._store) {
              node._store.validated = true;
            }
          } else if (node) {
            var iteratorFn = getIteratorFn(node);
            if (typeof iteratorFn === "function") {
              if (iteratorFn !== node.entries) {
                var iterator = iteratorFn.call(node);
                var step;
                while (!(step = iterator.next()).done) {
                  if (isValidElement(step.value)) {
                    validateExplicitKey(step.value, parentType);
                  }
                }
              }
            }
          }
        }
      }
      function validatePropTypes(element) {
        {
          var type = element.type;
          if (type === null || type === undefined || typeof type === "string") {
            return;
          }
          var propTypes;
          if (typeof type === "function") {
            propTypes = type.propTypes;
          } else if (typeof type === "object" && (type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_MEMO_TYPE)) {
            propTypes = type.propTypes;
          } else {
            return;
          }
          if (propTypes) {
            var name = getComponentNameFromType(type);
            checkPropTypes(propTypes, element.props, "prop", name, element);
          } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {
            propTypesMisspellWarningShown = true;
            var _name = getComponentNameFromType(type);
            error("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", _name || "Unknown");
          }
          if (typeof type.getDefaultProps === "function" && !type.getDefaultProps.isReactClassApproved) {
            error("getDefaultProps is only used on classic React.createClass " + "definitions. Use a static property named `defaultProps` instead.");
          }
        }
      }
      function validateFragmentProps(fragment) {
        {
          var keys = Object.keys(fragment.props);
          for (var i = 0;i < keys.length; i++) {
            var key = keys[i];
            if (key !== "children" && key !== "key") {
              setCurrentlyValidatingElement$1(fragment);
              error("Invalid prop `%s` supplied to `React.Fragment`. " + "React.Fragment can only have `key` and `children` props.", key);
              setCurrentlyValidatingElement$1(null);
              break;
            }
          }
          if (fragment.ref !== null) {
            setCurrentlyValidatingElement$1(fragment);
            error("Invalid attribute `ref` supplied to `React.Fragment`.");
            setCurrentlyValidatingElement$1(null);
          }
        }
      }
      var didWarnAboutKeySpread = {};
      function jsxWithValidation(type, props, key, isStaticChildren, source, self) {
        {
          var validType = isValidElementType(type);
          if (!validType) {
            var info = "";
            if (type === undefined || typeof type === "object" && type !== null && Object.keys(type).length === 0) {
              info += " You likely forgot to export your component from the file " + "it's defined in, or you might have mixed up default and named imports.";
            }
            var sourceInfo = getSourceInfoErrorAddendum(source);
            if (sourceInfo) {
              info += sourceInfo;
            } else {
              info += getDeclarationErrorAddendum();
            }
            var typeString;
            if (type === null) {
              typeString = "null";
            } else if (isArray(type)) {
              typeString = "array";
            } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {
              typeString = "<" + (getComponentNameFromType(type.type) || "Unknown") + " />";
              info = " Did you accidentally export a JSX literal instead of a component?";
            } else {
              typeString = typeof type;
            }
            error("React.jsx: type is invalid -- expected a string (for " + "built-in components) or a class/function (for composite " + "components) but got: %s.%s", typeString, info);
          }
          var element = jsxDEV(type, props, key, source, self);
          if (element == null) {
            return element;
          }
          if (validType) {
            var children = props.children;
            if (children !== undefined) {
              if (isStaticChildren) {
                if (isArray(children)) {
                  for (var i = 0;i < children.length; i++) {
                    validateChildKeys(children[i], type);
                  }
                  if (Object.freeze) {
                    Object.freeze(children);
                  }
                } else {
                  error("React.jsx: Static children should always be an array. " + "You are likely explicitly calling React.jsxs or React.jsxDEV. " + "Use the Babel transform instead.");
                }
              } else {
                validateChildKeys(children, type);
              }
            }
          }
          {
            if (hasOwnProperty.call(props, "key")) {
              var componentName = getComponentNameFromType(type);
              var keys = Object.keys(props).filter(function(k) {
                return k !== "key";
              });
              var beforeExample = keys.length > 0 ? "{key: someKey, " + keys.join(": ..., ") + ": ...}" : "{key: someKey}";
              if (!didWarnAboutKeySpread[componentName + beforeExample]) {
                var afterExample = keys.length > 0 ? "{" + keys.join(": ..., ") + ": ...}" : "{}";
                error(`A props object containing a "key" prop is being spread into JSX:
` + `  let props = %s;
` + `  <%s {...props} />
` + `React keys must be passed directly to JSX without using spread:
` + `  let props = %s;
` + "  <%s key={someKey} {...props} />", beforeExample, componentName, afterExample, componentName);
                didWarnAboutKeySpread[componentName + beforeExample] = true;
              }
            }
          }
          if (type === REACT_FRAGMENT_TYPE) {
            validateFragmentProps(element);
          } else {
            validatePropTypes(element);
          }
          return element;
        }
      }
      var jsxDEV$1 = jsxWithValidation;
      exports.Fragment = REACT_FRAGMENT_TYPE;
      exports.jsxDEV = jsxDEV$1;
    })();
  }
});

// node_modules/react/jsx-dev-runtime.js
var require_jsx_dev_runtime = __commonJS((exports, module) => {
  var react_jsx_dev_runtime_development = __toESM(require_react_jsx_dev_runtime_development());
  if (false) {} else {
    module.exports = react_jsx_dev_runtime_development;
  }
});

// demo/src/index.tsx
var import_client = __toESM(require_client(), 1);

// node_modules/tosijs/dist/module.js
var H = { debug: false, perf: false };
function C(n) {
  if (n == null || typeof n !== "object")
    return n;
  if (n instanceof Set)
    return new Set(n);
  else if (Array.isArray(n))
    return n.map(C);
  let e = {};
  for (let o in n) {
    let i = n[o];
    if (n != null && typeof n === "object")
      e[o] = C(i);
    else
      e[o] = i;
  }
  return e;
}
var un = "-xin-data";
var L = `.${un}`;
var pn = "-xin-event";
var yn = `.${pn}`;
var b = "xinPath";
var O = "xinValue";
var Yn = "xinSet";
var Jn = "xinObserve";
var Vn = "xinBind";
var _n = "xinOn";
var M = (n) => {
  return n && n[b] || undefined;
};
function w(n) {
  return typeof n === "object" && n !== null ? n[O] || n : n;
}
var $ = new WeakMap;
var v = new WeakMap;
var z = (n) => {
  let e = n.cloneNode();
  if (e instanceof Element) {
    let o = v.get(n), i = $.get(n);
    if (o != null)
      v.set(e, C(o));
    if (i != null)
      $.set(e, C(i));
  }
  for (let o of Array.from(n instanceof HTMLTemplateElement ? n.content.childNodes : n.childNodes))
    if (o instanceof Element || o instanceof DocumentFragment)
      e.appendChild(z(o));
    else
      e.appendChild(o.cloneNode());
  return e;
};
var U = new WeakMap;
var mn = (n) => {
  let e = document.body.parentElement;
  while (n.parentElement != null && n.parentElement !== e) {
    let o = U.get(n);
    if (o != null)
      return o;
    n = n.parentElement;
  }
  return false;
};
var Un = Symbol("observer should be removed");
var N = [];
var nn = [];
var xn = false;
var hn;
var bn;

class Gn {
  description;
  test;
  callback;
  constructor(n, e) {
    let o = typeof e === "string" ? `"${e}"` : `function ${e.name}`, i;
    if (typeof n === "string")
      this.test = (t) => typeof t === "string" && t !== "" && (n.startsWith(t) || t.startsWith(n)), i = `test = "${n}"`;
    else if (n instanceof RegExp)
      this.test = n.test.bind(n), i = `test = "${n.toString()}"`;
    else if (n instanceof Function)
      this.test = n, i = `test = function ${n.name}`;
    else
      throw Error("expect listener test to be a string, RegExp, or test function");
    if (this.description = `${i}, ${o}`, typeof e === "function")
      this.callback = e;
    else
      throw Error("expect callback to be a path or function");
    N.push(this);
  }
}
var ge = () => {
  if (H.perf)
    console.time("xin async update");
  let n = Array.from(nn);
  for (let e of n)
    N.filter((o) => {
      let i;
      try {
        i = o.test(e);
      } catch (t) {
        throw Error(`Listener ${o.description} threw "${t}" at "${e}"`);
      }
      if (i === Un)
        return G(o), false;
      return i;
    }).forEach((o) => {
      let i;
      try {
        i = o.callback(e);
      } catch (t) {
        console.error(`Listener ${o.description} threw "${t}" handling "${e}"`);
      }
      if (i === Un)
        G(o);
    });
  if (nn.splice(0), xn = false, typeof bn === "function")
    bn();
  if (H.perf)
    console.timeEnd("xin async update");
};
var W = (n) => {
  let e = typeof n === "string" ? n : M(n);
  if (e === undefined)
    throw console.error("touch was called on an invalid target", n), Error("touch was called on an invalid target");
  if (xn === false)
    hn = new Promise((o) => {
      bn = o;
    }), xn = setTimeout(ge);
  if (nn.find((o) => e.startsWith(o)) == null)
    nn.push(e);
};
var wn = (n, e) => {
  return new Gn(n, e);
};
var G = (n) => {
  let e = N.indexOf(n);
  if (e > -1)
    N.splice(e, 1);
  else
    throw Error("unobserve failed, listener not found");
};
var Te = (n) => {
  try {
    return JSON.stringify(n);
  } catch (e) {
    return "{has circular references}";
  }
};
var gn = (...n) => Error(n.map(Te).join(" "));
var Xe = () => new Date(parseInt("1000000000", 36) + Date.now()).valueOf().toString(36).slice(1);
var Se = 0;
var Ee = () => (parseInt("10000", 36) + ++Se).toString(36).slice(-5);
var ke = () => Xe() + Ee();
var Xn = Symbol("delete");
var Kn = Symbol("new-object");
var Tn = Symbol("automatic-index");
function Rn(n) {
  if (n === "")
    return [];
  if (Array.isArray(n))
    return n;
  else {
    let e = [];
    while (n.length > 0) {
      let o = n.search(/\[[^\]]+\]/);
      if (o === -1) {
        e.push(n.split("."));
        break;
      } else {
        let i = n.slice(0, o);
        if (n = n.slice(o), i !== "")
          e.push(i.split("."));
        if (o = n.indexOf("]") + 1, e.push(n.slice(1, o - 1)), n.slice(o, o + 1) === ".")
          o += 1;
        n = n.slice(o);
      }
    }
    return e;
  }
}
var D = new WeakMap;
function Nn(n, e) {
  if (D.get(n) === undefined)
    D.set(n, {});
  if (D.get(n)[e] === undefined)
    D.get(n)[e] = {};
  let o = D.get(n)[e];
  if (e === "_auto_")
    n.forEach((i, t) => {
      if (i[Tn] === undefined)
        i[Tn] = ke();
      o[i[Tn] + ""] = t;
    });
  else
    n.forEach((i, t) => {
      o[I(i, e) + ""] = t;
    });
  return o;
}
function Ce(n, e) {
  if (D.get(n) === undefined || D.get(n)[e] === undefined)
    return Nn(n, e);
  else
    return D.get(n)[e];
}
function ve(n, e, o) {
  o = o + "";
  let i = Ce(n, e)[o];
  if (i === undefined || I(n[i], e) + "" !== o)
    i = Nn(n, e)[o];
  return i;
}
function Me(n, e, o) {
  if (n[e] === undefined && o !== undefined)
    n[e] = o;
  return n[e];
}
function ne(n, e, o, i) {
  let t = e !== "" ? ve(n, e, o) : o;
  if (i === Xn)
    return n.splice(t, 1), D.delete(n), Symbol("deleted");
  else if (i === Kn) {
    if (e === "" && n[t] === undefined)
      n[t] = {};
  } else if (i !== undefined)
    if (t !== undefined)
      n[t] = i;
    else if (e !== "" && I(i, e) + "" === o + "")
      n.push(i), t = n.length - 1;
    else
      throw Error(`byIdPath insert failed at [${e}=${o}]`);
  return n[t];
}
function qn(n) {
  if (!Array.isArray(n))
    throw gn("setByPath failed: expected array, found", n);
}
function Qn(n) {
  if (n == null || !(n instanceof Object))
    throw gn("setByPath failed: expected Object, found", n);
}
function I(n, e) {
  let o = Rn(e), i = n, t, s, r, c;
  for (t = 0, s = o.length;i !== undefined && t < s; t++) {
    let d = o[t];
    if (Array.isArray(d))
      for (r = 0, c = d.length;i !== undefined && r < c; r++) {
        let l = d[r];
        i = i[l];
      }
    else if (i.length === 0) {
      if (i = i[Number(d.slice(1))], d[0] !== "=")
        return;
    } else if (d.includes("=")) {
      let [l, ...p] = d.split("=");
      i = ne(i, l, p.join("="));
    } else
      r = parseInt(d, 10), i = i[r];
  }
  return i;
}
function ee(n, e, o) {
  let i = n;
  if (e === "")
    throw Error("setByPath cannot be used to set the root object");
  let t = Rn(e);
  while (i != null && t.length > 0) {
    let s = t.shift();
    if (typeof s === "string") {
      let r = s.indexOf("=");
      if (r > -1) {
        if (r === 0)
          Qn(i);
        else
          qn(i);
        let c = s.slice(0, r), d = s.slice(r + 1);
        if (i = ne(i, c, d, t.length > 0 ? Kn : o), t.length === 0)
          return true;
      } else {
        qn(i);
        let c = parseInt(s, 10);
        if (t.length > 0)
          i = i[c];
        else {
          if (o !== Xn) {
            if (i[c] === o)
              return false;
            i[c] = o;
          } else
            i.splice(c, 1);
          return true;
        }
      }
    } else if (Array.isArray(s) && s.length > 0) {
      Qn(i);
      while (s.length > 0) {
        let r = s.shift();
        if (s.length > 0 || t.length > 0)
          i = Me(i, r, s.length > 0 ? {} : []);
        else {
          if (o !== Xn) {
            if (i[r] === o)
              return false;
            i[r] = o;
          } else {
            if (!Object.prototype.hasOwnProperty.call(i, r))
              return false;
            delete i[r];
          }
          return true;
        }
      }
    } else
      throw Error(`setByPath failed, bad path ${e}`);
  }
  throw Error(`setByPath(${n}, ${e}, ${o}) failed`);
}
var De = ["sort", "splice", "copyWithin", "fill", "pop", "push", "reverse", "shift", "unshift"];
var En = {};
var Fe = true;
var Le = /^\.?([^.[\](),])+(\.[^.[\](),]+|\[\d+\]|\[[^=[\](),]*=[^[\]()]+\])*$/;
var Be = (n) => Le.test(n);
var A = (n = "", e = "") => {
  if (n === "")
    return e;
  else if (e.match(/^\d+$/) !== null || e.includes("="))
    return `${n}[${e}]`;
  else
    return `${n}.${e}`;
};
var He = { string(n) {
  return new String(n);
}, boolean(n) {
  return new Boolean(n);
}, bigint(n) {
  return n;
}, symbol(n) {
  return n;
}, number(n) {
  return new Number(n);
} };
function Sn(n, e) {
  let o = typeof n;
  if (n === undefined || o === "object" || o === "function")
    return n;
  else
    return new Proxy(He[typeof n](n), Y(e, true));
}
var Y = (n, e) => ({ get(o, i) {
  switch (i) {
    case b:
      return n;
    case O:
      return o.valueOf ? o.valueOf() : o;
    case Yn:
      return (r) => f[n] = r;
    case Jn:
      return (r) => {
        let c = wn(n, r);
        return () => G(c);
      };
    case _n:
      return (r, c) => P(r, c, w(o));
    case Vn:
      return (r, c, d) => {
        g(r, n, c, d);
      };
  }
  if (typeof i === "symbol")
    return o[i];
  let t = i, s = t.match(/^([^.[]+)\.(.+)$/) ?? t.match(/^([^\]]+)(\[.+)/) ?? t.match(/^(\[[^\]]+\])\.(.+)$/) ?? t.match(/^(\[[^\]]+\])\[(.+)$/);
  if (s !== null) {
    let [, r, c] = s, d = A(n, r), l = I(o, r);
    return l !== null && typeof l === "object" ? new Proxy(l, Y(d, e))[c] : l;
  }
  if (t.startsWith("[") && t.endsWith("]"))
    t = t.substring(1, t.length - 1);
  if (!Array.isArray(o) && o[t] !== undefined || Array.isArray(o) && t.includes("=")) {
    let r;
    if (t.includes("=")) {
      let [c, d] = t.split("=");
      r = o.find((l) => `${I(l, c)}` === d);
    } else
      r = o[t];
    if (r instanceof Object) {
      let c = A(n, t);
      return new Proxy(r instanceof Function ? r.bind(o) : r, Y(c, e));
    } else
      return e ? Sn(r, A(n, t)) : r;
  } else if (Array.isArray(o)) {
    let r = o[t];
    return typeof r === "function" ? (...c) => {
      let d = r.apply(o, c);
      if (De.includes(t))
        W(n);
      return d;
    } : typeof r === "object" ? new Proxy(r, Y(A(n, t), e)) : e ? Sn(r, A(n, t)) : r;
  } else
    return e ? Sn(o[t], A(n, t)) : o[t];
}, set(o, i, t) {
  t = w(t);
  let s = i !== O ? A(n, i) : n;
  if (Fe && !Be(s))
    throw Error(`setting invalid path ${s}`);
  if (w(f[s]) !== t && ee(En, s, t))
    W(s);
  return true;
} });
var Z = (n, e) => {
  let o = typeof e === "function" ? e : f[e];
  if (typeof o !== "function")
    throw Error(`observe expects a function or path to a function, ${e} is neither`);
  return wn(n, o);
};
var f = new Proxy(En, Y("", false));
var J = new Proxy(En, Y("", true));
var kn = (n, e) => {
  let o = new Event(e);
  n.dispatchEvent(o);
};
var ie = (n) => {
  if (n instanceof HTMLInputElement)
    return n.type;
  else if (n instanceof HTMLSelectElement && n.hasAttribute("multiple"))
    return "multi-select";
  else
    return "other";
};
var te = (n, e) => {
  switch (ie(n)) {
    case "radio":
      n.checked = n.value === e;
      break;
    case "checkbox":
      n.checked = !!e;
      break;
    case "date":
      n.valueAsDate = new Date(e);
      break;
    case "multi-select":
      for (let o of Array.from(n.querySelectorAll("option")))
        o.selected = e[o.value];
      break;
    default:
      n.value = e;
  }
};
var re = (n) => {
  switch (ie(n)) {
    case "radio": {
      let e = n.parentElement?.querySelector(`[name="${n.name}"]:checked`);
      return e != null ? e.value : null;
    }
    case "checkbox":
      return n.checked;
    case "date":
      return n.valueAsDate?.toISOString();
    case "multi-select":
      return Array.from(n.querySelectorAll("option")).reduce((e, o) => {
        return e[o.value] = o.selected, e;
      }, {});
    default:
      return n.value;
  }
};
var { ResizeObserver: oe } = globalThis;
var q = oe != null ? new oe((n) => {
  for (let e of n) {
    let o = e.target;
    kn(o, "resize");
  }
}) : { observe() {}, unobserve() {} };
var Cn = (n, e, o = true) => {
  if (n != null && e != null)
    if (typeof e === "string")
      n.textContent = e;
    else if (Array.isArray(e))
      e.forEach((i) => {
        n.append(i instanceof Node && o ? z(i) : i);
      });
    else if (e instanceof Node)
      n.append(o ? z(e) : e);
    else
      throw Error("expect text content or document node");
};
var en = (n, e = 250) => {
  let o, i = Date.now() - e, t = false;
  return (...s) => {
    if (clearTimeout(o), o = setTimeout(() => {
      n(...s), i = Date.now();
    }, e), !t && Date.now() - i >= e) {
      t = true;
      try {
        n(...s), i = Date.now();
      } finally {
        t = false;
      }
    }
  };
};
var on = Symbol("list-binding");
var $e = 16;
var Oe = 100;
function se(n, e) {
  let o = Array.from(n.querySelectorAll(L));
  if (n.matches(L))
    o.unshift(n);
  for (let i of o) {
    let t = v.get(i);
    for (let s of t) {
      if (s.path.startsWith("^"))
        s.path = `${e}${s.path.substring(1)}`;
      if (s.binding.toDOM != null)
        s.binding.toDOM(i, f[s.path]);
    }
  }
}

class ce {
  boundElement;
  listTop;
  listBottom;
  template;
  options;
  itemToElement;
  _array = [];
  _update;
  _previousSlice;
  static filterBoundObservers = new WeakMap;
  constructor(n, e, o = {}) {
    if (this.boundElement = n, this.itemToElement = new WeakMap, n.children.length !== 1)
      throw Error("ListBinding expects an element with exactly one child element");
    if (n.children[0] instanceof HTMLTemplateElement) {
      let i = n.children[0];
      if (i.content.children.length !== 1)
        throw Error("ListBinding expects a template with exactly one child element");
      this.template = z(i.content.children[0]);
    } else
      this.template = n.children[0], this.template.remove();
    if (this.options = o, this.listTop = document.createElement("div"), this.listBottom = document.createElement("div"), this.listTop.classList.add("virtual-list-padding"), this.listBottom.classList.add("virtual-list-padding"), this.boundElement.append(this.listTop), this.boundElement.append(this.listBottom), o.virtual != null)
      q.observe(this.boundElement), this._update = en(() => {
        this.update(this._array, true);
      }, $e), this.boundElement.addEventListener("scroll", this._update), this.boundElement.addEventListener("resize", this._update);
  }
  visibleSlice() {
    let { virtual: n, hiddenProp: e, visibleProp: o } = this.options, i = this._array;
    if (e !== undefined)
      i = i.filter((d) => d[e] !== true);
    if (o !== undefined)
      i = i.filter((d) => d[o] === true);
    if (this.options.filter && this.needle !== undefined)
      i = this.options.filter(i, this.needle);
    let t = 0, s = i.length - 1, r = 0, c = 0;
    if (n != null && this.boundElement instanceof HTMLElement) {
      let d = this.boundElement.offsetWidth, l = this.boundElement.offsetHeight;
      if (n.visibleColumns == null)
        n.visibleColumns = n.width != null ? Math.max(1, Math.floor(d / n.width)) : 1;
      let p = Math.ceil(l / n.height) + (n.rowChunkSize || 1), S = Math.ceil(i.length / n.visibleColumns), E = n.visibleColumns * p, y = Math.floor(this.boundElement.scrollTop / n.height);
      if (y > S - p + 1)
        y = Math.max(0, S - p + 1);
      if (n.rowChunkSize)
        y -= y % n.rowChunkSize;
      t = y * n.visibleColumns, s = t + E - 1, r = y * n.height, c = Math.max((S - p) * n.height - r, 0);
    }
    return { items: i, firstItem: t, lastItem: s, topBuffer: r, bottomBuffer: c };
  }
  needle;
  filter = en((n) => {
    if (this.needle !== n)
      this.needle = n, this.update(this._array);
  }, Oe);
  update(n, e) {
    if (n == null)
      n = [];
    this._array = n;
    let { hiddenProp: o, visibleProp: i } = this.options, t = M(n), s = this.visibleSlice();
    this.boundElement.classList.toggle("-xin-empty-list", s.items.length === 0);
    let r = this._previousSlice, { firstItem: c, lastItem: d, topBuffer: l, bottomBuffer: p } = s;
    if (o === undefined && i === undefined && e === true && r != null && c === r.firstItem && d === r.lastItem)
      return;
    this._previousSlice = s;
    let S = 0, E = 0, y = 0;
    for (let u of Array.from(this.boundElement.children)) {
      if (u === this.listTop || u === this.listBottom)
        continue;
      let k = U.get(u);
      if (k == null)
        u.remove();
      else {
        let h = s.items.indexOf(k);
        if (h < c || h > d)
          u.remove(), this.itemToElement.delete(k), U.delete(u), S++;
      }
    }
    this.listTop.style.height = String(l) + "px", this.listBottom.style.height = String(p) + "px";
    let x = [], { idPath: ln } = this.options;
    for (let u = c;u <= d; u++) {
      let k = s.items[u];
      if (k === undefined)
        continue;
      let h = this.itemToElement.get(w(k));
      if (h == null) {
        if (y++, h = z(this.template), typeof k === "object")
          this.itemToElement.set(w(k), h), U.set(h, w(k));
        if (this.boundElement.insertBefore(h, this.listBottom), ln != null) {
          let fn = k[ln], we = `${t}[${ln}=${fn}]`;
          se(h, we);
        } else {
          let fn = `${t}[${u}]`;
          se(h, fn);
        }
      }
      x.push(h);
    }
    let R = null;
    for (let u of x) {
      if (u.previousElementSibling !== R)
        if (E++, R?.nextElementSibling != null)
          this.boundElement.insertBefore(u, R.nextElementSibling);
        else
          this.boundElement.insertBefore(u, this.listBottom);
      R = u;
    }
    if (H.perf)
      console.log(t, "updated", { removed: S, created: y, moved: E });
  }
}
var de = (n, e, o) => {
  let i = n[on];
  if (i === undefined)
    i = new ce(n, e, o), n[on] = i;
  return i;
};
var { document: Q, MutationObserver: ae } = globalThis;
var Mn = (n, e) => {
  let o = v.get(n);
  if (o == null)
    return;
  for (let i of o) {
    let { binding: t, options: s } = i, { path: r } = i, { toDOM: c } = t;
    if (c != null) {
      if (r.startsWith("^")) {
        let d = mn(n);
        if (d != null && d[b] != null)
          r = i.path = `${d[b]}${r.substring(1)}`;
        else
          throw console.error(`Cannot resolve relative binding ${r}`, n, "is not part of a list"), Error(`Cannot resolve relative binding ${r}`);
      }
      if (e == null || r.startsWith(e))
        c(n, f[r], s);
    }
  }
};
if (ae != null)
  new ae((e) => {
    e.forEach((o) => {
      Array.from(o.addedNodes).forEach((i) => {
        if (i instanceof Element)
          Array.from(i.querySelectorAll(L)).forEach((t) => Mn(t));
      });
    });
  }).observe(Q.body, { subtree: true, childList: true });
Z(() => true, (n) => {
  let e = Array.from(Q.querySelectorAll(L));
  for (let o of e)
    Mn(o, n);
});
var le = (n) => {
  let e = n.target.closest(L);
  while (e != null) {
    let o = v.get(e);
    for (let i of o) {
      let { binding: t, path: s } = i, { fromDOM: r } = t;
      if (r != null) {
        let c;
        try {
          c = r(e, i.options);
        } catch (d) {
          throw console.error("Cannot get value from", e, "via", i), Error("Cannot obtain value fromDOM");
        }
        if (c != null) {
          let d = f[s];
          if (d == null)
            f[s] = c;
          else {
            let l = d[b] != null ? d[O] : d, p = c[b] != null ? c[O] : c;
            if (l !== p)
              f[s] = p;
          }
        }
      }
    }
    e = e.parentElement.closest(L);
  }
};
if (globalThis.document != null)
  Q.body.addEventListener("change", le, true), Q.body.addEventListener("input", le, true);
function g(n, e, o, i) {
  if (n instanceof DocumentFragment)
    throw Error("bind cannot bind to a DocumentFragment");
  let t;
  if (typeof e === "object" && e[b] === undefined && i === undefined) {
    let { value: c } = e;
    t = typeof c === "string" ? c : c[b], i = e, delete i.value;
  } else
    t = typeof e === "string" ? e : e[b];
  if (t == null)
    throw Error("bind requires a path or object with xin Proxy");
  let { toDOM: s } = o;
  n.classList?.add(un);
  let r = v.get(n);
  if (r == null)
    r = [], v.set(n, r);
  if (r.push({ path: t, binding: o, options: i }), s != null && !t.startsWith("^"))
    W(t);
  if (i?.filter && i?.needle)
    g(n, i.needle, { toDOM(c, d) {
      console.log({ needle: d }), c[on]?.filter(d);
    } });
  return n;
}
var fe = new Set;
var ze = (n) => {
  let e = n?.target.closest(yn), o = false, i = new Proxy(n, { get(s, r) {
    if (r === "stopPropagation")
      return () => {
        n.stopPropagation(), o = true;
      };
    else {
      let c = s[r];
      return typeof c === "function" ? c.bind(s) : c;
    }
  } }), t = new Set;
  while (!o && e != null) {
    let r = $.get(e)[n.type] || t;
    for (let c of r) {
      if (typeof c === "function")
        c(i);
      else {
        let d = f[c];
        if (typeof d === "function")
          d(i);
        else
          throw Error(`no event handler found at path ${c}`);
      }
      if (o)
        continue;
    }
    e = e.parentElement != null ? e.parentElement.closest(yn) : null;
  }
};
function P(n, e, o) {
  let i = $.get(n);
  if (n.classList.add(pn), i == null)
    i = {}, $.set(n, i);
  if (!i[e])
    i[e] = new Set;
  if (i[e].add(o), !fe.has(e))
    fe.add(e), Q.body.addEventListener(e, ze, true);
  return () => {
    i[e].delete(o);
  };
}
var tn = { value: { toDOM: te, fromDOM(n) {
  return re(n);
} }, text: { toDOM(n, e) {
  n.textContent = e;
} }, enabled: { toDOM(n, e) {
  n.disabled = !e;
} }, disabled: { toDOM(n, e) {
  n.disabled = Boolean(e);
} }, list: { toDOM(n, e, o) {
  de(n, e, o).update(e);
} } };
var Ae = 180 / Math.PI;
var Pe = Math.PI / 180;
function T(n, e, o) {
  return o < n ? NaN : e < n ? n : e > o ? o : e;
}
function F(n, e, o, i = true) {
  if (i)
    o = T(0, o, 1);
  return o * (e - n) + n;
}
function Dn(n, e = document.body) {
  let o = getComputedStyle(e);
  if (n.endsWith(")") && n.startsWith("var("))
    n = n.slice(4, -1);
  return o.getPropertyValue(n).trim();
}
var We = (n, e, o) => {
  return (0.299 * n + 0.587 * e + 0.114 * o) / 255;
};
var j = (n) => ("00" + Math.round(Number(n)).toString(16)).slice(-2);

class ue {
  h;
  s;
  l;
  constructor(n, e, o) {
    n /= 255, e /= 255, o /= 255;
    let i = Math.max(n, e, o), t = i - Math.min(n, e, o), s = t !== 0 ? i === n ? (e - o) / t : i === e ? 2 + (o - n) / t : 4 + (n - e) / t : 0;
    this.h = 60 * s < 0 ? 60 * s + 360 : 60 * s, this.s = t !== 0 ? i <= 0.5 ? t / (2 * i - t) : t / (2 - (2 * i - t)) : 0, this.l = (2 * i - t) / 2;
  }
}
var V = globalThis.document !== undefined ? globalThis.document.createElement("span") : undefined;

class a {
  r;
  g;
  b;
  a;
  static fromVar(n, e = document.body) {
    return a.fromCss(Dn(n, e));
  }
  static fromCss(n) {
    let e = n;
    if (V instanceof HTMLSpanElement)
      V.style.color = "black", V.style.color = n, document.body.appendChild(V), e = getComputedStyle(V).color, V.remove();
    let [o, i, t, s] = e.match(/[\d.]+/g) || ["0", "0", "0", "0"], r = e.startsWith("color(srgb") ? 255 : 1;
    return new a(Number(o) * r, Number(i) * r, Number(t) * r, s == null ? 1 : Number(s));
  }
  static fromHsl(n, e, o, i = 1) {
    let t, s, r;
    if (e === 0)
      t = s = r = o;
    else {
      let d = (E, y, x) => {
        if (x < 0)
          x += 1;
        if (x > 1)
          x -= 1;
        if (x < 0.16666666666666666)
          return E + (y - E) * 6 * x;
        if (x < 0.5)
          return y;
        if (x < 0.6666666666666666)
          return E + (y - E) * (0.6666666666666666 - x) * 6;
        return E;
      }, l = o < 0.5 ? o * (1 + e) : o + e - o * e, p = 2 * o - l, S = (n % 360 + 360) % 360 / 360;
      t = d(p, l, S + 0.3333333333333333), s = d(p, l, S), r = d(p, l, S - 0.3333333333333333);
    }
    let c = new a(t * 255, s * 255, r * 255, i);
    return c.hslCached = { h: (n % 360 + 360) % 360, s: e, l: o }, c;
  }
  static black = new a(0, 0, 0);
  static white = new a(255, 255, 255);
  constructor(n, e, o, i = 1) {
    this.r = T(0, n, 255), this.g = T(0, e, 255), this.b = T(0, o, 255), this.a = T(0, i, 1);
  }
  get inverse() {
    return new a(255 - this.r, 255 - this.g, 255 - this.b, this.a);
  }
  get inverseLuminance() {
    let { h: n, s: e, l: o } = this._hsl;
    return a.fromHsl(n, e, 1 - o, this.a);
  }
  get opaque() {
    return this.a === 1 ? this : new a(this.r, this.g, this.b, 1);
  }
  contrasting(n = 1) {
    return this.opaque.blend(this.brightness > 0.5 ? a.black : a.white, n);
  }
  get rgb() {
    let { r: n, g: e, b: o } = this;
    return `rgb(${n.toFixed(0)},${e.toFixed(0)},${o.toFixed(0)})`;
  }
  get rgba() {
    let { r: n, g: e, b: o, a: i } = this;
    return `rgba(${n.toFixed(0)},${e.toFixed(0)},${o.toFixed(0)},${i.toFixed(2)})`;
  }
  get RGBA() {
    return [this.r / 255, this.g / 255, this.b / 255, this.a];
  }
  get ARGB() {
    return [this.a, this.r / 255, this.g / 255, this.b / 255];
  }
  hslCached;
  get _hsl() {
    if (this.hslCached == null)
      this.hslCached = new ue(this.r, this.g, this.b);
    return this.hslCached;
  }
  get hsl() {
    let { h: n, s: e, l: o } = this._hsl;
    return `hsl(${n.toFixed(0)}deg ${(e * 100).toFixed(0)}% ${(o * 100).toFixed(0)}%)`;
  }
  get hsla() {
    let { h: n, s: e, l: o } = this._hsl;
    return `hsl(${n.toFixed(0)}deg ${(e * 100).toFixed(0)}% ${(o * 100).toFixed(0)}% / ${(this.a * 100).toFixed(0)}%)`;
  }
  get mono() {
    let n = this.brightness * 255;
    return new a(n, n, n);
  }
  get brightness() {
    return We(this.r, this.g, this.b);
  }
  get html() {
    return this.toString();
  }
  toString() {
    return this.a === 1 ? "#" + j(this.r) + j(this.g) + j(this.b) : "#" + j(this.r) + j(this.g) + j(this.b) + j(Math.floor(255 * this.a));
  }
  brighten(n) {
    let { h: e, s: o, l: i } = this._hsl, t = T(0, i + n * (1 - i), 1);
    return a.fromHsl(e, o, t, this.a);
  }
  darken(n) {
    let { h: e, s: o, l: i } = this._hsl, t = T(0, i * (1 - n), 1);
    return a.fromHsl(e, o, t, this.a);
  }
  saturate(n) {
    let { h: e, s: o, l: i } = this._hsl, t = T(0, o + n * (1 - o), 1);
    return a.fromHsl(e, t, i, this.a);
  }
  desaturate(n) {
    let { h: e, s: o, l: i } = this._hsl, t = T(0, o * (1 - n), 1);
    return a.fromHsl(e, t, i, this.a);
  }
  rotate(n) {
    let { h: e, s: o, l: i } = this._hsl, t = (e + 360 + n) % 360;
    return a.fromHsl(t, o, i, this.a);
  }
  opacity(n) {
    let { h: e, s: o, l: i } = this._hsl;
    return a.fromHsl(e, o, i, n);
  }
  swatch() {
    return console.log(`%c      %c ${this.html}, ${this.rgba}`, `background-color: ${this.html}`, "background-color: transparent"), this;
  }
  blend(n, e) {
    return new a(F(this.r, n.r, e), F(this.g, n.g, e), F(this.b, n.b, e), F(this.a, n.a, e));
  }
  static blendHue(n, e, o) {
    let i = (e - n + 720) % 360;
    if (i < 180)
      return n + o * i;
    else
      return n - (360 - i) * o;
  }
  mix(n, e) {
    let o = this._hsl, i = n._hsl;
    return a.fromHsl(o.s === 0 ? i.h : i.s === 0 ? o.h : a.blendHue(o.h, i.h, e), F(o.s, i.s, e), F(o.l, i.l, e), F(this.a, n.a, e));
  }
  colorMix(n, e) {
    return a.fromCss(`color-mix(in hsl, ${this.html}, ${n.html} ${(e * 100).toFixed(0)}%)`);
  }
}
function X(n) {
  return n.replace(/[A-Z]/g, (e) => {
    return `-${e.toLocaleLowerCase()}`;
  });
}
function pe(n) {
  return n.replace(/-([a-z])/g, (e, o) => {
    return o.toLocaleUpperCase();
  });
}
var Ie = "http://www.w3.org/1998/Math/MathML";
var Ye = "http://www.w3.org/2000/svg";
var rn = {};
var ye = (n, e, o) => {
  let i = $n(X(e), o);
  if (i.prop.startsWith("--"))
    n.style.setProperty(i.prop, i.value);
  else
    n.style[e] = i.value;
};
var Je = (n) => {
  return { toDOM(e, o) {
    ye(e, n, o);
  } };
};
var me = (n, e, o) => {
  if (e === "style")
    if (typeof o === "object")
      for (let i of Object.keys(o))
        if (M(o[i]))
          g(n, o[i], Je(i));
        else
          ye(n, i, o[i]);
    else
      n.setAttribute("style", o);
  else if (n[e] !== undefined) {
    let { MathMLElement: i } = globalThis;
    if (n instanceof SVGElement || i !== undefined && n instanceof i)
      n.setAttribute(e, o);
    else
      n[e] = o;
  } else {
    let i = X(e);
    if (i === "class")
      o.split(" ").forEach((t) => {
        n.classList.add(t);
      });
    else if (n[i] !== undefined)
      n[i] = o;
    else if (typeof o === "boolean")
      o ? n.setAttribute(i, "") : n.removeAttribute(i);
    else
      n.setAttribute(i, o);
  }
};
var Ve = (n) => {
  return { toDOM(e, o) {
    me(e, n, o);
  } };
};
var _e = (n, e, o) => {
  if (e === "apply")
    o(n);
  else if (e.match(/^on[A-Z]/) != null) {
    let i = e.substring(2).toLowerCase();
    P(n, i, o);
  } else if (e === "bind")
    if ((typeof o.binding === "string" ? tn[o.binding] : o.binding) !== undefined && o.value !== undefined)
      g(n, o.value, o.binding instanceof Function ? { toDOM: o.binding } : o.binding);
    else
      throw Error("bad binding");
  else if (e.match(/^bind[A-Z]/) != null) {
    let i = e.substring(4, 5).toLowerCase() + e.substring(5), t = tn[i];
    if (t !== undefined)
      g(n, o, t);
    else
      throw Error(`${e} is not allowed, bindings.${i} is not defined`);
  } else if (M(o))
    g(n, o, Ve(e));
  else
    me(n, e, o);
};
var Fn = (n, ...e) => {
  if (rn[n] === undefined) {
    let [t, s] = n.split("|");
    if (s === undefined)
      rn[n] = globalThis.document.createElement(t);
    else
      rn[n] = globalThis.document.createElementNS(s, t);
  }
  let o = rn[n].cloneNode(), i = {};
  for (let t of e)
    if (t instanceof Element || t instanceof DocumentFragment || typeof t === "string" || typeof t === "number")
      if (o instanceof HTMLTemplateElement)
        o.content.append(t);
      else
        o.append(t);
    else if (M(t))
      o.append(m.span({ bindText: t }));
    else
      Object.assign(i, t);
  for (let t of Object.keys(i)) {
    let s = i[t];
    _e(o, t, s);
  }
  return o;
};
var Ln = (...n) => {
  let e = globalThis.document.createDocumentFragment();
  for (let o of n)
    e.append(o);
  return e;
};
var m = new Proxy({ fragment: Ln }, { get(n, e) {
  if (e = e.replace(/[A-Z]/g, (o) => `-${o.toLocaleLowerCase()}`), n[e] === undefined)
    n[e] = (...o) => Fn(e, ...o);
  return n[e];
}, set() {
  throw Error("You may not add new properties to elements");
} });
var Bn = new Proxy({ fragment: Ln }, { get(n, e) {
  if (n[e] === undefined)
    n[e] = (...o) => Fn(`${e}|${Ye}`, ...o);
  return n[e];
}, set() {
  throw Error("You may not add new properties to elements");
} });
var Hn = new Proxy({ fragment: Ln }, { get(n, e) {
  if (n[e] === undefined)
    n[e] = (...o) => Fn(`${e}|${Ie}`, ...o);
  return n[e];
}, set() {
  throw Error("You may not add new properties to elements");
} });
function Ue(n, e) {
  let o = m.style(_(e));
  o.id = n, document.head.append(o);
}
var Ge = ["animation-iteration-count", "flex", "flex-base", "flex-grow", "flex-shrink", "opacity", "order", "tab-size", "widows", "z-index", "zoom"];
var $n = (n, e) => {
  if (typeof e === "number" && !Ge.includes(n))
    e = `${e}px`;
  if (n.startsWith("_"))
    if (n.startsWith("__"))
      n = "--" + n.substring(2), e = `var(${n}-default, ${e})`;
    else
      n = "--" + n.substring(1);
  return { prop: n, value: String(e) };
};
var Ze = (n, e, o) => {
  if (o === undefined)
    return "";
  if (o instanceof a)
    o = o.html;
  let i = $n(e, o);
  return `${n}  ${i.prop}: ${i.value};`;
};
var xe = (n, e, o = "") => {
  let i = X(n);
  if (typeof e === "object" && !(e instanceof a)) {
    let t = Object.keys(e).map((s) => xe(s, e[s], `${o}  `)).join(`
`);
    return `${o}  ${n} {
${t}
${o}  }`;
  } else
    return Ze(o, i, e);
};
var _ = (n, e = "") => {
  return Object.keys(n).map((i) => {
    let t = n[i];
    if (typeof t === "string") {
      if (i === "@import")
        return `@import url('${t}');`;
      throw Error("top-level string value only allowed for `@import`");
    }
    let s = Object.keys(t).map((r) => xe(r, t[r])).join(`
`);
    return `${e}${i} {
${s}
}`;
  }).join(`

`);
};
var sn = new Proxy({}, { get(n, e) {
  if (n[e] === undefined) {
    let o = "--" + X(e);
    n[e] = (i) => `var(${o}, ${i})`;
  }
  return n[e];
} });
var On = new Proxy({}, { get(n, e) {
  if (e === "default")
    return sn;
  if (n[e] == null) {
    e = X(e);
    let [, o, , i, t, s] = e.match(/^([-\w]*?)((_)?(\d+)(\w?))?$/) || ["", e], r = `--${o}`;
    if (t != null) {
      let c = i == null ? Number(t) / 100 : -Number(t) / 100;
      switch (s) {
        case "b":
          {
            let d = a.fromVar(r);
            n[e] = c > 0 ? d.brighten(c).rgba : d.darken(-c).rgba;
          }
          break;
        case "s":
          {
            let d = a.fromVar(r);
            n[e] = c > 0 ? d.saturate(c).rgba : d.desaturate(-c).rgba;
          }
          break;
        case "h":
          {
            let d = a.fromVar(r);
            n[e] = d.rotate(c * 100).rgba;
          }
          break;
        case "o":
          {
            let d = a.fromVar(r);
            n[e] = d.opacity(c).rgba;
          }
          break;
        case "":
          n[e] = `calc(var(${r}) * ${c})`;
          break;
        default:
          throw console.error(s), Error(`Unrecognized method ${s} for css variable ${r}`);
      }
    } else
      n[e] = `var(${r})`;
  }
  return n[e];
} });
var Ke = 0;
function zn() {
  return `custom-elt${(Ke++).toString(36)}`;
}
var he = 0;
var K = {};
function Re(n, e) {
  let o = K[n], i = _(e).replace(/:host\b/g, n);
  K[n] = o ? o + `
` + i : i;
}
function Ne(n) {
  if (K[n])
    document.head.append(m.style({ id: n + "-component" }, K[n]));
  delete K[n];
}

class B extends HTMLElement {
  static elements = m;
  static _elementCreator;
  instanceId;
  styleNode;
  static styleSpec;
  static styleNode;
  content = m.slot();
  isSlotted;
  static _tagName = null;
  static get tagName() {
    return this._tagName;
  }
  static StyleNode(n) {
    return console.warn("StyleNode is deprecated, just assign static styleSpec: XinStyleSheet to the class directly"), m.style(_(n));
  }
  static elementCreator(n = {}) {
    let e = this;
    if (e._elementCreator == null) {
      let { tag: o, styleSpec: i } = n, t = n != null ? o : null;
      if (t == null)
        if (typeof e.name === "string" && e.name !== "") {
          if (t = X(e.name), t.startsWith("-"))
            t = t.slice(1);
        } else
          t = zn();
      if (customElements.get(t) != null)
        console.warn(`${t} is already defined`);
      if (t.match(/\w+(-\w+)+/) == null)
        console.warn(`${t} is not a legal tag for a custom-element`), t = zn();
      while (customElements.get(t) !== undefined)
        t = zn();
      if (e._tagName = t, i !== undefined)
        Re(t, i);
      window.customElements.define(t, this, n), e._elementCreator = m[t];
    }
    return e._elementCreator;
  }
  initAttributes(...n) {
    let e = {}, o = {};
    new MutationObserver((t) => {
      let s = false;
      if (t.forEach((r) => {
        s = !!(r.attributeName && n.includes(pe(r.attributeName)));
      }), s && this.queueRender !== undefined)
        this.queueRender(false);
    }).observe(this, { attributes: true }), n.forEach((t) => {
      e[t] = C(this[t]);
      let s = X(t);
      Object.defineProperty(this, t, { enumerable: false, get() {
        if (typeof e[t] === "boolean")
          return this.hasAttribute(s);
        else if (this.hasAttribute(s))
          return typeof e[t] === "number" ? parseFloat(this.getAttribute(s)) : this.getAttribute(s);
        else if (o[t] !== undefined)
          return o[t];
        else
          return e[t];
      }, set(r) {
        if (typeof e[t] === "boolean") {
          if (r !== this[t]) {
            if (r)
              this.setAttribute(s, "");
            else
              this.removeAttribute(s);
            this.queueRender();
          }
        } else if (typeof e[t] === "number") {
          if (r !== parseFloat(this[t]))
            this.setAttribute(s, r), this.queueRender();
        } else if (typeof r === "object" || `${r}` !== `${this[t]}`) {
          if (r === null || r === undefined || typeof r === "object")
            this.removeAttribute(s);
          else
            this.setAttribute(s, r);
          this.queueRender(), o[t] = r;
        }
      } });
    });
  }
  initValue() {
    let n = Object.getOwnPropertyDescriptor(this, "value");
    if (n === undefined || n.get !== undefined || n.set !== undefined)
      return;
    let e = this.hasAttribute("value") ? this.getAttribute("value") : C(this.value);
    delete this.value, Object.defineProperty(this, "value", { enumerable: false, get() {
      return e;
    }, set(o) {
      if (e !== o)
        e = o, this.queueRender(true);
    } });
  }
  _parts;
  get parts() {
    let n = this.shadowRoot != null ? this.shadowRoot : this;
    if (this._parts == null)
      this._parts = new Proxy({}, { get(e, o) {
        if (e[o] === undefined) {
          let i = n.querySelector(`[part="${o}"]`);
          if (i == null)
            i = n.querySelector(o);
          if (i == null)
            throw Error(`elementRef "${o}" does not exist!`);
          i.removeAttribute("data-ref"), e[o] = i;
        }
        return e[o];
      } });
    return this._parts;
  }
  constructor() {
    super();
    he += 1, this.initAttributes("hidden"), this.instanceId = `${this.tagName.toLocaleLowerCase()}-${he}`, this._value = C(this.defaultValue);
  }
  connectedCallback() {
    if (Ne(this.constructor.tagName), this.hydrate(), this.role != null)
      this.setAttribute("role", this.role);
    if (this.onResize !== undefined) {
      if (q.observe(this), this._onResize == null)
        this._onResize = this.onResize.bind(this);
      this.addEventListener("resize", this._onResize);
    }
    if (this.value != null && this.getAttribute("value") != null)
      this._value = this.getAttribute("value");
    this.queueRender();
  }
  disconnectedCallback() {
    q.unobserve(this);
  }
  _changeQueued = false;
  _renderQueued = false;
  queueRender(n = false) {
    if (!this._hydrated)
      return;
    if (!this._changeQueued)
      this._changeQueued = n;
    if (!this._renderQueued)
      this._renderQueued = true, requestAnimationFrame(() => {
        if (this._changeQueued)
          kn(this, "change");
        this._changeQueued = false, this._renderQueued = false, this.render();
      });
  }
  _hydrated = false;
  hydrate() {
    if (!this._hydrated) {
      this.initValue();
      let n = typeof this.content !== "function", e = typeof this.content === "function" ? this.content() : this.content, { styleSpec: o } = this.constructor, { styleNode: i } = this.constructor;
      if (o)
        i = this.constructor.styleNode = m.style(_(o)), delete this.constructor.styleNode;
      if (this.styleNode)
        console.warn(this, "styleNode is deprecrated, use static styleNode or statc styleSpec instead"), i = this.styleNode;
      if (i) {
        let t = this.attachShadow({ mode: "open" });
        t.appendChild(i.cloneNode(true)), Cn(t, e, n);
      } else if (e !== null) {
        let t = Array.from(this.childNodes);
        Cn(this, e, n), this.isSlotted = this.querySelector("slot,xin-slot") !== undefined;
        let s = Array.from(this.querySelectorAll("slot"));
        if (s.length > 0)
          s.forEach(An.replaceSlot);
        if (t.length > 0) {
          let r = { "": this };
          Array.from(this.querySelectorAll("xin-slot")).forEach((c) => {
            r[c.name] = c;
          }), t.forEach((c) => {
            let d = r[""], l = c instanceof Element ? r[c.slot] : d;
            (l !== undefined ? l : d).append(c);
          });
        }
      }
      this._hydrated = true;
    }
  }
  render() {}
}

class An extends B {
  name = "";
  content = null;
  static replaceSlot(n) {
    let e = document.createElement("xin-slot");
    if (n.name !== "")
      e.setAttribute("name", n.name);
    n.replaceWith(e);
  }
  constructor() {
    super();
    this.initAttributes("name");
  }
}
var fi = An.elementCreator({ tag: "xin-slot" });
var Pn = "1.0.9";
function be(n) {
  return Object.assign(J, n), J;
}
function cn(n) {
  return console.warn("boxedProxy is deprecated, please use tosi() instead"), be(n);
}
function jn(n, e = false) {
  if (e)
    return console.warn("xinProxy(..., true) is deprecated; use tosi(...) instead"), cn(n);
  return Object.keys(n).forEach((o) => {
    f[o] = n[o];
  }), f;
}
var eo = {};
async function dn(n, e) {
  let { type: o, styleSpec: i } = await e(n, { Color: a, Component: B, elements: m, svgElements: Bn, mathML: Hn, varDefault: sn, vars: On, xin: f, boxed: J, xinProxy: jn, boxedProxy: cn, makeComponent: dn, bind: g, on: P, version: Pn }), t = { type: o, creator: o.elementCreator({ tag: n, styleSpec: i }) };
  return eo[n] = t, t;
}
var Wn = {};
var oo = (n) => import(n);

class an extends B {
  tag = "anon-elt";
  src = "";
  property = "default";
  loaded;
  blueprintLoaded = (n) => {};
  async packaged() {
    let { tag: n, src: e, property: o } = this, i = `${n}.${o}:${e}`;
    if (!this.loaded) {
      if (Wn[i] === undefined)
        Wn[i] = oo(e).then((t) => {
          let s = t[o];
          return dn(n, s);
        });
      else
        console.log(`using cached ${n} with signature ${i}`);
      this.loaded = await Wn[i], this.blueprintLoaded(this.loaded);
    }
    return this.loaded;
  }
  constructor() {
    super();
    this.initAttributes("tag", "src", "property");
  }
}
var io = an.elementCreator({ tag: "xin-blueprint", styleSpec: { ":host": { display: "none" } } });

class In extends B {
  allLoaded = () => {};
  constructor() {
    super();
  }
  async load() {
    let e = Array.from(this.querySelectorAll(an.tagName)).filter((o) => o.src).map((o) => o.packaged());
    await Promise.all(e), this.allLoaded();
  }
  connectedCallback() {
    super.connectedCallback(), this.load();
  }
}
var to = In.elementCreator({ tag: "xin-loader", styleSpec: { ":host": { display: "none" } } });

// dist/index.js
var import_react = __toESM(require_react(), 1);
var useTosi = function(observed, initialValue) {
  const path = typeof observed === "string" ? observed : M(observed);
  if (typeof path !== "string") {
    console.error("useXin must either be passed a path or a XinProxy", observed);
    throw new Error("useXin must either be passed a path or a XinProxy");
  }
  const [value, update] = import_react.useState(f[path] !== undefined ? f[path] : initialValue);
  import_react.useEffect(() => {
    const observer = () => {
      update(f[path]);
    };
    const listener = Z(path, observer);
    return () => {
      G(listener);
    };
  });
  const setValue = (value2) => {
    f[path] = value2;
  };
  return [value, setValue];
};
var reactWebComponents = new Proxy({}, {
  get(target, key) {
    if (typeof key !== "string") {
      return target[key];
    }
    const tagName = key.replace(/([a-z])([A-Z])/g, (_2, first, last) => {
      return first + "-" + last.toLocaleLowerCase();
    });
    if (!target[tagName]) {
      target[tagName] = (props) => import_react.createElement(tagName, props);
    }
    return target[tagName];
  }
});

// demo/src/todo.tsx
var jsx_dev_runtime = __toESM(require_jsx_dev_runtime(), 1);
var { app } = jn({
  app: {
    name: "Reminders",
    newItem: {
      id: 1,
      reminder: ""
    },
    todos: [],
    addItem(evt) {
      evt.preventDefault();
      if (!app.newItem.reminder)
        return;
      app.todos.push({
        ...app.newItem
      });
      app.newItem.id++;
      app.newItem.reminder = "";
    }
  }
});
window.app = app;
var List = () => {
  const [todos] = useTosi(app.todos);
  return /* @__PURE__ */ jsx_dev_runtime.jsxDEV("div", {
    className: "List",
    children: todos.map((item) => /* @__PURE__ */ jsx_dev_runtime.jsxDEV("div", {
      className: "ListItem",
      children: [
        /* @__PURE__ */ jsx_dev_runtime.jsxDEV("span", {
          className: "elastic",
          children: item.reminder
        }, undefined, false, undefined, this),
        /* @__PURE__ */ jsx_dev_runtime.jsxDEV("button", {
          title: "delete",
          onClick: () => {
            todos.splice(todos.indexOf(item), 1);
          },
          children: ""
        }, undefined, false, undefined, this)
      ]
    }, item.id, true, undefined, this))
  }, undefined, false, undefined, this);
};
var Editor = () => {
  const [reminder, setReminder] = useTosi("app.newItem.reminder");
  const [id] = useTosi("app.newItem.id");
  return /* @__PURE__ */ jsx_dev_runtime.jsxDEV("form", {
    className: "Editor",
    onSubmit: app.addItem,
    children: [
      /* @__PURE__ */ jsx_dev_runtime.jsxDEV("input", {
        className: "elastic",
        placeholder: "enter a reminder",
        value: reminder,
        onInput: (event) => setReminder(event.target.value)
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime.jsxDEV("button", {
        disabled: !reminder,
        children: [
          "Add Item #",
          id
        ]
      }, undefined, true, undefined, this)
    ]
  }, undefined, true, undefined, this);
};
var App = () => {
  const [name] = useTosi("app.name");
  return /* @__PURE__ */ jsx_dev_runtime.jsxDEV("div", {
    className: "App",
    children: [
      /* @__PURE__ */ jsx_dev_runtime.jsxDEV("h2", {
        children: name
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime.jsxDEV(List, {}, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime.jsxDEV(Editor, {}, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this);
};
var todo_default = App;

// node_modules/marked/lib/marked.esm.js
function L2() {
  return { async: false, breaks: false, extensions: null, gfm: true, hooks: null, pedantic: false, renderer: null, silent: false, tokenizer: null, walkTokens: null };
}
var T2 = L2();
function G2(u) {
  T2 = u;
}
var I2 = { exec: () => null };
function h(u, e = "") {
  let t = typeof u == "string" ? u : u.source, n = { replace: (r, i) => {
    let s = typeof i == "string" ? i : i.source;
    return s = s.replace(m2.caret, "$1"), t = t.replace(r, s), n;
  }, getRegex: () => new RegExp(t, e) };
  return n;
}
var m2 = { codeRemoveIndent: /^(?: {1,4}| {0,3}\t)/gm, outputLinkReplace: /\\([\[\]])/g, indentCodeCompensation: /^(\s+)(?:```)/, beginningSpace: /^\s+/, endingHash: /#$/, startingSpaceChar: /^ /, endingSpaceChar: / $/, nonSpaceChar: /[^ ]/, newLineCharGlobal: /\n/g, tabCharGlobal: /\t/g, multipleSpaceGlobal: /\s+/g, blankLine: /^[ \t]*$/, doubleBlankLine: /\n[ \t]*\n[ \t]*$/, blockquoteStart: /^ {0,3}>/, blockquoteSetextReplace: /\n {0,3}((?:=+|-+) *)(?=\n|$)/g, blockquoteSetextReplace2: /^ {0,3}>[ \t]?/gm, listReplaceTabs: /^\t+/, listReplaceNesting: /^ {1,4}(?=( {4})*[^ ])/g, listIsTask: /^\[[ xX]\] /, listReplaceTask: /^\[[ xX]\] +/, anyLine: /\n.*\n/, hrefBrackets: /^<(.*)>$/, tableDelimiter: /[:|]/, tableAlignChars: /^\||\| *$/g, tableRowBlankLine: /\n[ \t]*$/, tableAlignRight: /^ *-+: *$/, tableAlignCenter: /^ *:-+: *$/, tableAlignLeft: /^ *:-+ *$/, startATag: /^<a /i, endATag: /^<\/a>/i, startPreScriptTag: /^<(pre|code|kbd|script)(\s|>)/i, endPreScriptTag: /^<\/(pre|code|kbd|script)(\s|>)/i, startAngleBracket: /^</, endAngleBracket: />$/, pedanticHrefTitle: /^([^'"]*[^\s])\s+(['"])(.*)\2/, unicodeAlphaNumeric: /[\p{L}\p{N}]/u, escapeTest: /[&<>"']/, escapeReplace: /[&<>"']/g, escapeTestNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/, escapeReplaceNoEncode: /[<>"']|&(?!(#\d{1,7}|#[Xx][a-fA-F0-9]{1,6}|\w+);)/g, unescapeTest: /&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, caret: /(^|[^\[])\^/g, percentDecode: /%25/g, findPipe: /\|/g, splitPipe: / \|/, slashPipe: /\\\|/g, carriageReturn: /\r\n|\r/g, spaceLine: /^ +$/gm, notSpaceStart: /^\S*/, endingNewline: /\n$/, listItemRegex: (u) => new RegExp(`^( {0,3}${u})((?:[	 ][^\\n]*)?(?:\\n|$))`), nextBulletRegex: (u) => new RegExp(`^ {0,${Math.min(3, u - 1)}}(?:[*+-]|\\d{1,9}[.)])((?:[ 	][^\\n]*)?(?:\\n|$))`), hrRegex: (u) => new RegExp(`^ {0,${Math.min(3, u - 1)}}((?:- *){3,}|(?:_ *){3,}|(?:\\* *){3,})(?:\\n+|$)`), fencesBeginRegex: (u) => new RegExp(`^ {0,${Math.min(3, u - 1)}}(?:\`\`\`|~~~)`), headingBeginRegex: (u) => new RegExp(`^ {0,${Math.min(3, u - 1)}}#`), htmlBeginRegex: (u) => new RegExp(`^ {0,${Math.min(3, u - 1)}}<(?:[a-z].*>|!--)`, "i") };
var be2 = /^(?:[ \t]*(?:\n|$))+/;
var Re2 = /^((?: {4}| {0,3}\t)[^\n]+(?:\n(?:[ \t]*(?:\n|$))*)?)+/;
var Te2 = /^ {0,3}(`{3,}(?=[^`\n]*(?:\n|$))|~{3,})([^\n]*)(?:\n|$)(?:|([\s\S]*?)(?:\n|$))(?: {0,3}\1[~`]* *(?=\n|$)|$)/;
var E = /^ {0,3}((?:-[\t ]*){3,}|(?:_[ \t]*){3,}|(?:\*[ \t]*){3,})(?:\n+|$)/;
var Oe2 = /^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n+|$)/;
var F2 = /(?:[*+-]|\d{1,9}[.)])/;
var ie2 = /^(?!bull |blockCode|fences|blockquote|heading|html|table)((?:.|\n(?!\s*?\n|bull |blockCode|fences|blockquote|heading|html|table))+?)\n {0,3}(=+|-+) *(?:\n+|$)/;
var oe2 = h(ie2).replace(/bull/g, F2).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/\|table/g, "").getRegex();
var we = h(ie2).replace(/bull/g, F2).replace(/blockCode/g, /(?: {4}| {0,3}\t)/).replace(/fences/g, / {0,3}(?:`{3,}|~{3,})/).replace(/blockquote/g, / {0,3}>/).replace(/heading/g, / {0,3}#{1,6}/).replace(/html/g, / {0,3}<[^\n>]+>\n/).replace(/table/g, / {0,3}\|?(?:[:\- ]*\|)+[\:\- ]*\n/).getRegex();
var j2 = /^([^\n]+(?:\n(?!hr|heading|lheading|blockquote|fences|list|html|table| +\n)[^\n]+)*)/;
var ye2 = /^[^\n]+/;
var Q2 = /(?!\s*\])(?:\\[\s\S]|[^\[\]\\])+/;
var Pe2 = h(/^ {0,3}\[(label)\]: *(?:\n[ \t]*)?([^<\s][^\s]*|<.*?>)(?:(?: +(?:\n[ \t]*)?| *\n[ \t]*)(title))? *(?:\n+|$)/).replace("label", Q2).replace("title", /(?:"(?:\\"?|[^"\\])*"|'[^'\n]*(?:\n[^'\n]+)*\n?'|\([^()]*\))/).getRegex();
var Se2 = h(/^( {0,3}bull)([ \t][^\n]+?)?(?:\n|$)/).replace(/bull/g, F2).getRegex();
var v2 = "address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h[1-6]|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|meta|nav|noframes|ol|optgroup|option|p|param|search|section|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul";
var U2 = /<!--(?:-?>|[\s\S]*?(?:-->|$))/;
var $e2 = h("^ {0,3}(?:<(script|pre|style|textarea)[\\s>][\\s\\S]*?(?:</\\1>[^\\n]*\\n+|$)|comment[^\\n]*(\\n+|$)|<\\?[\\s\\S]*?(?:\\?>\\n*|$)|<![A-Z][\\s\\S]*?(?:>\\n*|$)|<!\\[CDATA\\[[\\s\\S]*?(?:\\]\\]>\\n*|$)|</?(tag)(?: +|\\n|/?>)[\\s\\S]*?(?:(?:\\n[ \t]*)+\\n|$)|<(?!script|pre|style|textarea)([a-z][\\w-]*)(?:attribute)*? */?>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ \t]*)+\\n|$)|</(?!script|pre|style|textarea)[a-z][\\w-]*\\s*>(?=[ \\t]*(?:\\n|$))[\\s\\S]*?(?:(?:\\n[ \t]*)+\\n|$))", "i").replace("comment", U2).replace("tag", v2).replace("attribute", / +[a-zA-Z:_][\w.:-]*(?: *= *"[^"\n]*"| *= *'[^'\n]*'| *= *[^\s"'=<>`]+)?/).getRegex();
var ae2 = h(j2).replace("hr", E).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("|table", "").replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", v2).getRegex();
var _e2 = h(/^( {0,3}> ?(paragraph|[^\n]*)(?:\n|$))+/).replace("paragraph", ae2).getRegex();
var K2 = { blockquote: _e2, code: Re2, def: Pe2, fences: Te2, heading: Oe2, hr: E, html: $e2, lheading: oe2, list: Se2, newline: be2, paragraph: ae2, table: I2, text: ye2 };
var re2 = h("^ *([^\\n ].*)\\n {0,3}((?:\\| *)?:?-+:? *(?:\\| *:?-+:? *)*(?:\\| *)?)(?:\\n((?:(?! *\\n|hr|heading|blockquote|code|fences|list|html).*(?:\\n|$))*)\\n*|$)").replace("hr", E).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("blockquote", " {0,3}>").replace("code", "(?: {4}| {0,3}\t)[^\\n]").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", v2).getRegex();
var Le2 = { ...K2, lheading: we, table: re2, paragraph: h(j2).replace("hr", E).replace("heading", " {0,3}#{1,6}(?:\\s|$)").replace("|lheading", "").replace("table", re2).replace("blockquote", " {0,3}>").replace("fences", " {0,3}(?:`{3,}(?=[^`\\n]*\\n)|~{3,})[^\\n]*\\n").replace("list", " {0,3}(?:[*+-]|1[.)]) ").replace("html", "</?(?:tag)(?: +|\\n|/?>)|<(?:script|pre|style|textarea|!--)").replace("tag", v2).getRegex() };
var Me2 = { ...K2, html: h(`^ *(?:comment *(?:\\n|\\s*$)|<(tag)[\\s\\S]+?</\\1> *(?:\\n{2,}|\\s*$)|<tag(?:"[^"]*"|'[^']*'|\\s[^'"/>\\s]*)*?/?> *(?:\\n{2,}|\\s*$))`).replace("comment", U2).replace(/tag/g, "(?!(?:a|em|strong|small|s|cite|q|dfn|abbr|data|time|code|var|samp|kbd|sub|sup|i|b|u|mark|ruby|rt|rp|bdi|bdo|span|br|wbr|ins|del|img)\\b)\\w+(?!:|[^\\w\\s@]*@)\\b").getRegex(), def: /^ *\[([^\]]+)\]: *<?([^\s>]+)>?(?: +(["(][^\n]+[")]))? *(?:\n+|$)/, heading: /^(#{1,6})(.*)(?:\n+|$)/, fences: I2, lheading: /^(.+?)\n {0,3}(=+|-+) *(?:\n+|$)/, paragraph: h(j2).replace("hr", E).replace("heading", ` *#{1,6} *[^
]`).replace("lheading", oe2).replace("|table", "").replace("blockquote", " {0,3}>").replace("|fences", "").replace("|list", "").replace("|html", "").replace("|tag", "").getRegex() };
var ze2 = /^\\([!"#$%&'()*+,\-./:;<=>?@\[\]\\^_`{|}~])/;
var Ae2 = /^(`+)([^`]|[^`][\s\S]*?[^`])\1(?!`)/;
var le2 = /^( {2,}|\\)\n(?!\s*$)/;
var Ie2 = /^(`+|[^`])(?:(?= {2,}\n)|[\s\S]*?(?:(?=[\\<!\[`*_]|\b_|$)|[^ ](?= {2,}\n)))/;
var D2 = /[\p{P}\p{S}]/u;
var W2 = /[\s\p{P}\p{S}]/u;
var ue2 = /[^\s\p{P}\p{S}]/u;
var Ee2 = h(/^((?![*_])punctSpace)/, "u").replace(/punctSpace/g, W2).getRegex();
var pe2 = /(?!~)[\p{P}\p{S}]/u;
var Ce2 = /(?!~)[\s\p{P}\p{S}]/u;
var Be2 = /(?:[^\s\p{P}\p{S}]|~)/u;
var qe = h(/link|code|html/, "g").replace("link", /\[(?:[^\[\]`]|(?<!`)(?<a>`+)[^`]+\k<a>(?!`))*?\]\((?:\\[\s\S]|[^\\\(\)]|\((?:\\[\s\S]|[^\\\(\)])*\))*\)/).replace("code", /(?<!`)(?<b>`+)[^`]+\k<b>(?!`)/).replace("html", /<(?! )[^<>]*?>/).getRegex();
var ce2 = /^(?:\*+(?:((?!\*)punct)|[^\s*]))|^_+(?:((?!_)punct)|([^\s_]))/;
var ve2 = h(ce2, "u").replace(/punct/g, D2).getRegex();
var De2 = h(ce2, "u").replace(/punct/g, pe2).getRegex();
var he2 = "^[^_*]*?__[^_*]*?\\*[^_*]*?(?=__)|[^*]+(?=[^*])|(?!\\*)punct(\\*+)(?=[\\s]|$)|notPunctSpace(\\*+)(?!\\*)(?=punctSpace|$)|(?!\\*)punctSpace(\\*+)(?=notPunctSpace)|[\\s](\\*+)(?!\\*)(?=punct)|(?!\\*)punct(\\*+)(?!\\*)(?=punct)|notPunctSpace(\\*+)(?=notPunctSpace)";
var He2 = h(he2, "gu").replace(/notPunctSpace/g, ue2).replace(/punctSpace/g, W2).replace(/punct/g, D2).getRegex();
var Ze2 = h(he2, "gu").replace(/notPunctSpace/g, Be2).replace(/punctSpace/g, Ce2).replace(/punct/g, pe2).getRegex();
var Ge2 = h("^[^_*]*?\\*\\*[^_*]*?_[^_*]*?(?=\\*\\*)|[^_]+(?=[^_])|(?!_)punct(_+)(?=[\\s]|$)|notPunctSpace(_+)(?!_)(?=punctSpace|$)|(?!_)punctSpace(_+)(?=notPunctSpace)|[\\s](_+)(?!_)(?=punct)|(?!_)punct(_+)(?!_)(?=punct)", "gu").replace(/notPunctSpace/g, ue2).replace(/punctSpace/g, W2).replace(/punct/g, D2).getRegex();
var Ne2 = h(/\\(punct)/, "gu").replace(/punct/g, D2).getRegex();
var Fe2 = h(/^<(scheme:[^\s\x00-\x1f<>]*|email)>/).replace("scheme", /[a-zA-Z][a-zA-Z0-9+.-]{1,31}/).replace("email", /[a-zA-Z0-9.!#$%&'*+/=?^_`{|}~-]+(@)[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)+(?![-_])/).getRegex();
var je = h(U2).replace("(?:-->|$)", "-->").getRegex();
var Qe = h("^comment|^</[a-zA-Z][\\w:-]*\\s*>|^<[a-zA-Z][\\w-]*(?:attribute)*?\\s*/?>|^<\\?[\\s\\S]*?\\?>|^<![a-zA-Z]+\\s[\\s\\S]*?>|^<!\\[CDATA\\[[\\s\\S]*?\\]\\]>").replace("comment", je).replace("attribute", /\s+[a-zA-Z:_][\w.:-]*(?:\s*=\s*"[^"]*"|\s*=\s*'[^']*'|\s*=\s*[^\s"'=<>`]+)?/).getRegex();
var q2 = /(?:\[(?:\\[\s\S]|[^\[\]\\])*\]|\\[\s\S]|`+[^`]*?`+(?!`)|[^\[\]\\`])*?/;
var Ue2 = h(/^!?\[(label)\]\(\s*(href)(?:(?:[ \t]*(?:\n[ \t]*)?)(title))?\s*\)/).replace("label", q2).replace("href", /<(?:\\.|[^\n<>\\])+>|[^ \t\n\x00-\x1f]*/).replace("title", /"(?:\\"?|[^"\\])*"|'(?:\\'?|[^'\\])*'|\((?:\\\)?|[^)\\])*\)/).getRegex();
var de2 = h(/^!?\[(label)\]\[(ref)\]/).replace("label", q2).replace("ref", Q2).getRegex();
var ke2 = h(/^!?\[(ref)\](?:\[\])?/).replace("ref", Q2).getRegex();
var Ke2 = h("reflink|nolink(?!\\()", "g").replace("reflink", de2).replace("nolink", ke2).getRegex();
var se2 = /[hH][tT][tT][pP][sS]?|[fF][tT][pP]/;
var X2 = { _backpedal: I2, anyPunctuation: Ne2, autolink: Fe2, blockSkip: qe, br: le2, code: Ae2, del: I2, emStrongLDelim: ve2, emStrongRDelimAst: He2, emStrongRDelimUnd: Ge2, escape: ze2, link: Ue2, nolink: ke2, punctuation: Ee2, reflink: de2, reflinkSearch: Ke2, tag: Qe, text: Ie2, url: I2 };
var We2 = { ...X2, link: h(/^!?\[(label)\]\((.*?)\)/).replace("label", q2).getRegex(), reflink: h(/^!?\[(label)\]\s*\[([^\]]*)\]/).replace("label", q2).getRegex() };
var N2 = { ...X2, emStrongRDelimAst: Ze2, emStrongLDelim: De2, url: h(/^((?:protocol):\/\/|www\.)(?:[a-zA-Z0-9\-]+\.?)+[^\s<]*|^email/).replace("protocol", se2).replace("email", /[A-Za-z0-9._+-]+(@)[a-zA-Z0-9-_]+(?:\.[a-zA-Z0-9-_]*[a-zA-Z0-9])+(?![-_])/).getRegex(), _backpedal: /(?:[^?!.,:;*_'"~()&]+|\([^)]*\)|&(?![a-zA-Z0-9]+;$)|[?!.,:;*_'"~)]+(?!$))+/, del: /^(~~?)(?=[^\s~])((?:\\[\s\S]|[^\\])*?(?:\\[\s\S]|[^\s~\\]))\1(?=[^~]|$)/, text: h(/^([`~]+|[^`~])(?:(?= {2,}\n)|(?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)|[\s\S]*?(?:(?=[\\<!\[`*~_]|\b_|protocol:\/\/|www\.|$)|[^ ](?= {2,}\n)|[^a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-](?=[a-zA-Z0-9.!#$%&'*+\/=?_`{\|}~-]+@)))/).replace("protocol", se2).getRegex() };
var Xe2 = { ...N2, br: h(le2).replace("{2,}", "*").getRegex(), text: h(N2.text).replace("\\b_", "\\b_| {2,}\\n").replace(/\{2,\}/g, "*").getRegex() };
var C2 = { normal: K2, gfm: Le2, pedantic: Me2 };
var M2 = { normal: X2, gfm: N2, breaks: Xe2, pedantic: We2 };
var Je2 = { "&": "&amp;", "<": "&lt;", ">": "&gt;", '"': "&quot;", "'": "&#39;" };
var ge2 = (u) => Je2[u];
function w2(u, e) {
  if (e) {
    if (m2.escapeTest.test(u))
      return u.replace(m2.escapeReplace, ge2);
  } else if (m2.escapeTestNoEncode.test(u))
    return u.replace(m2.escapeReplaceNoEncode, ge2);
  return u;
}
function J2(u) {
  try {
    u = encodeURI(u).replace(m2.percentDecode, "%");
  } catch {
    return null;
  }
  return u;
}
function V2(u, e) {
  let t = u.replace(m2.findPipe, (i, s, o) => {
    let a2 = false, l = s;
    for (;--l >= 0 && o[l] === "\\"; )
      a2 = !a2;
    return a2 ? "|" : " |";
  }), n = t.split(m2.splitPipe), r = 0;
  if (n[0].trim() || n.shift(), n.length > 0 && !n.at(-1)?.trim() && n.pop(), e)
    if (n.length > e)
      n.splice(e);
    else
      for (;n.length < e; )
        n.push("");
  for (;r < n.length; r++)
    n[r] = n[r].trim().replace(m2.slashPipe, "|");
  return n;
}
function z2(u, e, t) {
  let n = u.length;
  if (n === 0)
    return "";
  let r = 0;
  for (;r < n; ) {
    let i = u.charAt(n - r - 1);
    if (i === e && !t)
      r++;
    else if (i !== e && t)
      r++;
    else
      break;
  }
  return u.slice(0, n - r);
}
function fe2(u, e) {
  if (u.indexOf(e[1]) === -1)
    return -1;
  let t = 0;
  for (let n = 0;n < u.length; n++)
    if (u[n] === "\\")
      n++;
    else if (u[n] === e[0])
      t++;
    else if (u[n] === e[1] && (t--, t < 0))
      return n;
  return t > 0 ? -2 : -1;
}
function me2(u, e, t, n, r) {
  let i = e.href, s = e.title || null, o = u[1].replace(r.other.outputLinkReplace, "$1");
  n.state.inLink = true;
  let a2 = { type: u[0].charAt(0) === "!" ? "image" : "link", raw: t, href: i, title: s, text: o, tokens: n.inlineTokens(o) };
  return n.state.inLink = false, a2;
}
function Ve2(u, e, t) {
  let n = u.match(t.other.indentCodeCompensation);
  if (n === null)
    return e;
  let r = n[1];
  return e.split(`
`).map((i) => {
    let s = i.match(t.other.beginningSpace);
    if (s === null)
      return i;
    let [o] = s;
    return o.length >= r.length ? i.slice(r.length) : i;
  }).join(`
`);
}
var y = class {
  options;
  rules;
  lexer;
  constructor(e) {
    this.options = e || T2;
  }
  space(e) {
    let t = this.rules.block.newline.exec(e);
    if (t && t[0].length > 0)
      return { type: "space", raw: t[0] };
  }
  code(e) {
    let t = this.rules.block.code.exec(e);
    if (t) {
      let n = t[0].replace(this.rules.other.codeRemoveIndent, "");
      return { type: "code", raw: t[0], codeBlockStyle: "indented", text: this.options.pedantic ? n : z2(n, `
`) };
    }
  }
  fences(e) {
    let t = this.rules.block.fences.exec(e);
    if (t) {
      let n = t[0], r = Ve2(n, t[3] || "", this.rules);
      return { type: "code", raw: n, lang: t[2] ? t[2].trim().replace(this.rules.inline.anyPunctuation, "$1") : t[2], text: r };
    }
  }
  heading(e) {
    let t = this.rules.block.heading.exec(e);
    if (t) {
      let n = t[2].trim();
      if (this.rules.other.endingHash.test(n)) {
        let r = z2(n, "#");
        (this.options.pedantic || !r || this.rules.other.endingSpaceChar.test(r)) && (n = r.trim());
      }
      return { type: "heading", raw: t[0], depth: t[1].length, text: n, tokens: this.lexer.inline(n) };
    }
  }
  hr(e) {
    let t = this.rules.block.hr.exec(e);
    if (t)
      return { type: "hr", raw: z2(t[0], `
`) };
  }
  blockquote(e) {
    let t = this.rules.block.blockquote.exec(e);
    if (t) {
      let n = z2(t[0], `
`).split(`
`), r = "", i = "", s = [];
      for (;n.length > 0; ) {
        let o = false, a2 = [], l;
        for (l = 0;l < n.length; l++)
          if (this.rules.other.blockquoteStart.test(n[l]))
            a2.push(n[l]), o = true;
          else if (!o)
            a2.push(n[l]);
          else
            break;
        n = n.slice(l);
        let c = a2.join(`
`), p = c.replace(this.rules.other.blockquoteSetextReplace, `
    $1`).replace(this.rules.other.blockquoteSetextReplace2, "");
        r = r ? `${r}
${c}` : c, i = i ? `${i}
${p}` : p;
        let g2 = this.lexer.state.top;
        if (this.lexer.state.top = true, this.lexer.blockTokens(p, s, true), this.lexer.state.top = g2, n.length === 0)
          break;
        let d = s.at(-1);
        if (d?.type === "code")
          break;
        if (d?.type === "blockquote") {
          let R = d, f2 = R.raw + `
` + n.join(`
`), O2 = this.blockquote(f2);
          s[s.length - 1] = O2, r = r.substring(0, r.length - R.raw.length) + O2.raw, i = i.substring(0, i.length - R.text.length) + O2.text;
          break;
        } else if (d?.type === "list") {
          let R = d, f2 = R.raw + `
` + n.join(`
`), O2 = this.list(f2);
          s[s.length - 1] = O2, r = r.substring(0, r.length - d.raw.length) + O2.raw, i = i.substring(0, i.length - R.raw.length) + O2.raw, n = f2.substring(s.at(-1).raw.length).split(`
`);
          continue;
        }
      }
      return { type: "blockquote", raw: r, tokens: s, text: i };
    }
  }
  list(e) {
    let t = this.rules.block.list.exec(e);
    if (t) {
      let n = t[1].trim(), r = n.length > 1, i = { type: "list", raw: "", ordered: r, start: r ? +n.slice(0, -1) : "", loose: false, items: [] };
      n = r ? `\\d{1,9}\\${n.slice(-1)}` : `\\${n}`, this.options.pedantic && (n = r ? n : "[*+-]");
      let s = this.rules.other.listItemRegex(n), o = false;
      for (;e; ) {
        let l = false, c = "", p = "";
        if (!(t = s.exec(e)) || this.rules.block.hr.test(e))
          break;
        c = t[0], e = e.substring(c.length);
        let g2 = t[2].split(`
`, 1)[0].replace(this.rules.other.listReplaceTabs, (H2) => " ".repeat(3 * H2.length)), d = e.split(`
`, 1)[0], R = !g2.trim(), f2 = 0;
        if (this.options.pedantic ? (f2 = 2, p = g2.trimStart()) : R ? f2 = t[1].length + 1 : (f2 = t[2].search(this.rules.other.nonSpaceChar), f2 = f2 > 4 ? 1 : f2, p = g2.slice(f2), f2 += t[1].length), R && this.rules.other.blankLine.test(d) && (c += d + `
`, e = e.substring(d.length + 1), l = true), !l) {
          let H2 = this.rules.other.nextBulletRegex(f2), ee2 = this.rules.other.hrRegex(f2), te2 = this.rules.other.fencesBeginRegex(f2), ne2 = this.rules.other.headingBeginRegex(f2), xe2 = this.rules.other.htmlBeginRegex(f2);
          for (;e; ) {
            let Z2 = e.split(`
`, 1)[0], A2;
            if (d = Z2, this.options.pedantic ? (d = d.replace(this.rules.other.listReplaceNesting, "  "), A2 = d) : A2 = d.replace(this.rules.other.tabCharGlobal, "    "), te2.test(d) || ne2.test(d) || xe2.test(d) || H2.test(d) || ee2.test(d))
              break;
            if (A2.search(this.rules.other.nonSpaceChar) >= f2 || !d.trim())
              p += `
` + A2.slice(f2);
            else {
              if (R || g2.replace(this.rules.other.tabCharGlobal, "    ").search(this.rules.other.nonSpaceChar) >= 4 || te2.test(g2) || ne2.test(g2) || ee2.test(g2))
                break;
              p += `
` + d;
            }
            !R && !d.trim() && (R = true), c += Z2 + `
`, e = e.substring(Z2.length + 1), g2 = A2.slice(f2);
          }
        }
        i.loose || (o ? i.loose = true : this.rules.other.doubleBlankLine.test(c) && (o = true));
        let O2 = null, Y2;
        this.options.gfm && (O2 = this.rules.other.listIsTask.exec(p), O2 && (Y2 = O2[0] !== "[ ] ", p = p.replace(this.rules.other.listReplaceTask, ""))), i.items.push({ type: "list_item", raw: c, task: !!O2, checked: Y2, loose: false, text: p, tokens: [] }), i.raw += c;
      }
      let a2 = i.items.at(-1);
      if (a2)
        a2.raw = a2.raw.trimEnd(), a2.text = a2.text.trimEnd();
      else
        return;
      i.raw = i.raw.trimEnd();
      for (let l = 0;l < i.items.length; l++)
        if (this.lexer.state.top = false, i.items[l].tokens = this.lexer.blockTokens(i.items[l].text, []), !i.loose) {
          let c = i.items[l].tokens.filter((g2) => g2.type === "space"), p = c.length > 0 && c.some((g2) => this.rules.other.anyLine.test(g2.raw));
          i.loose = p;
        }
      if (i.loose)
        for (let l = 0;l < i.items.length; l++)
          i.items[l].loose = true;
      return i;
    }
  }
  html(e) {
    let t = this.rules.block.html.exec(e);
    if (t)
      return { type: "html", block: true, raw: t[0], pre: t[1] === "pre" || t[1] === "script" || t[1] === "style", text: t[0] };
  }
  def(e) {
    let t = this.rules.block.def.exec(e);
    if (t) {
      let n = t[1].toLowerCase().replace(this.rules.other.multipleSpaceGlobal, " "), r = t[2] ? t[2].replace(this.rules.other.hrefBrackets, "$1").replace(this.rules.inline.anyPunctuation, "$1") : "", i = t[3] ? t[3].substring(1, t[3].length - 1).replace(this.rules.inline.anyPunctuation, "$1") : t[3];
      return { type: "def", tag: n, raw: t[0], href: r, title: i };
    }
  }
  table(e) {
    let t = this.rules.block.table.exec(e);
    if (!t || !this.rules.other.tableDelimiter.test(t[2]))
      return;
    let n = V2(t[1]), r = t[2].replace(this.rules.other.tableAlignChars, "").split("|"), i = t[3]?.trim() ? t[3].replace(this.rules.other.tableRowBlankLine, "").split(`
`) : [], s = { type: "table", raw: t[0], header: [], align: [], rows: [] };
    if (n.length === r.length) {
      for (let o of r)
        this.rules.other.tableAlignRight.test(o) ? s.align.push("right") : this.rules.other.tableAlignCenter.test(o) ? s.align.push("center") : this.rules.other.tableAlignLeft.test(o) ? s.align.push("left") : s.align.push(null);
      for (let o = 0;o < n.length; o++)
        s.header.push({ text: n[o], tokens: this.lexer.inline(n[o]), header: true, align: s.align[o] });
      for (let o of i)
        s.rows.push(V2(o, s.header.length).map((a2, l) => ({ text: a2, tokens: this.lexer.inline(a2), header: false, align: s.align[l] })));
      return s;
    }
  }
  lheading(e) {
    let t = this.rules.block.lheading.exec(e);
    if (t)
      return { type: "heading", raw: t[0], depth: t[2].charAt(0) === "=" ? 1 : 2, text: t[1], tokens: this.lexer.inline(t[1]) };
  }
  paragraph(e) {
    let t = this.rules.block.paragraph.exec(e);
    if (t) {
      let n = t[1].charAt(t[1].length - 1) === `
` ? t[1].slice(0, -1) : t[1];
      return { type: "paragraph", raw: t[0], text: n, tokens: this.lexer.inline(n) };
    }
  }
  text(e) {
    let t = this.rules.block.text.exec(e);
    if (t)
      return { type: "text", raw: t[0], text: t[0], tokens: this.lexer.inline(t[0]) };
  }
  escape(e) {
    let t = this.rules.inline.escape.exec(e);
    if (t)
      return { type: "escape", raw: t[0], text: t[1] };
  }
  tag(e) {
    let t = this.rules.inline.tag.exec(e);
    if (t)
      return !this.lexer.state.inLink && this.rules.other.startATag.test(t[0]) ? this.lexer.state.inLink = true : this.lexer.state.inLink && this.rules.other.endATag.test(t[0]) && (this.lexer.state.inLink = false), !this.lexer.state.inRawBlock && this.rules.other.startPreScriptTag.test(t[0]) ? this.lexer.state.inRawBlock = true : this.lexer.state.inRawBlock && this.rules.other.endPreScriptTag.test(t[0]) && (this.lexer.state.inRawBlock = false), { type: "html", raw: t[0], inLink: this.lexer.state.inLink, inRawBlock: this.lexer.state.inRawBlock, block: false, text: t[0] };
  }
  link(e) {
    let t = this.rules.inline.link.exec(e);
    if (t) {
      let n = t[2].trim();
      if (!this.options.pedantic && this.rules.other.startAngleBracket.test(n)) {
        if (!this.rules.other.endAngleBracket.test(n))
          return;
        let s = z2(n.slice(0, -1), "\\");
        if ((n.length - s.length) % 2 === 0)
          return;
      } else {
        let s = fe2(t[2], "()");
        if (s === -2)
          return;
        if (s > -1) {
          let a2 = (t[0].indexOf("!") === 0 ? 5 : 4) + t[1].length + s;
          t[2] = t[2].substring(0, s), t[0] = t[0].substring(0, a2).trim(), t[3] = "";
        }
      }
      let r = t[2], i = "";
      if (this.options.pedantic) {
        let s = this.rules.other.pedanticHrefTitle.exec(r);
        s && (r = s[1], i = s[3]);
      } else
        i = t[3] ? t[3].slice(1, -1) : "";
      return r = r.trim(), this.rules.other.startAngleBracket.test(r) && (this.options.pedantic && !this.rules.other.endAngleBracket.test(n) ? r = r.slice(1) : r = r.slice(1, -1)), me2(t, { href: r && r.replace(this.rules.inline.anyPunctuation, "$1"), title: i && i.replace(this.rules.inline.anyPunctuation, "$1") }, t[0], this.lexer, this.rules);
    }
  }
  reflink(e, t) {
    let n;
    if ((n = this.rules.inline.reflink.exec(e)) || (n = this.rules.inline.nolink.exec(e))) {
      let r = (n[2] || n[1]).replace(this.rules.other.multipleSpaceGlobal, " "), i = t[r.toLowerCase()];
      if (!i) {
        let s = n[0].charAt(0);
        return { type: "text", raw: s, text: s };
      }
      return me2(n, i, n[0], this.lexer, this.rules);
    }
  }
  emStrong(e, t, n = "") {
    let r = this.rules.inline.emStrongLDelim.exec(e);
    if (!r || r[3] && n.match(this.rules.other.unicodeAlphaNumeric))
      return;
    if (!(r[1] || r[2] || "") || !n || this.rules.inline.punctuation.exec(n)) {
      let s = [...r[0]].length - 1, o, a2, l = s, c = 0, p = r[0][0] === "*" ? this.rules.inline.emStrongRDelimAst : this.rules.inline.emStrongRDelimUnd;
      for (p.lastIndex = 0, t = t.slice(-1 * e.length + s);(r = p.exec(t)) != null; ) {
        if (o = r[1] || r[2] || r[3] || r[4] || r[5] || r[6], !o)
          continue;
        if (a2 = [...o].length, r[3] || r[4]) {
          l += a2;
          continue;
        } else if ((r[5] || r[6]) && s % 3 && !((s + a2) % 3)) {
          c += a2;
          continue;
        }
        if (l -= a2, l > 0)
          continue;
        a2 = Math.min(a2, a2 + l + c);
        let g2 = [...r[0]][0].length, d = e.slice(0, s + r.index + g2 + a2);
        if (Math.min(s, a2) % 2) {
          let f2 = d.slice(1, -1);
          return { type: "em", raw: d, text: f2, tokens: this.lexer.inlineTokens(f2) };
        }
        let R = d.slice(2, -2);
        return { type: "strong", raw: d, text: R, tokens: this.lexer.inlineTokens(R) };
      }
    }
  }
  codespan(e) {
    let t = this.rules.inline.code.exec(e);
    if (t) {
      let n = t[2].replace(this.rules.other.newLineCharGlobal, " "), r = this.rules.other.nonSpaceChar.test(n), i = this.rules.other.startingSpaceChar.test(n) && this.rules.other.endingSpaceChar.test(n);
      return r && i && (n = n.substring(1, n.length - 1)), { type: "codespan", raw: t[0], text: n };
    }
  }
  br(e) {
    let t = this.rules.inline.br.exec(e);
    if (t)
      return { type: "br", raw: t[0] };
  }
  del(e) {
    let t = this.rules.inline.del.exec(e);
    if (t)
      return { type: "del", raw: t[0], text: t[2], tokens: this.lexer.inlineTokens(t[2]) };
  }
  autolink(e) {
    let t = this.rules.inline.autolink.exec(e);
    if (t) {
      let n, r;
      return t[2] === "@" ? (n = t[1], r = "mailto:" + n) : (n = t[1], r = n), { type: "link", raw: t[0], text: n, href: r, tokens: [{ type: "text", raw: n, text: n }] };
    }
  }
  url(e) {
    let t;
    if (t = this.rules.inline.url.exec(e)) {
      let n, r;
      if (t[2] === "@")
        n = t[0], r = "mailto:" + n;
      else {
        let i;
        do
          i = t[0], t[0] = this.rules.inline._backpedal.exec(t[0])?.[0] ?? "";
        while (i !== t[0]);
        n = t[0], t[1] === "www." ? r = "http://" + t[0] : r = t[0];
      }
      return { type: "link", raw: t[0], text: n, href: r, tokens: [{ type: "text", raw: n, text: n }] };
    }
  }
  inlineText(e) {
    let t = this.rules.inline.text.exec(e);
    if (t) {
      let n = this.lexer.state.inRawBlock;
      return { type: "text", raw: t[0], text: t[0], escaped: n };
    }
  }
};
var x = class u {
  tokens;
  options;
  state;
  tokenizer;
  inlineQueue;
  constructor(e) {
    this.tokens = [], this.tokens.links = Object.create(null), this.options = e || T2, this.options.tokenizer = this.options.tokenizer || new y, this.tokenizer = this.options.tokenizer, this.tokenizer.options = this.options, this.tokenizer.lexer = this, this.inlineQueue = [], this.state = { inLink: false, inRawBlock: false, top: true };
    let t = { other: m2, block: C2.normal, inline: M2.normal };
    this.options.pedantic ? (t.block = C2.pedantic, t.inline = M2.pedantic) : this.options.gfm && (t.block = C2.gfm, this.options.breaks ? t.inline = M2.breaks : t.inline = M2.gfm), this.tokenizer.rules = t;
  }
  static get rules() {
    return { block: C2, inline: M2 };
  }
  static lex(e, t) {
    return new u(t).lex(e);
  }
  static lexInline(e, t) {
    return new u(t).inlineTokens(e);
  }
  lex(e) {
    e = e.replace(m2.carriageReturn, `
`), this.blockTokens(e, this.tokens);
    for (let t = 0;t < this.inlineQueue.length; t++) {
      let n = this.inlineQueue[t];
      this.inlineTokens(n.src, n.tokens);
    }
    return this.inlineQueue = [], this.tokens;
  }
  blockTokens(e, t = [], n = false) {
    for (this.options.pedantic && (e = e.replace(m2.tabCharGlobal, "    ").replace(m2.spaceLine, ""));e; ) {
      let r;
      if (this.options.extensions?.block?.some((s) => (r = s.call({ lexer: this }, e, t)) ? (e = e.substring(r.raw.length), t.push(r), true) : false))
        continue;
      if (r = this.tokenizer.space(e)) {
        e = e.substring(r.raw.length);
        let s = t.at(-1);
        r.raw.length === 1 && s !== undefined ? s.raw += `
` : t.push(r);
        continue;
      }
      if (r = this.tokenizer.code(e)) {
        e = e.substring(r.raw.length);
        let s = t.at(-1);
        s?.type === "paragraph" || s?.type === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + r.raw, s.text += `
` + r.text, this.inlineQueue.at(-1).src = s.text) : t.push(r);
        continue;
      }
      if (r = this.tokenizer.fences(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      if (r = this.tokenizer.heading(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      if (r = this.tokenizer.hr(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      if (r = this.tokenizer.blockquote(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      if (r = this.tokenizer.list(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      if (r = this.tokenizer.html(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      if (r = this.tokenizer.def(e)) {
        e = e.substring(r.raw.length);
        let s = t.at(-1);
        s?.type === "paragraph" || s?.type === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + r.raw, s.text += `
` + r.raw, this.inlineQueue.at(-1).src = s.text) : this.tokens.links[r.tag] || (this.tokens.links[r.tag] = { href: r.href, title: r.title }, t.push(r));
        continue;
      }
      if (r = this.tokenizer.table(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      if (r = this.tokenizer.lheading(e)) {
        e = e.substring(r.raw.length), t.push(r);
        continue;
      }
      let i = e;
      if (this.options.extensions?.startBlock) {
        let s = 1 / 0, o = e.slice(1), a2;
        this.options.extensions.startBlock.forEach((l) => {
          a2 = l.call({ lexer: this }, o), typeof a2 == "number" && a2 >= 0 && (s = Math.min(s, a2));
        }), s < 1 / 0 && s >= 0 && (i = e.substring(0, s + 1));
      }
      if (this.state.top && (r = this.tokenizer.paragraph(i))) {
        let s = t.at(-1);
        n && s?.type === "paragraph" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + r.raw, s.text += `
` + r.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = s.text) : t.push(r), n = i.length !== e.length, e = e.substring(r.raw.length);
        continue;
      }
      if (r = this.tokenizer.text(e)) {
        e = e.substring(r.raw.length);
        let s = t.at(-1);
        s?.type === "text" ? (s.raw += (s.raw.endsWith(`
`) ? "" : `
`) + r.raw, s.text += `
` + r.text, this.inlineQueue.pop(), this.inlineQueue.at(-1).src = s.text) : t.push(r);
        continue;
      }
      if (e) {
        let s = "Infinite loop on byte: " + e.charCodeAt(0);
        if (this.options.silent) {
          console.error(s);
          break;
        } else
          throw new Error(s);
      }
    }
    return this.state.top = true, t;
  }
  inline(e, t = []) {
    return this.inlineQueue.push({ src: e, tokens: t }), t;
  }
  inlineTokens(e, t = []) {
    let n = e, r = null;
    if (this.tokens.links) {
      let o = Object.keys(this.tokens.links);
      if (o.length > 0)
        for (;(r = this.tokenizer.rules.inline.reflinkSearch.exec(n)) != null; )
          o.includes(r[0].slice(r[0].lastIndexOf("[") + 1, -1)) && (n = n.slice(0, r.index) + "[" + "a".repeat(r[0].length - 2) + "]" + n.slice(this.tokenizer.rules.inline.reflinkSearch.lastIndex));
    }
    for (;(r = this.tokenizer.rules.inline.anyPunctuation.exec(n)) != null; )
      n = n.slice(0, r.index) + "++" + n.slice(this.tokenizer.rules.inline.anyPunctuation.lastIndex);
    for (;(r = this.tokenizer.rules.inline.blockSkip.exec(n)) != null; )
      n = n.slice(0, r.index) + "[" + "a".repeat(r[0].length - 2) + "]" + n.slice(this.tokenizer.rules.inline.blockSkip.lastIndex);
    n = this.options.hooks?.emStrongMask?.call({ lexer: this }, n) ?? n;
    let i = false, s = "";
    for (;e; ) {
      i || (s = ""), i = false;
      let o;
      if (this.options.extensions?.inline?.some((l) => (o = l.call({ lexer: this }, e, t)) ? (e = e.substring(o.raw.length), t.push(o), true) : false))
        continue;
      if (o = this.tokenizer.escape(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.tag(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.link(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.reflink(e, this.tokens.links)) {
        e = e.substring(o.raw.length);
        let l = t.at(-1);
        o.type === "text" && l?.type === "text" ? (l.raw += o.raw, l.text += o.text) : t.push(o);
        continue;
      }
      if (o = this.tokenizer.emStrong(e, n, s)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.codespan(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.br(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.del(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (o = this.tokenizer.autolink(e)) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      if (!this.state.inLink && (o = this.tokenizer.url(e))) {
        e = e.substring(o.raw.length), t.push(o);
        continue;
      }
      let a2 = e;
      if (this.options.extensions?.startInline) {
        let l = 1 / 0, c = e.slice(1), p;
        this.options.extensions.startInline.forEach((g2) => {
          p = g2.call({ lexer: this }, c), typeof p == "number" && p >= 0 && (l = Math.min(l, p));
        }), l < 1 / 0 && l >= 0 && (a2 = e.substring(0, l + 1));
      }
      if (o = this.tokenizer.inlineText(a2)) {
        e = e.substring(o.raw.length), o.raw.slice(-1) !== "_" && (s = o.raw.slice(-1)), i = true;
        let l = t.at(-1);
        l?.type === "text" ? (l.raw += o.raw, l.text += o.text) : t.push(o);
        continue;
      }
      if (e) {
        let l = "Infinite loop on byte: " + e.charCodeAt(0);
        if (this.options.silent) {
          console.error(l);
          break;
        } else
          throw new Error(l);
      }
    }
    return t;
  }
};
var P2 = class {
  options;
  parser;
  constructor(e) {
    this.options = e || T2;
  }
  space(e) {
    return "";
  }
  code({ text: e, lang: t, escaped: n }) {
    let r = (t || "").match(m2.notSpaceStart)?.[0], i = e.replace(m2.endingNewline, "") + `
`;
    return r ? '<pre><code class="language-' + w2(r) + '">' + (n ? i : w2(i, true)) + `</code></pre>
` : "<pre><code>" + (n ? i : w2(i, true)) + `</code></pre>
`;
  }
  blockquote({ tokens: e }) {
    return `<blockquote>
${this.parser.parse(e)}</blockquote>
`;
  }
  html({ text: e }) {
    return e;
  }
  def(e) {
    return "";
  }
  heading({ tokens: e, depth: t }) {
    return `<h${t}>${this.parser.parseInline(e)}</h${t}>
`;
  }
  hr(e) {
    return `<hr>
`;
  }
  list(e) {
    let { ordered: t, start: n } = e, r = "";
    for (let o = 0;o < e.items.length; o++) {
      let a2 = e.items[o];
      r += this.listitem(a2);
    }
    let i = t ? "ol" : "ul", s = t && n !== 1 ? ' start="' + n + '"' : "";
    return "<" + i + s + `>
` + r + "</" + i + `>
`;
  }
  listitem(e) {
    let t = "";
    if (e.task) {
      let n = this.checkbox({ checked: !!e.checked });
      e.loose ? e.tokens[0]?.type === "paragraph" ? (e.tokens[0].text = n + " " + e.tokens[0].text, e.tokens[0].tokens && e.tokens[0].tokens.length > 0 && e.tokens[0].tokens[0].type === "text" && (e.tokens[0].tokens[0].text = n + " " + w2(e.tokens[0].tokens[0].text), e.tokens[0].tokens[0].escaped = true)) : e.tokens.unshift({ type: "text", raw: n + " ", text: n + " ", escaped: true }) : t += n + " ";
    }
    return t += this.parser.parse(e.tokens, !!e.loose), `<li>${t}</li>
`;
  }
  checkbox({ checked: e }) {
    return "<input " + (e ? 'checked="" ' : "") + 'disabled="" type="checkbox">';
  }
  paragraph({ tokens: e }) {
    return `<p>${this.parser.parseInline(e)}</p>
`;
  }
  table(e) {
    let t = "", n = "";
    for (let i = 0;i < e.header.length; i++)
      n += this.tablecell(e.header[i]);
    t += this.tablerow({ text: n });
    let r = "";
    for (let i = 0;i < e.rows.length; i++) {
      let s = e.rows[i];
      n = "";
      for (let o = 0;o < s.length; o++)
        n += this.tablecell(s[o]);
      r += this.tablerow({ text: n });
    }
    return r && (r = `<tbody>${r}</tbody>`), `<table>
<thead>
` + t + `</thead>
` + r + `</table>
`;
  }
  tablerow({ text: e }) {
    return `<tr>
${e}</tr>
`;
  }
  tablecell(e) {
    let t = this.parser.parseInline(e.tokens), n = e.header ? "th" : "td";
    return (e.align ? `<${n} align="${e.align}">` : `<${n}>`) + t + `</${n}>
`;
  }
  strong({ tokens: e }) {
    return `<strong>${this.parser.parseInline(e)}</strong>`;
  }
  em({ tokens: e }) {
    return `<em>${this.parser.parseInline(e)}</em>`;
  }
  codespan({ text: e }) {
    return `<code>${w2(e, true)}</code>`;
  }
  br(e) {
    return "<br>";
  }
  del({ tokens: e }) {
    return `<del>${this.parser.parseInline(e)}</del>`;
  }
  link({ href: e, title: t, tokens: n }) {
    let r = this.parser.parseInline(n), i = J2(e);
    if (i === null)
      return r;
    e = i;
    let s = '<a href="' + e + '"';
    return t && (s += ' title="' + w2(t) + '"'), s += ">" + r + "</a>", s;
  }
  image({ href: e, title: t, text: n, tokens: r }) {
    r && (n = this.parser.parseInline(r, this.parser.textRenderer));
    let i = J2(e);
    if (i === null)
      return w2(n);
    e = i;
    let s = `<img src="${e}" alt="${n}"`;
    return t && (s += ` title="${w2(t)}"`), s += ">", s;
  }
  text(e) {
    return "tokens" in e && e.tokens ? this.parser.parseInline(e.tokens) : ("escaped" in e) && e.escaped ? e.text : w2(e.text);
  }
};
var $2 = class {
  strong({ text: e }) {
    return e;
  }
  em({ text: e }) {
    return e;
  }
  codespan({ text: e }) {
    return e;
  }
  del({ text: e }) {
    return e;
  }
  html({ text: e }) {
    return e;
  }
  text({ text: e }) {
    return e;
  }
  link({ text: e }) {
    return "" + e;
  }
  image({ text: e }) {
    return "" + e;
  }
  br() {
    return "";
  }
};
var b2 = class u2 {
  options;
  renderer;
  textRenderer;
  constructor(e) {
    this.options = e || T2, this.options.renderer = this.options.renderer || new P2, this.renderer = this.options.renderer, this.renderer.options = this.options, this.renderer.parser = this, this.textRenderer = new $2;
  }
  static parse(e, t) {
    return new u2(t).parse(e);
  }
  static parseInline(e, t) {
    return new u2(t).parseInline(e);
  }
  parse(e, t = true) {
    let n = "";
    for (let r = 0;r < e.length; r++) {
      let i = e[r];
      if (this.options.extensions?.renderers?.[i.type]) {
        let o = i, a2 = this.options.extensions.renderers[o.type].call({ parser: this }, o);
        if (a2 !== false || !["space", "hr", "heading", "code", "table", "blockquote", "list", "html", "def", "paragraph", "text"].includes(o.type)) {
          n += a2 || "";
          continue;
        }
      }
      let s = i;
      switch (s.type) {
        case "space": {
          n += this.renderer.space(s);
          continue;
        }
        case "hr": {
          n += this.renderer.hr(s);
          continue;
        }
        case "heading": {
          n += this.renderer.heading(s);
          continue;
        }
        case "code": {
          n += this.renderer.code(s);
          continue;
        }
        case "table": {
          n += this.renderer.table(s);
          continue;
        }
        case "blockquote": {
          n += this.renderer.blockquote(s);
          continue;
        }
        case "list": {
          n += this.renderer.list(s);
          continue;
        }
        case "html": {
          n += this.renderer.html(s);
          continue;
        }
        case "def": {
          n += this.renderer.def(s);
          continue;
        }
        case "paragraph": {
          n += this.renderer.paragraph(s);
          continue;
        }
        case "text": {
          let o = s, a2 = this.renderer.text(o);
          for (;r + 1 < e.length && e[r + 1].type === "text"; )
            o = e[++r], a2 += `
` + this.renderer.text(o);
          t ? n += this.renderer.paragraph({ type: "paragraph", raw: a2, text: a2, tokens: [{ type: "text", raw: a2, text: a2, escaped: true }] }) : n += a2;
          continue;
        }
        default: {
          let o = 'Token with "' + s.type + '" type was not found.';
          if (this.options.silent)
            return console.error(o), "";
          throw new Error(o);
        }
      }
    }
    return n;
  }
  parseInline(e, t = this.renderer) {
    let n = "";
    for (let r = 0;r < e.length; r++) {
      let i = e[r];
      if (this.options.extensions?.renderers?.[i.type]) {
        let o = this.options.extensions.renderers[i.type].call({ parser: this }, i);
        if (o !== false || !["escape", "html", "link", "image", "strong", "em", "codespan", "br", "del", "text"].includes(i.type)) {
          n += o || "";
          continue;
        }
      }
      let s = i;
      switch (s.type) {
        case "escape": {
          n += t.text(s);
          break;
        }
        case "html": {
          n += t.html(s);
          break;
        }
        case "link": {
          n += t.link(s);
          break;
        }
        case "image": {
          n += t.image(s);
          break;
        }
        case "strong": {
          n += t.strong(s);
          break;
        }
        case "em": {
          n += t.em(s);
          break;
        }
        case "codespan": {
          n += t.codespan(s);
          break;
        }
        case "br": {
          n += t.br(s);
          break;
        }
        case "del": {
          n += t.del(s);
          break;
        }
        case "text": {
          n += t.text(s);
          break;
        }
        default: {
          let o = 'Token with "' + s.type + '" type was not found.';
          if (this.options.silent)
            return console.error(o), "";
          throw new Error(o);
        }
      }
    }
    return n;
  }
};
var S = class {
  options;
  block;
  constructor(e) {
    this.options = e || T2;
  }
  static passThroughHooks = new Set(["preprocess", "postprocess", "processAllTokens", "emStrongMask"]);
  static passThroughHooksRespectAsync = new Set(["preprocess", "postprocess", "processAllTokens"]);
  preprocess(e) {
    return e;
  }
  postprocess(e) {
    return e;
  }
  processAllTokens(e) {
    return e;
  }
  emStrongMask(e) {
    return e;
  }
  provideLexer() {
    return this.block ? x.lex : x.lexInline;
  }
  provideParser() {
    return this.block ? b2.parse : b2.parseInline;
  }
};
var B2 = class {
  defaults = L2();
  options = this.setOptions;
  parse = this.parseMarkdown(true);
  parseInline = this.parseMarkdown(false);
  Parser = b2;
  Renderer = P2;
  TextRenderer = $2;
  Lexer = x;
  Tokenizer = y;
  Hooks = S;
  constructor(...e) {
    this.use(...e);
  }
  walkTokens(e, t) {
    let n = [];
    for (let r of e)
      switch (n = n.concat(t.call(this, r)), r.type) {
        case "table": {
          let i = r;
          for (let s of i.header)
            n = n.concat(this.walkTokens(s.tokens, t));
          for (let s of i.rows)
            for (let o of s)
              n = n.concat(this.walkTokens(o.tokens, t));
          break;
        }
        case "list": {
          let i = r;
          n = n.concat(this.walkTokens(i.items, t));
          break;
        }
        default: {
          let i = r;
          this.defaults.extensions?.childTokens?.[i.type] ? this.defaults.extensions.childTokens[i.type].forEach((s) => {
            let o = i[s].flat(1 / 0);
            n = n.concat(this.walkTokens(o, t));
          }) : i.tokens && (n = n.concat(this.walkTokens(i.tokens, t)));
        }
      }
    return n;
  }
  use(...e) {
    let t = this.defaults.extensions || { renderers: {}, childTokens: {} };
    return e.forEach((n) => {
      let r = { ...n };
      if (r.async = this.defaults.async || r.async || false, n.extensions && (n.extensions.forEach((i) => {
        if (!i.name)
          throw new Error("extension name required");
        if ("renderer" in i) {
          let s = t.renderers[i.name];
          s ? t.renderers[i.name] = function(...o) {
            let a2 = i.renderer.apply(this, o);
            return a2 === false && (a2 = s.apply(this, o)), a2;
          } : t.renderers[i.name] = i.renderer;
        }
        if ("tokenizer" in i) {
          if (!i.level || i.level !== "block" && i.level !== "inline")
            throw new Error("extension level must be 'block' or 'inline'");
          let s = t[i.level];
          s ? s.unshift(i.tokenizer) : t[i.level] = [i.tokenizer], i.start && (i.level === "block" ? t.startBlock ? t.startBlock.push(i.start) : t.startBlock = [i.start] : i.level === "inline" && (t.startInline ? t.startInline.push(i.start) : t.startInline = [i.start]));
        }
        "childTokens" in i && i.childTokens && (t.childTokens[i.name] = i.childTokens);
      }), r.extensions = t), n.renderer) {
        let i = this.defaults.renderer || new P2(this.defaults);
        for (let s in n.renderer) {
          if (!(s in i))
            throw new Error(`renderer '${s}' does not exist`);
          if (["options", "parser"].includes(s))
            continue;
          let o = s, a2 = n.renderer[o], l = i[o];
          i[o] = (...c) => {
            let p = a2.apply(i, c);
            return p === false && (p = l.apply(i, c)), p || "";
          };
        }
        r.renderer = i;
      }
      if (n.tokenizer) {
        let i = this.defaults.tokenizer || new y(this.defaults);
        for (let s in n.tokenizer) {
          if (!(s in i))
            throw new Error(`tokenizer '${s}' does not exist`);
          if (["options", "rules", "lexer"].includes(s))
            continue;
          let o = s, a2 = n.tokenizer[o], l = i[o];
          i[o] = (...c) => {
            let p = a2.apply(i, c);
            return p === false && (p = l.apply(i, c)), p;
          };
        }
        r.tokenizer = i;
      }
      if (n.hooks) {
        let i = this.defaults.hooks || new S;
        for (let s in n.hooks) {
          if (!(s in i))
            throw new Error(`hook '${s}' does not exist`);
          if (["options", "block"].includes(s))
            continue;
          let o = s, a2 = n.hooks[o], l = i[o];
          S.passThroughHooks.has(s) ? i[o] = (c) => {
            if (this.defaults.async && S.passThroughHooksRespectAsync.has(s))
              return (async () => {
                let g2 = await a2.call(i, c);
                return l.call(i, g2);
              })();
            let p = a2.call(i, c);
            return l.call(i, p);
          } : i[o] = (...c) => {
            if (this.defaults.async)
              return (async () => {
                let g2 = await a2.apply(i, c);
                return g2 === false && (g2 = await l.apply(i, c)), g2;
              })();
            let p = a2.apply(i, c);
            return p === false && (p = l.apply(i, c)), p;
          };
        }
        r.hooks = i;
      }
      if (n.walkTokens) {
        let i = this.defaults.walkTokens, s = n.walkTokens;
        r.walkTokens = function(o) {
          let a2 = [];
          return a2.push(s.call(this, o)), i && (a2 = a2.concat(i.call(this, o))), a2;
        };
      }
      this.defaults = { ...this.defaults, ...r };
    }), this;
  }
  setOptions(e) {
    return this.defaults = { ...this.defaults, ...e }, this;
  }
  lexer(e, t) {
    return x.lex(e, t ?? this.defaults);
  }
  parser(e, t) {
    return b2.parse(e, t ?? this.defaults);
  }
  parseMarkdown(e) {
    return (n, r) => {
      let i = { ...r }, s = { ...this.defaults, ...i }, o = this.onError(!!s.silent, !!s.async);
      if (this.defaults.async === true && i.async === false)
        return o(new Error("marked(): The async option was set to true by an extension. Remove async: false from the parse options object to return a Promise."));
      if (typeof n > "u" || n === null)
        return o(new Error("marked(): input parameter is undefined or null"));
      if (typeof n != "string")
        return o(new Error("marked(): input parameter is of type " + Object.prototype.toString.call(n) + ", string expected"));
      if (s.hooks && (s.hooks.options = s, s.hooks.block = e), s.async)
        return (async () => {
          let a2 = s.hooks ? await s.hooks.preprocess(n) : n, c = await (s.hooks ? await s.hooks.provideLexer() : e ? x.lex : x.lexInline)(a2, s), p = s.hooks ? await s.hooks.processAllTokens(c) : c;
          s.walkTokens && await Promise.all(this.walkTokens(p, s.walkTokens));
          let d = await (s.hooks ? await s.hooks.provideParser() : e ? b2.parse : b2.parseInline)(p, s);
          return s.hooks ? await s.hooks.postprocess(d) : d;
        })().catch(o);
      try {
        s.hooks && (n = s.hooks.preprocess(n));
        let l = (s.hooks ? s.hooks.provideLexer() : e ? x.lex : x.lexInline)(n, s);
        s.hooks && (l = s.hooks.processAllTokens(l)), s.walkTokens && this.walkTokens(l, s.walkTokens);
        let p = (s.hooks ? s.hooks.provideParser() : e ? b2.parse : b2.parseInline)(l, s);
        return s.hooks && (p = s.hooks.postprocess(p)), p;
      } catch (a2) {
        return o(a2);
      }
    };
  }
  onError(e, t) {
    return (n) => {
      if (n.message += `
Please report this to https://github.com/markedjs/marked.`, e) {
        let r = "<p>An error occurred:</p><pre>" + w2(n.message + "", true) + "</pre>";
        return t ? Promise.resolve(r) : r;
      }
      if (t)
        return Promise.reject(n);
      throw n;
    };
  }
};
var _2 = new B2;
function k(u3, e) {
  return _2.parse(u3, e);
}
k.options = k.setOptions = function(u3) {
  return _2.setOptions(u3), k.defaults = _2.defaults, G2(k.defaults), k;
};
k.getDefaults = L2;
k.defaults = T2;
k.use = function(...u3) {
  return _2.use(...u3), k.defaults = _2.defaults, G2(k.defaults), k;
};
k.walkTokens = function(u3, e) {
  return _2.walkTokens(u3, e);
};
k.parseInline = _2.parseInline;
k.Parser = b2;
k.parser = b2.parse;
k.Renderer = P2;
k.TextRenderer = $2;
k.Lexer = x;
k.lexer = x.lex;
k.Tokenizer = y;
k.Hooks = S;
k.parse = k;
var Ht = k.options;
var Zt = k.setOptions;
var Gt = k.use;
var Nt = k.walkTokens;
var Ft = k.parseInline;
var Qt = b2.parse;
var Ut = x.lex;

// node_modules/tosijs-ui/dist/index.js
var Li = Object.defineProperty;
var Si = (e, t) => {
  for (var i in t)
    Li(e, i, { get: t[i], enumerable: true, configurable: true, set: (o) => t[i] = () => o });
};
var Ae3 = {};

class le3 extends B {
  static set conditions(e) {
    Object.assign(Ae3, e);
    for (let t of [...le3.instances])
      t.queueRender();
  }
  condition = "";
  not = false;
  static instances = new Set;
  constructor() {
    super();
    this.initAttributes("condition", "not");
  }
  connectedCallback() {
    super.connectedCallback(), le3.instances.add(this);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), le3.instances.delete(this);
  }
  render() {
    if (this.condition !== "" && (this.not ? Ae3[this.condition] !== true : Ae3[this.condition] === true))
      this.toggleAttribute("hidden", false);
    else
      this.toggleAttribute("hidden", true);
  }
}
var e1 = le3.elementCreator({ tag: "xin-ab" });
var xe2 = {};
function L3(e, t) {
  if (xe2[e] === undefined) {
    if (t !== undefined) {
      let o = globalThis[t];
      xe2[e] = Promise.resolve({ [t]: o });
    }
    let i = m.script({ src: e });
    document.head.append(i), xe2[e] = new Promise((o) => {
      i.onload = () => o(globalThis);
    });
  }
  return xe2[e];
}
var Ee3 = {};
function He3(e) {
  if (Ee3[e] === undefined) {
    let t = m.link({ rel: "stylesheet", type: "text/css", href: e });
    document.head.append(t), Ee3[e] = new Promise((i) => {
      t.onload = i;
    });
  }
  return Ee3[e];
}
var ae3 = { earth: '<svg class="color" viewBox="0 0 48 48"><g><g><g><path style="fill:#a3d9ff;fill-rule:evenodd;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M7,13.46 C5.10,16.52,4,20.13,4,24 C4,31.81,8.47,38.57,15,41.87 C15,41.87,15,31,15,31 C15,31,9,29,9,29 C9,29,9,19,9,19 C9,19,7,15,7,15 C7,15,7,13.46,7,13.46 z"/><path style="fill:#a3d9ff;fill-rule:evenodd;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M18.40,4.79 C20.18,4.28,22.06,4,24,4 C27.57,4,30.92,4.93,33.82,6.57 C33.82,6.57,29,13,29,13 C29,13,31,19,31,19 C31,19,37,21,37,21 C37,21,39,29,39,29 C39,29,37.35,38.89,37.35,38.89 C33.81,42.07,29.13,44,24,44 C21.03,44,18.22,43.35,15.69,42.20 C15.69,42.20,27,29,27,29 C27,29,27,25,27,25 C27,25,21,23,21,23 C21,23,15,19,15,19 C15,19,11,19,11,19 C11,19,11,13,11,13 C11,13,13,11,13,11 C13,11,15,15,15,15 C15,15,17,15,17,15 C17,15,17,9,17,9 C17,9,18.40,4.79,18.40,4.79 z"/><path style="fill:#274e42;fill-rule:evenodd;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M18.40,4.79 C18.40,4.79,17,9,17,9 C17,9,17,15,17,15 C17,15,15,15,15,15 C15,15,13,11,13,11 C13,11,11,13,11,13 C11,13,11,19,11,19 C11,19,15,19,15,19 C15,19,21,23,21,23 C21,23,27,25,27,25 C27,25,27,29,27,29 C27,29,15.69,42.20,15.69,42.20 C15.46,42.09,15.23,41.98,15,41.87 C15,41.87,15,31,15,31 C15,31,9,29,9,29 C9,29,9,19,9,19 C9,19,7,15,7,15 C7,15,7,13.46,7,13.46 C9.57,9.32,13.62,6.19,18.40,4.79 z"/><path style="fill:#274e42;fill-rule:evenodd;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M33.82,6.57 C33.82,6.57,29,13,29,13 C29,13,31,19,31,19 C31,19,37,21,37,21 C37,21,39,29,39,29 C39,29,37.35,38.89,37.35,38.89 C41.43,35.23,44,29.91,44,24 C44,16.52,39.90,10.00,33.82,6.57 z"/></g></g></g></svg> ', blueprint: '<svg class="color" viewBox="0 0 24 24"><g><path style="fill:#9e9e9e;fill-rule:nonzero;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:1;" d="M10.5,14.5 C10.5,14.5,7.5,15.5,7.5,17.5 C7.5,19.5,10.5,19.5,10.5,19.5"/><path style="fill:#9e9e9e;fill-rule:nonzero;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:1;" d="M18.50,14.5 C18.50,14.5,21.50,15.5,21.50,17.5 C21.50,19.5,18.50,19.5,18.50,19.5"/><path style="fill:#ffffff;fill-rule:evenodd;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:1;" d="M7,5.09 C7,3.94,7.90,3,9,3 C9,3,20,3,20,3 C21.10,3,22,3.94,22,5.09 C22,5.09,22,12.41,22,12.41 C22,13.56,21.10,14.5,20,14.5 C20,14.5,9,14.5,9,14.5 C7.90,14.5,7,13.56,7,12.41 C7,12.41,7,5.09,7,5.09 z"/><path style="fill:#ffffff;fill-rule:nonzero;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:1;" d="M14.5,5.5 C14.5,5.5,14.5,11.5,14.5,11.5"/><path style="fill:#ffffff;fill-rule:nonzero;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:1;" d="M16.5,7.5 C16.5,7.5,16.5,8.5,16.5,8.5"/><path style="fill:#ffffff;fill-rule:nonzero;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:1;" d="M12.5,7.5 C12.5,7.5,12.5,8.5,12.5,8.5"/><g/><path style="fill:none;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:1;" d="M18.5,21.5 C18.5,21.5,17.5,20.5,17.5,20.5 C17.5,20.5,16.5,21.5,16.5,21.5"/><path style="fill:none;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:1;" d="M12.5,21.5 C12.5,21.5,11.5,20.5,11.5,20.5 C11.5,20.5,10.5,21.5,10.5,21.5"/><path style="fill:#e4e4e4;fill-rule:evenodd;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:1;" d="M10.5,14.5 C10.5,14.5,18.5,14.5,18.5,14.5 C18.5,14.5,18.5,19.5,18.5,19.5 C18.5,19.5,10.5,19.5,10.5,19.5 C10.5,19.5,10.5,14.5,10.5,14.5 z"/><g><g><path style="fill:#5e78ca;fill-rule:nonzero;stroke:#f2f2f2;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:1;" d="M14,16.5 C14,16.5,16,16.5,16,16.5 C16,16.5,14.53,19.5,14.53,19.5"/><path style="fill:#5e78ca;fill-rule:evenodd;stroke:none;" d="M3.59,8.5 C3.59,8.5,12.59,8.5,12.59,8.5 C12.59,8.5,14.53,19.5,14.53,19.5 C14.53,19.5,5.53,19.5,5.53,19.5 C5.53,19.5,3.59,8.5,3.59,8.5 z"/><path style="fill:#5e78ca;fill-rule:nonzero;stroke:#f2f2f2;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:1;" d="M12.59,8.5 C12.59,8.5,11.12,11.5,11.12,11.5 C11.12,11.5,2.12,11.5,2.12,11.5 C2.12,11.5,3.59,8.5,3.59,8.5"/><path style="fill:#5e78ca;fill-rule:nonzero;stroke:#f2f2f2;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:1;" d="M12.59,8.5 C12.59,8.5,14.53,19.5,14.53,19.5"/><path style="fill:#5e78ca;fill-rule:nonzero;stroke:#f2f2f2;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:1;" d="M4.12,11.5 C4.12,11.5,5.53,19.5,5.53,19.5"/></g><path style="fill:#9e9e9e;fill-rule:nonzero;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:1;" d="M9.24,12.5 C10.75,12.5,12.20,13.73,12.46,15.24 C12.46,15.24,12.46,15.24,12.46,15.24 C12.68,16.49,11.85,17.5,10.60,17.5 C10.60,17.5,10.55,17.5,10.55,17.5 C10.17,17.5,9.92,17.81,9.98,18.19 C9.98,18.19,9.98,18.19,9.98,18.19 C10.21,19.47,9.36,20.5,8.08,20.5 C8.08,20.5,6.39,20.5,6.39,20.5 C5.10,20.5,3.87,19.45,3.64,18.16 C3.64,18.16,3.12,15.21,3.12,15.21 C2.86,13.71,3.86,12.5,5.35,12.5 C5.35,12.5,9.24,12.5,9.24,12.5 z"/></g></g></svg> ', tosiXr: '<svg class="color" viewBox="0 0 24 24"><g><path style="fill:#9e9e9e;fill-rule:nonzero;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:1;" d="M8.00,14.25 C8.00,14.25,5.00,15.25,5.00,17.25 C5.00,19.25,8.00,19.25,8.00,19.25"/><path style="fill:#9e9e9e;fill-rule:nonzero;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:1;" d="M16.00,14.25 C16.00,14.25,19.00,15.25,19.00,17.25 C19.00,19.25,16.00,19.25,16.00,19.25"/><path style="fill:#ffffff;fill-rule:evenodd;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:1;" d="M4.50,4.85 C4.50,3.69,5.40,2.75,6.50,2.75 C6.50,2.75,17.50,2.75,17.50,2.75 C18.61,2.75,19.50,3.69,19.50,4.85 C19.50,4.85,19.50,12.16,19.50,12.16 C19.50,13.32,18.61,14.25,17.50,14.25 C17.50,14.25,6.50,14.25,6.50,14.25 C5.40,14.25,4.50,13.32,4.50,12.16 C4.50,12.16,4.50,4.85,4.50,4.85 z"/><path style="fill:#ffffff;fill-rule:nonzero;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:1;" d="M12.00,5.25 C12.00,5.25,12.00,11.25,12.00,11.25"/><path style="fill:#ffffff;fill-rule:nonzero;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:1;" d="M14.00,7.25 C14.00,7.25,14.00,8.25,14.00,8.25"/><path style="fill:#ffffff;fill-rule:nonzero;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:1;" d="M10.00,7.25 C10.00,7.25,10.00,8.25,10.00,8.25"/><path style="fill:none;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:1;" d="M16.00,21.25 C16.00,21.25,15.00,20.25,15.00,20.25 C15.00,20.25,14.00,21.25,14.00,21.25"/><path style="fill:none;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:1;" d="M10.00,21.25 C10.00,21.25,9.00,20.25,9.00,20.25 C9.00,20.25,8.00,21.25,8.00,21.25"/><path style="fill:#e4e4e4;fill-rule:evenodd;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:1;" d="M8.00,14.25 C8.00,14.25,16.00,14.25,16.00,14.25 C16.00,14.25,16.00,19.25,16.00,19.25 C16.00,19.25,8.00,19.25,8.00,19.25 C8.00,19.25,8.00,14.25,8.00,14.25 z"/><path style="fill:#ff7bac;fill-opacity:0.75;fill-rule:evenodd;stroke:#000000;stroke-linecap:butt;stroke-linejoin:miter;stroke-miterlimit:10;stroke-width:1;" d="M12.00,4.00 C12.00,4,11.99,4,11.99,4 C6.19,4,3,4.73,3,8.50 C3,11.39,4.66,13.00,7.27,13 C9.88,13.00,10.68,11.13,11.99,11.13 C11.99,11.13,12.00,11.13,12,11.13 C12.00,11.13,12.01,11.13,12.01,11.13 C13.32,11.13,14.12,13.00,16.73,13 C19.34,13.00,21,11.39,21,8.50 C21,4.73,17.81,4,12.01,4 C12.01,4,12.00,4,12.00,4.00 C12.00,4.00,12.00,4.00,12.00,4.00 z"/></g></svg> ', cmy: '<svg class="color filled" viewBox="0 0 24 24"><g><g><path style="fill:#00ff00;fill-rule:evenodd;" d="M12.00,10.88 C10.90,10.01,9.51,9.5,8.00,9.5 C7.22,9.5,6.47,9.64,5.78,9.89 C6.37,11.85,7.87,13.42,9.78,14.11 C10.17,12.81,10.96,11.69,12.00,10.88 z"/><path style="fill:#0000ff;fill-rule:evenodd;" d="M12.00,10.88 C13.10,10.01,14.49,9.5,16,9.5 C16.78,9.5,17.53,9.64,18.22,9.89 C17.63,11.85,16.13,13.42,14.22,14.11 C13.83,12.81,13.04,11.69,12.00,10.88 C12.00,10.88,12.00,10.88,12.00,10.88 z"/><path style="fill:#000000;fill-rule:evenodd;" d="M9.78,14.11 C10.17,12.81,10.96,11.69,12.00,10.88 C13.04,11.69,13.83,12.81,14.22,14.11 C13.53,14.36,12.78,14.5,12,14.5 C11.22,14.5,10.47,14.36,9.78,14.11 C9.78,14.11,9.78,14.11,9.78,14.11 z"/><path style="fill:#ff0000;fill-rule:evenodd;" d="M9.78,14.11 C9.60,14.71,9.5,15.34,9.5,16 C9.5,18.08,10.48,19.93,12.00,21.12 C13.52,19.93,14.50,18.08,14.50,16 C14.50,15.34,14.40,14.71,14.22,14.11 C13.53,14.36,12.78,14.5,12,14.5 C11.22,14.5,10.47,14.36,9.78,14.11 C9.78,14.11,9.78,14.11,9.78,14.11 z"/><path style="fill:#02fefe;fill-rule:evenodd;" d="M5.78,9.89 C5.60,9.29,5.5,8.66,5.5,8 C5.5,4.41,8.41,1.5,12,1.5 C15.59,1.5,18.5,4.41,18.5,8 C18.5,8.66,18.40,9.29,18.22,9.89 C17.53,9.64,16.78,9.5,16,9.5 C14.49,9.5,13.10,10.01,12.00,10.88 C10.90,10.01,9.51,9.5,8.00,9.5 C7.22,9.5,6.47,9.64,5.78,9.89 C5.78,9.89,5.78,9.89,5.78,9.89 z"/><path style="fill:#fffe00;fill-rule:evenodd;" d="M5.78,9.89 C3.28,10.80,1.50,13.19,1.50,16 C1.50,19.59,4.41,22.5,8.00,22.5 C9.51,22.5,10.90,21.99,12.00,21.12 C10.48,19.93,9.5,18.08,9.5,16 C9.5,15.34,9.60,14.71,9.78,14.11 C7.87,13.42,6.37,11.85,5.78,9.89 C5.78,9.89,5.78,9.89,5.78,9.89 z"/><path style="fill:#ff00ff;fill-rule:evenodd;" d="M18.22,9.89 C20.72,10.80,22.5,13.19,22.5,16 C22.5,19.59,19.59,22.5,16,22.5 C14.49,22.5,13.10,21.99,12.00,21.12 C13.52,19.93,14.50,18.08,14.50,16 C14.50,15.34,14.40,14.71,14.22,14.11 C16.13,13.42,17.63,11.85,18.22,9.89 z"/></g></g></svg> ', rgb: '<svg class="color filled" viewBox="0 0 24 24"><g><g><path style="fill:#ff00ff;fill-rule:evenodd;" d="M12.00,10.88 C10.90,10.01,9.51,9.5,8.00,9.5 C7.22,9.5,6.47,9.64,5.78,9.89 C6.37,11.85,7.87,13.42,9.78,14.11 C10.17,12.81,10.96,11.69,12.00,10.88 z"/><path style="fill:#ffff00;fill-rule:evenodd;" d="M12.00,10.88 C13.10,10.01,14.49,9.5,16,9.5 C16.78,9.5,17.53,9.64,18.22,9.89 C17.63,11.85,16.13,13.42,14.22,14.11 C13.83,12.81,13.04,11.69,12.00,10.88 C12.00,10.88,12.00,10.88,12.00,10.88 z"/><path style="fill:#ffffff;fill-rule:evenodd;" d="M9.78,14.11 C10.17,12.81,10.96,11.69,12.00,10.88 C13.04,11.69,13.83,12.81,14.22,14.11 C13.53,14.36,12.78,14.5,12,14.5 C11.22,14.5,10.47,14.36,9.78,14.11 C9.78,14.11,9.78,14.11,9.78,14.11 z"/><path style="fill:#00ffff;fill-rule:evenodd;" d="M9.78,14.11 C9.60,14.71,9.5,15.34,9.5,16 C9.5,18.08,10.48,19.93,12.00,21.12 C13.52,19.93,14.50,18.08,14.50,16 C14.50,15.34,14.40,14.71,14.22,14.11 C13.53,14.36,12.78,14.5,12,14.5 C11.22,14.5,10.47,14.36,9.78,14.11 C9.78,14.11,9.78,14.11,9.78,14.11 z"/><path style="fill:#ff0000;fill-rule:evenodd;" d="M5.78,9.89 C5.60,9.29,5.5,8.66,5.5,8 C5.5,4.41,8.41,1.5,12,1.5 C15.59,1.5,18.5,4.41,18.5,8 C18.5,8.66,18.40,9.29,18.22,9.89 C17.53,9.64,16.78,9.5,16,9.5 C14.49,9.5,13.10,10.01,12.00,10.88 C10.90,10.01,9.51,9.5,8.00,9.5 C7.22,9.5,6.47,9.64,5.78,9.89 C5.78,9.89,5.78,9.89,5.78,9.89 z"/><path style="fill:#0000ff;fill-rule:evenodd;" d="M5.78,9.89 C3.28,10.80,1.50,13.19,1.50,16 C1.50,19.59,4.41,22.5,8.00,22.5 C9.51,22.5,10.90,21.99,12.00,21.12 C10.48,19.93,9.5,18.08,9.5,16 C9.5,15.34,9.60,14.71,9.78,14.11 C7.87,13.42,6.37,11.85,5.78,9.89 C5.78,9.89,5.78,9.89,5.78,9.89 z"/><path style="fill:#00ff00;fill-rule:evenodd;" d="M18.22,9.89 C20.72,10.80,22.5,13.19,22.5,16 C22.5,19.59,19.59,22.5,16,22.5 C14.49,22.5,13.10,21.99,12.00,21.12 C13.52,19.93,14.50,18.08,14.50,16 C14.50,15.34,14.40,14.71,14.22,14.11 C16.13,13.42,17.63,11.85,18.22,9.89 z"/></g></g></svg> ', xrColor: '<svg class="color filled" viewBox="0 0 40 24"><g><g><g><path style="fill:#000000;fill-rule:evenodd;" d="M20.00,2.00 C19.99,2.00,19.98,2,19.98,2 C8.39,2,2,3.61,2,12.00 C2,18.41,5.32,22.00,10.54,22 C15.77,22.00,17.37,17.85,19.98,17.85 C19.98,17.85,19.99,17.85,20,17.85 C20.01,17.85,20.02,17.85,20.02,17.85 C22.63,17.85,24.23,22.00,29.46,22 C34.68,22.00,38,18.41,38,12.00 C38,3.61,31.61,2,20.02,2 C20.02,2,20.01,2.00,20.00,2.00 C20.00,2.00,20.00,2.00,20.00,2.00 z"/></g><path style="fill:#fbed21;fill-rule:evenodd;" d="M12.20,19.84 C15.79,19.39,17.07,16.46,19.07,16.46 C19.07,16.46,19.08,16.46,19.09,16.46 C19.09,16.46,19.10,16.46,19.11,16.46 C19.44,16.46,19.75,16.54,20.06,16.68 C20.37,16.54,20.68,16.46,21.01,16.46 C21.02,16.46,21.02,16.46,21.03,16.46 C21.04,16.46,21.04,16.46,21.05,16.46 C23.05,16.46,24.33,19.39,27.92,19.84 C31.66,19.40,33.98,16.50,33.98,11.62 C33.98,4.91,29.04,3.44,20.06,3.35 C11.07,3.44,6.14,4.91,6.14,11.62 C6.14,16.50,8.46,19.40,12.20,19.84 z"/><path style="fill:#8cc63f;fill-rule:evenodd;" d="M12.20,19.84 C12.52,19.87,12.86,19.89,13.21,19.89 C16.86,19.89,18.37,17.43,20.06,16.68 C19.75,16.54,19.44,16.46,19.11,16.46 C19.10,16.46,19.09,16.46,19.09,16.46 C19.08,16.46,19.07,16.46,19.07,16.46 C17.07,16.46,15.79,19.39,12.20,19.84 z"/><path style="fill:#8cc63f;fill-rule:evenodd;" d="M20.06,3.35 C20.37,3.35,20.69,3.35,21.01,3.35 C21.02,3.35,21.02,3.35,21.03,3.35 C21.03,3.35,21.03,3.35,21.03,3.35 C21.04,3.35,21.04,3.35,21.05,3.35 C30.64,3.35,35.92,4.68,35.92,11.62 C35.92,16.92,33.18,19.89,28.86,19.89 C28.53,19.89,28.22,19.87,27.92,19.84 C31.66,19.40,33.98,16.50,33.98,11.62 C33.98,4.91,29.04,3.44,20.06,3.35 C20.06,3.35,20.06,3.35,20.06,3.35 z"/><path style="fill:#ff1c23;fill-rule:evenodd;" d="M20.06,16.68 C21.74,17.43,23.25,19.89,26.91,19.89 C27.26,19.89,27.59,19.87,27.92,19.84 C24.33,19.39,23.05,16.46,21.05,16.46 C21.04,16.46,21.04,16.46,21.03,16.46 C21.02,16.46,21.02,16.46,21.01,16.46 C20.68,16.46,20.37,16.54,20.06,16.68 z"/><path style="fill:#ff1c23;fill-rule:evenodd;" d="M12.20,19.84 C11.90,19.87,11.59,19.89,11.26,19.89 C6.94,19.89,4.19,16.92,4.19,11.62 C4.19,4.68,9.48,3.35,19.07,3.35 C19.07,3.35,19.08,3.35,19.09,3.35 C19.09,3.35,19.09,3.35,19.09,3.35 C19.09,3.35,19.1,3.35,19.11,3.35 C19.43,3.35,19.75,3.35,20.06,3.35 C11.07,3.44,6.14,4.91,6.14,11.62 C6.14,16.50,8.46,19.40,12.20,19.84 z"/></g><g><path style="fill:#8cc63e;fill-rule:nonzero;" d="M22.55,8.63 C22.55,9.05,22.55,9.46,22.55,9.88 C22.54,10.25,22.85,10.56,23.20,10.55 C23.54,10.56,23.85,10.25,23.85,9.88 C23.85,9.46,23.85,9.05,23.85,8.63 C23.85,8.26,23.54,7.95,23.20,7.96 C22.85,7.95,22.54,8.26,22.55,8.63 z"/><path style="fill:#8cc63e;fill-rule:nonzero;" d="M17.32,8.63 C17.32,9.05,17.32,9.46,17.32,9.88 C17.31,10.25,17.62,10.56,17.97,10.55 C18.31,10.56,18.62,10.25,18.62,9.88 C18.62,9.46,18.62,9.05,18.62,8.63 C18.62,8.26,18.31,7.95,17.97,7.96 C17.62,7.95,17.31,8.26,17.32,8.63 z"/><path style="fill:#8cc63e;fill-rule:nonzero;" d="M19.99,4.39 C19.99,8.09,19.99,11.80,19.99,15.50 C19.99,15.87,20.30,16.18,20.64,16.17 C20.99,16.18,21.30,15.87,21.29,15.50 C21.29,11.80,21.29,8.09,21.29,4.39 C21.30,4.02,20.99,3.71,20.64,3.72 C20.30,3.71,19.99,4.02,19.99,4.39 z"/><path style="fill:#fe1a22;fill-rule:nonzero;" d="M21.43,8.63 C21.43,9.05,21.43,9.46,21.43,9.88 C21.42,10.25,21.73,10.56,22.08,10.55 C22.42,10.56,22.73,10.25,22.73,9.88 C22.73,9.46,22.73,9.05,22.73,8.63 C22.73,8.26,22.42,7.95,22.08,7.96 C21.73,7.95,21.42,8.26,21.43,8.63 z"/><path style="fill:#fe1a22;fill-rule:nonzero;" d="M16.20,8.63 C16.20,9.05,16.20,9.46,16.20,9.88 C16.19,10.25,16.50,10.56,16.85,10.55 C17.19,10.56,17.50,10.25,17.50,9.88 C17.50,9.46,17.50,9.05,17.50,8.63 C17.50,8.26,17.19,7.95,16.85,7.96 C16.50,7.95,16.19,8.26,16.20,8.63 z"/><path style="fill:#fe1a22;fill-rule:nonzero;" d="M18.87,4.39 C18.87,8.09,18.87,11.80,18.87,15.50 C18.87,15.87,19.18,16.18,19.52,16.17 C19.86,16.18,20.18,15.87,20.17,15.50 C20.17,11.80,20.17,8.09,20.17,4.39 C20.18,4.02,19.86,3.71,19.52,3.72 C19.18,3.71,18.87,4.02,18.87,4.39 z"/><path style="fill:#000000;fill-rule:nonzero;" d="M21.97,8.63 C21.97,9.05,21.97,9.46,21.97,9.88 C21.97,10.25,22.28,10.56,22.62,10.55 C22.97,10.56,23.28,10.25,23.27,9.88 C23.27,9.46,23.27,9.05,23.27,8.63 C23.28,8.26,22.97,7.95,22.62,7.96 C22.28,7.95,21.97,8.26,21.97,8.63 z"/><path style="fill:#000000;fill-rule:nonzero;" d="M16.74,8.63 C16.74,9.05,16.74,9.46,16.74,9.88 C16.74,10.25,17.05,10.56,17.39,10.55 C17.74,10.56,18.05,10.25,18.04,9.88 C18.04,9.46,18.04,9.05,18.04,8.63 C18.05,8.26,17.74,7.95,17.39,7.96 C17.05,7.95,16.74,8.26,16.74,8.63 z"/><path style="fill:#000000;fill-rule:nonzero;" d="M19.41,4.39 C19.41,8.09,19.41,11.80,19.41,15.50 C19.41,15.87,19.72,16.18,20.07,16.17 C20.41,16.18,20.72,15.87,20.72,15.50 C20.72,11.80,20.72,8.09,20.72,4.39 C20.72,4.02,20.41,3.71,20.07,3.72 C19.72,3.71,19.41,4.02,19.41,4.39 z"/></g></g></svg> ', tosiUi: '<svg class="color" viewBox="0 0 48 48"><g><g><g><path style="fill:#ffffff;fill-rule:evenodd;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M3,33 C3,31.90,3.90,31,5,31 C5,31,43,31,43,31 C44.10,31,45,31.90,45,33 C45,33,45,43,45,43 C45,44.10,44.10,45,43,45 C43,45,5,45,5,45 C3.90,45,3,44.10,3,43 C3,43,3,33,3,33 z"/><g><path style="fill:#ffffff;fill-rule:evenodd;stroke:#ed247b;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M7,35 C7,35,7,36.34,7,38 C7,39.66,8.34,41,10,41 C11.66,41,13,39.66,13,38 C13,36.34,13,35,13,35"/><path style="fill:#ffffff;fill-rule:nonzero;stroke:#ed247b;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M17,35 C17,35,17,41,17,41"/></g><g><path style="fill:#ed247b;fill-rule:evenodd;stroke:none;" d="M38,33 C40.76,33,43,35.24,43,38 C43,40.76,40.76,43,38,43 C35.24,43,33,40.76,33,38 C33,35.24,35.24,33,38,33 z"/><path style="fill:#ed247b;fill-rule:nonzero;stroke:#ffffff;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M40,36 C40,36,36,40,36,40"/><path style="fill:#ed247b;fill-rule:nonzero;stroke:#ffffff;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M36,36 C36,36,40,40,40,40"/></g></g><g><path style="fill:#9e9e9e;fill-rule:nonzero;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M15.97,21.01 C15.97,21.01,9.97,23.01,9.97,27.01 C9.97,31.01,15.97,31.01,15.97,31.01"/><path style="fill:#9e9e9e;fill-rule:nonzero;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M31.97,21.01 C31.97,21.01,37.97,23.01,37.97,27.01 C37.97,31.01,31.97,31.01,31.97,31.01"/><path style="fill:none;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M31,33 C31,33,29.49,31,29.49,31 C29.49,31,27.97,33,27.97,33"/><path style="fill:none;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M19.97,33 C19.97,33,17.97,31,17.97,31 C17.97,31,15.97,33,15.97,33"/><path style="fill:#e4e4e4;fill-rule:evenodd;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M15.97,21 C15.97,21,31.97,21,31.97,21 C31.97,21,31.97,31,31.97,31 C31.97,31,15.97,31,15.97,31 C15.97,31,15.97,21,15.97,21 z"/><path style="fill:#ffffff;fill-rule:evenodd;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M9,7.18 C9,4.87,10.79,3,13.00,3 C13.00,3,35.02,3,35.02,3 C37.23,3,39.03,4.87,39.03,7.18 C39.03,7.18,39.03,21.82,39.03,21.82 C39.03,24.13,37.23,26,35.02,26 C35.02,26,13.00,26,13.00,26 C10.79,26,9,24.13,9,21.82 C9,21.82,9,7.18,9,7.18 z"/><path style="fill:#ffffff;fill-rule:nonzero;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M24,11 C24,11,24,23,24,23"/><path style="fill:#ffffff;fill-rule:nonzero;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M28,15 C28,15,28,17,28,17"/><path style="fill:#ffffff;fill-rule:nonzero;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M20,15 C20,15,20,17,20,17"/></g></g></g></svg> ', tosiFavicon: '<svg class="color" viewBox="0 0 48 48"><g><g><path style="fill:#ed247b;fill-rule:evenodd;stroke:none;" d="M1,9 C1,4.58,4.58,1,9,1 C9,1,39,1,39,1 C43.42,1,47,4.58,47,9 C47,9,47,39,47,39 C47,43.42,43.42,47,39,47 C39,47,9,47,9,47 C4.58,47,1,43.42,1,39 C1,39,1,9,1,9 z"/><g><path style="fill:#9e9e9e;fill-rule:nonzero;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M16,29 C16,29,10,31,10,35 C10,39,16,39,16,39"/><path style="fill:#9e9e9e;fill-rule:nonzero;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M32.00,29 C32.00,29,38.00,31,38.00,35 C38.00,39,32.00,39,32.00,39"/><path style="fill:#ffffff;fill-rule:evenodd;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M9,10.18 C9,7.87,10.79,6,13,6 C13,6,35,6,35,6 C37.21,6,39,7.87,39,10.18 C39,10.18,39,24.82,39,24.82 C39,27.13,37.21,29,35,29 C35,29,13,29,13,29 C10.79,29,9,27.13,9,24.82 C9,24.82,9,10.18,9,10.18 z"/><path style="fill:#ffffff;fill-rule:nonzero;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M24,11 C24,11,24,23,24,23"/><path style="fill:#ffffff;fill-rule:nonzero;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M28,15 C28,15,28,17,28,17"/><path style="fill:#ffffff;fill-rule:nonzero;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M20,15 C20,15,20,17,20,17"/><path style="fill:none;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M32,43 C32,43,30,41,30,41 C30,41,28,43,28,43"/><path style="fill:none;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M20,43 C20,43,18,41,18,41 C18,41,16,43,16,43"/><path style="fill:#e4e4e4;fill-rule:evenodd;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M16,29 C16,29,32,29,32,29 C32,29,32,39,32,39 C32,39,16,39,16,39 C16,39,16,29,16,29 z"/></g></g></g></svg> ', tosiPlatform: '<svg class="color" viewBox="0 0 48 48"><g><g><g><path style="fill:#3ea9f5;fill-rule:evenodd;stroke:none;" d="M23.97,47 C23.97,47,39,47,39,47 C43.42,47,47,43.42,47,39 C47,39,47,9,47,9 C47,4.58,43.42,1,39,1 C39,1,9,1,9,1 C4.58,1,1,4.58,1,9 C1,9,1,39,1,39 C1,41.64,2.28,43.98,4.25,45.44 C4.09,44.82,4,44.17,4,43.5 C4,39.36,7.36,36,11.5,36 C15.14,36,18.18,38.60,18.86,42.05 C19.07,42.02,19.28,42,19.5,42 C21.99,42,24,44.01,24,46.5 C24,46.67,23.99,46.84,23.97,47 z"/><path style="fill:#ffffff;fill-rule:evenodd;stroke:none;" d="M4.25,45.44 C4.09,44.82,4,44.17,4,43.5 C4,39.36,7.36,36,11.5,36 C15.14,36,18.18,38.60,18.86,42.05 C19.07,42.02,19.28,42,19.5,42 C21.99,42,24,44.01,24,46.5 C24,46.67,23.99,46.84,23.97,47 C23.97,47,9,47,9,47 C7.22,47,5.58,46.42,4.25,45.44 z"/></g><path style="fill:none;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M35,35 C35,35,32.17,35,32.17,35 C32.17,35,32.17,37.83,32.17,37.83"/><path style="fill:none;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M31,39 C31,39,28.17,39,28.17,39 C28.17,39,28.17,41.83,28.17,41.83"/><path style="fill:#9e9e9e;fill-rule:nonzero;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M7.48,16 C4.45,16,2,18.45,2,21.48 C2,21.48,2,21.48,2,21.48 C2,23.98,4.02,26,6.52,26 C6.52,26,6.62,26,6.62,26 C7.38,26,8,26.62,8,27.38 C8,27.38,8,27.38,8,27.38 C8,29.93,10.07,32,12.62,32 C12.62,32,16,32,16,32 C18.58,32,20.68,29.91,20.68,27.32 C20.68,27.32,20.68,21.42,20.68,21.42 C20.68,18.43,18.25,16,15.26,16 C15.26,16,7.48,16,7.48,16 z"/><path style="fill:#e4e4e4;fill-rule:evenodd;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M17,29 C17,29,33,29,33,29 C33,29,33,29,33,29 C33,34.52,28.52,39,23,39 C23,39,23,39,23,39 C19.69,39,17,36.31,17,33 C17,33,17,29,17,29 z"/><path style="fill:#9e9e9e;fill-rule:nonzero;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M40.52,16 C43.55,16,46,18.45,46,21.48 C46,21.48,46,21.48,46,21.48 C46,23.98,43.98,26,41.48,26 C41.48,26,41.38,26,41.38,26 C40.62,26,40,26.62,40,27.38 C40,27.38,40,27.38,40,27.38 C40,29.93,37.93,32,35.38,32 C35.38,32,32,32,32,32 C29.42,32,27.32,29.91,27.32,27.32 C27.32,27.32,27.32,21.42,27.32,21.42 C27.32,18.43,29.75,16,32.74,16 C32.74,16,40.52,16,40.52,16 z"/><g><path style="fill:#ffffff;fill-rule:evenodd;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M6,10.18 C6,7.87,7.79,6,10,6 C10,6,32,6,32,6 C34.21,6,36,7.87,36,10.18 C36,10.18,36,24.82,36,24.82 C36,27.13,34.21,29,32,29 C32,29,10,29,10,29 C7.79,29,6,27.13,6,24.82 C6,24.82,6,10.18,6,10.18 z"/><path style="fill:#ffffff;fill-rule:nonzero;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M21,11 C21,11,21,23,21,23"/><path style="fill:#ffffff;fill-rule:nonzero;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M25,15 C25,15,25,17,25,17"/><path style="fill:#ffffff;fill-rule:nonzero;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M17,15 C17,15,17,17,17,17"/></g></g></g></svg> ', tosi: '<svg class="color" viewBox="0 0 48 48"><g><path style="fill:#9e9e9e;fill-rule:nonzero;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M38.35,31.70 C39.78,34.37,38.78,37.69,36.11,39.13 C36.11,39.13,36.11,39.13,36.11,39.13 C33.92,40.31,31.18,39.48,29.99,37.29 C29.99,37.29,29.95,37.20,29.95,37.20 C29.58,36.53,28.75,36.27,28.08,36.64 C28.08,36.64,28.08,36.64,28.08,36.64 C25.83,37.84,23.03,37.00,21.82,34.76 C21.82,34.76,20.22,31.78,20.22,31.78 C18.99,29.50,19.85,26.67,22.12,25.44 C22.12,25.44,27.32,22.65,27.32,22.65 C29.96,21.23,33.24,22.22,34.66,24.85 C34.66,24.85,38.35,31.70,38.35,31.70 z"/><path style="fill:#9e9e9e;fill-rule:nonzero;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M10.65,31.70 C9.22,34.37,10.22,37.69,12.89,39.13 C12.89,39.13,12.89,39.13,12.89,39.13 C15.08,40.31,17.82,39.48,19.01,37.29 C19.01,37.29,19.05,37.20,19.05,37.20 C19.42,36.53,20.25,36.27,20.92,36.64 C20.92,36.64,20.92,36.64,20.92,36.64 C23.17,37.84,25.97,37.00,27.18,34.76 C27.18,34.76,28.78,31.78,28.78,31.78 C30.01,29.50,29.15,26.67,26.88,25.44 C26.88,25.44,21.68,22.65,21.68,22.65 C19.04,21.23,15.76,22.22,14.34,24.85 C14.34,24.85,10.65,31.70,10.65,31.70 z"/><path style="fill:none;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M32.5,43 C32.5,43,30.5,41,30.5,41 C30.5,41,28.5,43,28.5,43"/><path style="fill:none;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M20.5,43 C20.5,43,18.5,41,18.5,41 C18.5,41,16.5,43,16.5,43"/><path style="fill:#e4e4e4;fill-rule:evenodd;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M16.5,29 C16.5,29,32.5,29,32.5,29 C32.5,29,32.5,36,32.5,36 C32.5,37.66,31.16,39,29.5,39 C29.5,39,19.5,39,19.5,39 C17.84,39,16.5,37.66,16.5,36 C16.5,36,16.5,29,16.5,29 z"/><g><path style="fill:#ffffff;fill-rule:evenodd;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M9.5,10.18 C9.5,7.87,11.29,6,13.5,6 C13.5,6,35.5,6,35.5,6 C37.71,6,39.5,7.87,39.5,10.18 C39.5,10.18,39.5,24.82,39.5,24.82 C39.5,27.13,37.71,29,35.5,29 C35.5,29,13.5,29,13.5,29 C11.29,29,9.5,27.13,9.5,24.82 C9.5,24.82,9.5,10.18,9.5,10.18 z"/><g><path style="fill:#ffffff;fill-rule:nonzero;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M24.5,11 C24.5,11,24.5,23,24.5,23"/><path style="fill:#ffffff;fill-rule:nonzero;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M28.5,15 C28.5,15,28.5,17,28.5,17"/><path style="fill:#ffffff;fill-rule:nonzero;stroke:#000000;stroke-linecap:round;stroke-linejoin:round;stroke-miterlimit:10;stroke-width:2;" d="M20.5,15 C20.5,15,20.5,17,20.5,17"/></g></g></g></svg> ', sortDescending: '<svg class="stroked" viewBox="0 0 24 24"><g><path d="M16.5,14.5 C16.5,14.5,7.5,14.5,7.5,14.5"/><path d="M14.5,18.5 C14.5,18.5,9.5,18.5,9.5,18.5"/><path d="M18.5,10.5 C18.5,10.5,5.5,10.5,5.5,10.5"/><path d="M20.5,6.5 C20.5,6.5,3.5,6.5,3.5,6.5"/></g></svg> ', columns: '<svg class="stroked" viewBox="0 0 24 24"><path d="M12 3h7a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-7m0-18H5a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h7m0-18v18"></path></svg>', underline: '<svg class="stroked" viewBox="0 0 24 24"><path d="M6 3v7a6 6 0 0 0 6 6 6 6 0 0 0 6-6V3"></path><line x1="4" y1="21" x2="20" y2="21"></line></svg>', grid: '<svg class="stroked" viewBox="0 0 24 24"><rect x="3" y="3" width="7" height="7"></rect><rect x="14" y="3" width="7" height="7"></rect><rect x="14" y="14" width="7" height="7"></rect><rect x="3" y="14" width="7" height="7"></rect></svg>', triangle: '<svg class="stroked" viewBox="0 0 24 24"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path></svg>', search: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line></svg>', volume2: '<svg class="stroked" viewBox="0 0 24 24"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M19.07 4.93a10 10 0 0 1 0 14.14M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>', arrowUpCircle: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><polyline points="16 12 12 8 8 12"></polyline><line x1="12" y1="16" x2="12" y2="8"></line></svg>', pauseCircle: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><line x1="10" y1="15" x2="10" y2="9"></line><line x1="14" y1="15" x2="14" y2="9"></line></svg>', checkSquare: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="9 11 12 14 22 4"></polyline><path d="M21 12v7a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11"></path></svg>', arrowDown: '<svg class="stroked" viewBox="0 0 24 24"><line x1="12" y1="5" x2="12" y2="19"></line><polyline points="19 12 12 19 5 12"></polyline></svg>', figma: '<svg class="stroked" viewBox="0 0 24 24"><path d="M5 5.5A3.5 3.5 0 0 1 8.5 2H12v7H8.5A3.5 3.5 0 0 1 5 5.5z"></path><path d="M12 2h3.5a3.5 3.5 0 1 1 0 7H12V2z"></path><path d="M12 12.5a3.5 3.5 0 1 1 7 0 3.5 3.5 0 1 1-7 0z"></path><path d="M5 19.5A3.5 3.5 0 0 1 8.5 16H12v3.5a3.5 3.5 0 1 1-7 0z"></path><path d="M5 12.5A3.5 3.5 0 0 1 8.5 9H12v7H8.5A3.5 3.5 0 0 1 5 12.5z"></path></svg>', cornerRightUp: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="10 9 15 4 20 9"></polyline><path d="M4 20h7a4 4 0 0 0 4-4V4"></path></svg>', chevronsRight: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="13 17 18 12 13 7"></polyline><polyline points="6 17 11 12 6 7"></polyline></svg>', list: '<svg class="stroked" viewBox="0 0 24 24"><line x1="8" y1="6" x2="21" y2="6"></line><line x1="8" y1="12" x2="21" y2="12"></line><line x1="8" y1="18" x2="21" y2="18"></line><line x1="3" y1="6" x2="3.01" y2="6"></line><line x1="3" y1="12" x2="3.01" y2="12"></line><line x1="3" y1="18" x2="3.01" y2="18"></line></svg>', chevronsDown: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="7 13 12 18 17 13"></polyline><polyline points="7 6 12 11 17 6"></polyline></svg>', wind: '<svg class="stroked" viewBox="0 0 24 24"><path d="M9.59 4.59A2 2 0 1 1 11 8H2m10.59 11.41A2 2 0 1 0 14 16H2m15.73-8.27A2.5 2.5 0 1 1 19.5 12H2"></path></svg>', cornerUpRight: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="15 14 20 9 15 4"></polyline><path d="M4 20v-7a4 4 0 0 1 4-4h12"></path></svg>', target: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="6"></circle><circle cx="12" cy="12" r="2"></circle></svg>', scissors: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="6" cy="6" r="3"></circle><circle cx="6" cy="18" r="3"></circle><line x1="20" y1="4" x2="8.12" y2="15.88"></line><line x1="14.47" y1="14.48" x2="20" y2="20"></line><line x1="8.12" y1="8.12" x2="12" y2="12"></line></svg>', minimize2: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="4 14 10 14 10 20"></polyline><polyline points="20 10 14 10 14 4"></polyline><line x1="14" y1="10" x2="21" y2="3"></line><line x1="3" y1="21" x2="10" y2="14"></line></svg>', playCircle: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><polygon points="10 8 16 12 10 16 10 8"></polygon></svg>', crosshair: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><line x1="22" y1="12" x2="18" y2="12"></line><line x1="6" y1="12" x2="2" y2="12"></line><line x1="12" y1="6" x2="12" y2="2"></line><line x1="12" y1="22" x2="12" y2="18"></line></svg>', airplay: '<svg class="stroked" viewBox="0 0 24 24"><path d="M5 17H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2h-1"></path><polygon points="12 15 17 21 7 21 12 15"></polygon></svg>', xOctagon: '<svg class="stroked" viewBox="0 0 24 24"><polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>', repeat: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="17 1 21 5 17 9"></polyline><path d="M3 11V9a4 4 0 0 1 4-4h14"></path><polyline points="7 23 3 19 7 15"></polyline><path d="M21 13v2a4 4 0 0 1-4 4H3"></path></svg>', edit3: '<svg class="stroked" viewBox="0 0 24 24"><path d="M12 20h9"></path><path d="M16.5 3.5a2.12 2.12 0 0 1 3 3L7 19l-4 1 1-4L16.5 3.5z"></path></svg>', volume1: '<svg class="stroked" viewBox="0 0 24 24"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><path d="M15.54 8.46a5 5 0 0 1 0 7.07"></path></svg>', sunrise: '<svg class="stroked" viewBox="0 0 24 24"><path d="M17 18a5 5 0 0 0-10 0"></path><line x1="12" y1="2" x2="12" y2="9"></line><line x1="4.22" y1="10.22" x2="5.64" y2="11.64"></line><line x1="1" y1="18" x2="3" y2="18"></line><line x1="21" y1="18" x2="23" y2="18"></line><line x1="18.36" y1="11.64" x2="19.78" y2="10.22"></line><line x1="23" y1="22" x2="1" y2="22"></line><polyline points="8 6 12 2 16 6"></polyline></svg>', toggleRight: '<svg class="stroked" viewBox="0 0 24 24"><rect x="1" y="5" width="22" height="14" rx="7" ry="7"></rect><circle cx="16" cy="12" r="3"></circle></svg>', umbrella: '<svg class="stroked" viewBox="0 0 24 24"><path d="M23 12a11.05 11.05 0 0 0-22 0zm-5 7a3 3 0 0 1-6 0v-7"></path></svg>', user: '<svg class="stroked" viewBox="0 0 24 24"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg>', fileMinus: '<svg class="stroked" viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="9" y1="15" x2="15" y2="15"></line></svg>', xCircle: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><line x1="15" y1="9" x2="9" y2="15"></line><line x1="9" y1="9" x2="15" y2="15"></line></svg>', circle: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle></svg>', phoneMissed: '<svg class="stroked" viewBox="0 0 24 24"><line x1="23" y1="1" x2="17" y2="7"></line><line x1="17" y1="1" x2="23" y2="7"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path></svg>', edit2: '<svg class="stroked" viewBox="0 0 24 24"><path d="M17 3a2.83 2.83 0 1 1 4 4L7.5 20.5 2 22l1.5-5.5L17 3z"></path></svg>', cornerLeftUp: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="14 9 9 4 4 9"></polyline><path d="M20 20h-7a4 4 0 0 1-4-4V4"></path></svg>', home: '<svg class="stroked" viewBox="0 0 24 24"><path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path><polyline points="9 22 9 12 15 12 15 22"></polyline></svg>', gitlab: '<svg class="stroked" viewBox="0 0 24 24"><path d="M22.65 14.39L12 22.13 1.35 14.39a.84.84 0 0 1-.3-.94l1.22-3.78 2.44-7.51A.42.42 0 0 1 4.82 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.49h8.1l2.44-7.51A.42.42 0 0 1 18.6 2a.43.43 0 0 1 .58 0 .42.42 0 0 1 .11.18l2.44 7.51L23 13.45a.84.84 0 0 1-.35.94z"></path></svg>', music: '<svg class="stroked" viewBox="0 0 24 24"><path d="M9 18V5l12-2v13"></path><circle cx="6" cy="18" r="3"></circle><circle cx="18" cy="16" r="3"></circle></svg>', smartphone: '<svg class="stroked" viewBox="0 0 24 24"><rect x="5" y="2" width="14" height="20" rx="2" ry="2"></rect><line x1="12" y1="18" x2="12.01" y2="18"></line></svg>', moreHorizontal: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="12" r="1"></circle><circle cx="19" cy="12" r="1"></circle><circle cx="5" cy="12" r="1"></circle></svg>', sliders: '<svg class="stroked" viewBox="0 0 24 24"><line x1="4" y1="21" x2="4" y2="14"></line><line x1="4" y1="10" x2="4" y2="3"></line><line x1="12" y1="21" x2="12" y2="12"></line><line x1="12" y1="8" x2="12" y2="3"></line><line x1="20" y1="21" x2="20" y2="16"></line><line x1="20" y1="12" x2="20" y2="3"></line><line x1="1" y1="14" x2="7" y2="14"></line><line x1="9" y1="8" x2="15" y2="8"></line><line x1="17" y1="16" x2="23" y2="16"></line></svg>', arrowUpLeft: '<svg class="stroked" viewBox="0 0 24 24"><line x1="17" y1="17" x2="7" y2="7"></line><polyline points="7 17 7 7 17 7"></polyline></svg>', chevronDown: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="6 9 12 15 18 9"></polyline></svg>', hexagon: '<svg class="stroked" viewBox="0 0 24 24"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path></svg>', github: '<svg class="stroked" viewBox="0 0 24 24"><path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path></svg>', crop: '<svg class="stroked" viewBox="0 0 24 24"><path d="M6.13 1L6 16a2 2 0 0 0 2 2h15"></path><path d="M1 6.13L16 6a2 2 0 0 1 2 2v15"></path></svg>', tag: '<svg class="stroked" viewBox="0 0 24 24"><path d="M20.59 13.41l-7.17 7.17a2 2 0 0 1-2.83 0L2 12V2h10l8.59 8.59a2 2 0 0 1 0 2.82z"></path><line x1="7" y1="7" x2="7.01" y2="7"></line></svg>', briefcase: '<svg class="stroked" viewBox="0 0 24 24"><rect x="2" y="7" width="20" height="14" rx="2" ry="2"></rect><path d="M16 21V5a2 2 0 0 0-2-2h-4a2 2 0 0 0-2 2v16"></path></svg>', rotateCw: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="23 4 23 10 17 10"></polyline><path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path></svg>', map: '<svg class="stroked" viewBox="0 0 24 24"><polygon points="1 6 1 22 8 18 16 22 23 18 23 2 16 6 8 2 1 6"></polygon><line x1="8" y1="2" x2="8" y2="18"></line><line x1="16" y1="6" x2="16" y2="22"></line></svg>', inbox: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="22 12 16 12 14 15 10 15 8 12 2 12"></polyline><path d="M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"></path></svg>', alignJustify: '<svg class="stroked" viewBox="0 0 24 24"><line x1="21" y1="10" x2="3" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="21" y1="18" x2="3" y2="18"></line></svg>', plusSquare: '<svg class="stroked" viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line></svg>', power: '<svg class="stroked" viewBox="0 0 24 24"><path d="M18.36 6.64a9 9 0 1 1-12.73 0"></path><line x1="12" y1="2" x2="12" y2="12"></line></svg>', database: '<svg class="stroked" viewBox="0 0 24 24"><ellipse cx="12" cy="5" rx="9" ry="3"></ellipse><path d="M21 12c0 1.66-4 3-9 3s-9-1.34-9-3"></path><path d="M3 5v14c0 1.66 4 3 9 3s9-1.34 9-3V5"></path></svg>', cameraOff: '<svg class="stroked" viewBox="0 0 24 24"><line x1="1" y1="1" x2="23" y2="23"></line><path d="M21 21H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3m3-3h6l2 3h4a2 2 0 0 1 2 2v9.34m-7.72-2.06a4 4 0 1 1-5.56-5.56"></path></svg>', toggleLeft: '<svg class="stroked" viewBox="0 0 24 24"><rect x="1" y="5" width="22" height="14" rx="7" ry="7"></rect><circle cx="8" cy="12" r="3"></circle></svg>', file: '<svg class="stroked" viewBox="0 0 24 24"><path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline></svg>', messageCircle: '<svg class="stroked" viewBox="0 0 24 24"><path d="M21 11.5a8.38 8.38 0 0 1-.9 3.8 8.5 8.5 0 0 1-7.6 4.7 8.38 8.38 0 0 1-3.8-.9L3 21l1.9-5.7a8.38 8.38 0 0 1-.9-3.8 8.5 8.5 0 0 1 4.7-7.6 8.38 8.38 0 0 1 3.8-.9h.5a8.48 8.48 0 0 1 8 8v.5z"></path></svg>', voicemail: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="5.5" cy="11.5" r="4.5"></circle><circle cx="18.5" cy="11.5" r="4.5"></circle><line x1="5.5" y1="16" x2="18.5" y2="16"></line></svg>', terminal: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="4 17 10 11 4 5"></polyline><line x1="12" y1="19" x2="20" y2="19"></line></svg>', move: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="5 9 2 12 5 15"></polyline><polyline points="9 5 12 2 15 5"></polyline><polyline points="15 19 12 22 9 19"></polyline><polyline points="19 9 22 12 19 15"></polyline><line x1="2" y1="12" x2="22" y2="12"></line><line x1="12" y1="2" x2="12" y2="22"></line></svg>', maximize: '<svg class="stroked" viewBox="0 0 24 24"><path d="M8 3H5a2 2 0 0 0-2 2v3m18 0V5a2 2 0 0 0-2-2h-3m0 18h3a2 2 0 0 0 2-2v-3M3 16v3a2 2 0 0 0 2 2h3"></path></svg>', chevronUp: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="18 15 12 9 6 15"></polyline></svg>', arrowDownLeft: '<svg class="stroked" viewBox="0 0 24 24"><line x1="17" y1="7" x2="7" y2="17"></line><polyline points="17 17 7 17 7 7"></polyline></svg>', fileText: '<svg class="stroked" viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="16" y1="13" x2="8" y2="13"></line><line x1="16" y1="17" x2="8" y2="17"></line><polyline points="10 9 9 9 8 9"></polyline></svg>', droplet: '<svg class="stroked" viewBox="0 0 24 24"><path d="M12 2.69l5.66 5.66a8 8 0 1 1-11.31 0z"></path></svg>', zapOff: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="12.41 6.75 13 2 10.57 4.92"></polyline><polyline points="18.57 12.91 21 10 15.66 10"></polyline><polyline points="8 8 3 14 12 14 11 22 16 16"></polyline><line x1="1" y1="1" x2="23" y2="23"></line></svg>', x: '<svg class="stroked" viewBox="0 0 24 24"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>', barChart: '<svg class="stroked" viewBox="0 0 24 24"><line x1="12" y1="20" x2="12" y2="10"></line><line x1="18" y1="20" x2="18" y2="4"></line><line x1="6" y1="20" x2="6" y2="16"></line></svg>', lock: '<svg class="stroked" viewBox="0 0 24 24"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 10 0v4"></path></svg>', logIn: '<svg class="stroked" viewBox="0 0 24 24"><path d="M15 3h4a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2h-4"></path><polyline points="10 17 15 12 10 7"></polyline><line x1="15" y1="12" x2="3" y2="12"></line></svg>', shoppingBag: '<svg class="stroked" viewBox="0 0 24 24"><path d="M6 2L3 6v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2V6l-3-4z"></path><line x1="3" y1="6" x2="21" y2="6"></line><path d="M16 10a4 4 0 0 1-8 0"></path></svg>', divide: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="6" r="2"></circle><line x1="5" y1="12" x2="19" y2="12"></line><circle cx="12" cy="18" r="2"></circle></svg>', cloudDrizzle: '<svg class="stroked" viewBox="0 0 24 24"><line x1="8" y1="19" x2="8" y2="21"></line><line x1="8" y1="13" x2="8" y2="15"></line><line x1="16" y1="19" x2="16" y2="21"></line><line x1="16" y1="13" x2="16" y2="15"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="12" y1="15" x2="12" y2="17"></line><path d="M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25"></path></svg>', refreshCw: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="23 4 23 10 17 10"></polyline><polyline points="1 20 1 14 7 14"></polyline><path d="M3.51 9a9 9 0 0 1 14.85-3.36L23 10M1 14l4.64 4.36A9 9 0 0 0 20.49 15"></path></svg>', chevronRight: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="9 18 15 12 9 6"></polyline></svg>', clipboard: '<svg class="stroked" viewBox="0 0 24 24"><path d="M16 4h2a2 2 0 0 1 2 2v14a2 2 0 0 1-2 2H6a2 2 0 0 1-2-2V6a2 2 0 0 1 2-2h2"></path><rect x="8" y="2" width="8" height="4" rx="1" ry="1"></rect></svg>', package: '<svg class="stroked" viewBox="0 0 24 24"><line x1="16.5" y1="9.4" x2="7.5" y2="4.21"></line><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg>', instagram: '<svg class="stroked" viewBox="0 0 24 24"><rect x="2" y="2" width="20" height="20" rx="5" ry="5"></rect><path d="M16 11.37A4 4 0 1 1 12.63 8 4 4 0 0 1 16 11.37z"></path><line x1="17.5" y1="6.5" x2="17.51" y2="6.5"></line></svg>', link: '<svg class="stroked" viewBox="0 0 24 24"><path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path></svg>', videoOff: '<svg class="stroked" viewBox="0 0 24 24"><path d="M16 16v1a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V7a2 2 0 0 1 2-2h2m5.66 0H14a2 2 0 0 1 2 2v3.34l1 1L23 7v10"></path><line x1="1" y1="1" x2="23" y2="23"></line></svg>', key: '<svg class="stroked" viewBox="0 0 24 24"><path d="M21 2l-2 2m-7.61 7.61a5.5 5.5 0 1 1-7.78 7.78 5.5 5.5 0 0 1 7.78-7.78zm0 0L15.5 7.5m0 0l3 3L22 7l-3-3m-3.5 3.5L19 4"></path></svg>', meh: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><line x1="8" y1="15" x2="16" y2="15"></line><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line></svg>', cornerDownRight: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="15 10 20 15 15 20"></polyline><path d="M4 4v7a4 4 0 0 0 4 4h12"></path></svg>', arrowRight: '<svg class="stroked" viewBox="0 0 24 24"><line x1="5" y1="12" x2="19" y2="12"></line><polyline points="12 5 19 12 12 19"></polyline></svg>', aperture: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><line x1="14.31" y1="8" x2="20.05" y2="17.94"></line><line x1="9.69" y1="8" x2="21.17" y2="8"></line><line x1="7.38" y1="12" x2="13.12" y2="2.06"></line><line x1="9.69" y1="16" x2="3.95" y2="6.06"></line><line x1="14.31" y1="16" x2="2.83" y2="16"></line><line x1="16.62" y1="12" x2="10.88" y2="21.94"></line></svg>', stopCircle: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><rect x="9" y="9" width="6" height="6"></rect></svg>', logOut: '<svg class="stroked" viewBox="0 0 24 24"><path d="M9 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h4"></path><polyline points="16 17 21 12 16 7"></polyline><line x1="21" y1="12" x2="9" y2="12"></line></svg>', arrowLeftCircle: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><polyline points="12 8 8 12 12 16"></polyline><line x1="16" y1="12" x2="8" y2="12"></line></svg>', barChart2: '<svg class="stroked" viewBox="0 0 24 24"><line x1="18" y1="20" x2="18" y2="10"></line><line x1="12" y1="20" x2="12" y2="4"></line><line x1="6" y1="20" x2="6" y2="14"></line></svg>', gitPullRequest: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="18" cy="18" r="3"></circle><circle cx="6" cy="6" r="3"></circle><path d="M13 6h3a2 2 0 0 1 2 2v7"></path><line x1="6" y1="9" x2="6" y2="21"></line></svg>', minimize: '<svg class="stroked" viewBox="0 0 24 24"><path d="M8 3v3a2 2 0 0 1-2 2H3m18 0h-3a2 2 0 0 1-2-2V3m0 18v-3a2 2 0 0 1 2-2h3M3 16h3a2 2 0 0 1 2 2v3"></path></svg>', minusSquare: '<svg class="stroked" viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="8" y1="12" x2="16" y2="12"></line></svg>', settings: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="12" r="3"></circle><path d="M19.4 15a1.65 1.65 0 0 0 .33 1.82l.06.06a2 2 0 0 1 0 2.83 2 2 0 0 1-2.83 0l-.06-.06a1.65 1.65 0 0 0-1.82-.33 1.65 1.65 0 0 0-1 1.51V21a2 2 0 0 1-2 2 2 2 0 0 1-2-2v-.09A1.65 1.65 0 0 0 9 19.4a1.65 1.65 0 0 0-1.82.33l-.06.06a2 2 0 0 1-2.83 0 2 2 0 0 1 0-2.83l.06-.06a1.65 1.65 0 0 0 .33-1.82 1.65 1.65 0 0 0-1.51-1H3a2 2 0 0 1-2-2 2 2 0 0 1 2-2h.09A1.65 1.65 0 0 0 4.6 9a1.65 1.65 0 0 0-.33-1.82l-.06-.06a2 2 0 0 1 0-2.83 2 2 0 0 1 2.83 0l.06.06a1.65 1.65 0 0 0 1.82.33H9a1.65 1.65 0 0 0 1-1.51V3a2 2 0 0 1 2-2 2 2 0 0 1 2 2v.09a1.65 1.65 0 0 0 1 1.51 1.65 1.65 0 0 0 1.82-.33l.06-.06a2 2 0 0 1 2.83 0 2 2 0 0 1 0 2.83l-.06.06a1.65 1.65 0 0 0-.33 1.82V9a1.65 1.65 0 0 0 1.51 1H21a2 2 0 0 1 2 2 2 2 0 0 1-2 2h-.09a1.65 1.65 0 0 0-1.51 1z"></path></svg>', cloudSnow: '<svg class="stroked" viewBox="0 0 24 24"><path d="M20 17.58A5 5 0 0 0 18 8h-1.26A8 8 0 1 0 4 16.25"></path><line x1="8" y1="16" x2="8.01" y2="16"></line><line x1="8" y1="20" x2="8.01" y2="20"></line><line x1="12" y1="18" x2="12.01" y2="18"></line><line x1="12" y1="22" x2="12.01" y2="22"></line><line x1="16" y1="16" x2="16.01" y2="16"></line><line x1="16" y1="20" x2="16.01" y2="20"></line></svg>', thumbsDown: '<svg class="stroked" viewBox="0 0 24 24"><path d="M10 15v4a3 3 0 0 0 3 3l4-9V2H5.72a2 2 0 0 0-2 1.7l-1.38 9a2 2 0 0 0 2 2.3zm7-13h2.67A2.31 2.31 0 0 1 22 4v7a2.31 2.31 0 0 1-2.33 2H17"></path></svg>', type: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="4 7 4 4 20 4 20 7"></polyline><line x1="9" y1="20" x2="15" y2="20"></line><line x1="12" y1="4" x2="12" y2="20"></line></svg>', archive: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="21 8 21 21 3 21 3 8"></polyline><rect x="1" y="3" width="22" height="5"></rect><line x1="10" y1="12" x2="14" y2="12"></line></svg>', phoneOutgoing: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="23 7 23 1 17 1"></polyline><line x1="16" y1="8" x2="23" y2="1"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path></svg>', pocket: '<svg class="stroked" viewBox="0 0 24 24"><path d="M4 3h16a2 2 0 0 1 2 2v6a10 10 0 0 1-10 10A10 10 0 0 1 2 11V5a2 2 0 0 1 2-2z"></path><polyline points="8 10 12 14 16 10"></polyline></svg>', mail: '<svg class="stroked" viewBox="0 0 24 24"><path d="M4 4h16c1.1 0 2 .9 2 2v12c0 1.1-.9 2-2 2H4c-1.1 0-2-.9-2-2V6c0-1.1.9-2 2-2z"></path><polyline points="22,6 12,13 2,6"></polyline></svg>', shield: '<svg class="stroked" viewBox="0 0 24 24"><path d="M12 22s8-4 8-10V5l-8-3-8 3v7c0 6 8 10 8 10z"></path></svg>', download: '<svg class="stroked" viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="7 10 12 15 17 10"></polyline><line x1="12" y1="15" x2="12" y2="3"></line></svg>', phoneForwarded: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="19 1 23 5 19 9"></polyline><line x1="15" y1="5" x2="23" y2="5"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path></svg>', cornerRightDown: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="10 15 15 20 20 15"></polyline><path d="M4 4h7a4 4 0 0 1 4 4v12"></path></svg>', bookOpen: '<svg class="stroked" viewBox="0 0 24 24"><path d="M2 3h6a4 4 0 0 1 4 4v14a3 3 0 0 0-3-3H2z"></path><path d="M22 3h-6a4 4 0 0 0-4 4v14a3 3 0 0 1 3-3h7z"></path></svg>', divideSquare: '<svg class="stroked" viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="8" y1="12" x2="16" y2="12"></line><line x1="12" y1="16" x2="12" y2="16"></line><line x1="12" y1="8" x2="12" y2="8"></line></svg>', server: '<svg class="stroked" viewBox="0 0 24 24"><rect x="2" y="2" width="20" height="8" rx="2" ry="2"></rect><rect x="2" y="14" width="20" height="8" rx="2" ry="2"></rect><line x1="6" y1="6" x2="6.01" y2="6"></line><line x1="6" y1="18" x2="6.01" y2="18"></line></svg>', tv: '<svg class="stroked" viewBox="0 0 24 24"><rect x="2" y="7" width="20" height="15" rx="2" ry="2"></rect><polyline points="17 2 12 7 7 2"></polyline></svg>', skipForward: '<svg class="stroked" viewBox="0 0 24 24"><polygon points="5 4 15 12 5 20 5 4"></polygon><line x1="19" y1="5" x2="19" y2="19"></line></svg>', volume: '<svg class="stroked" viewBox="0 0 24 24"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon></svg>', userPlus: '<svg class="stroked" viewBox="0 0 24 24"><path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="20" y1="8" x2="20" y2="14"></line><line x1="23" y1="11" x2="17" y2="11"></line></svg>', batteryCharging: '<svg class="stroked" viewBox="0 0 24 24"><path d="M5 18H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h3.19M15 6h2a2 2 0 0 1 2 2v8a2 2 0 0 1-2 2h-3.19"></path><line x1="23" y1="13" x2="23" y2="11"></line><polyline points="11 6 7 12 13 12 9 18"></polyline></svg>', layers: '<svg class="stroked" viewBox="0 0 24 24"><polygon points="12 2 2 7 12 12 22 7 12 2"></polygon><polyline points="2 17 12 22 22 17"></polyline><polyline points="2 12 12 17 22 12"></polyline></svg>', slash: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><line x1="4.93" y1="4.93" x2="19.07" y2="19.07"></line></svg>', radio: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="12" r="2"></circle><path d="M16.24 7.76a6 6 0 0 1 0 8.49m-8.48-.01a6 6 0 0 1 0-8.49m11.31-2.82a10 10 0 0 1 0 14.14m-14.14 0a10 10 0 0 1 0-14.14"></path></svg>', book: '<svg class="stroked" viewBox="0 0 24 24"><path d="M4 19.5A2.5 2.5 0 0 1 6.5 17H20"></path><path d="M6.5 2H20v20H6.5A2.5 2.5 0 0 1 4 19.5v-15A2.5 2.5 0 0 1 6.5 2z"></path></svg>', userMinus: '<svg class="stroked" viewBox="0 0 24 24"><path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="23" y1="11" x2="17" y2="11"></line></svg>', bell: '<svg class="stroked" viewBox="0 0 24 24"><path d="M18 8A6 6 0 0 0 6 8c0 7-3 9-3 9h18s-3-2-3-9"></path><path d="M13.73 21a2 2 0 0 1-3.46 0"></path></svg>', gitBranch: '<svg class="stroked" viewBox="0 0 24 24"><line x1="6" y1="3" x2="6" y2="15"></line><circle cx="18" cy="6" r="3"></circle><circle cx="6" cy="18" r="3"></circle><path d="M18 9a9 9 0 0 1-9 9"></path></svg>', coffee: '<svg class="stroked" viewBox="0 0 24 24"><path d="M18 8h1a4 4 0 0 1 0 8h-1"></path><path d="M2 8h16v9a4 4 0 0 1-4 4H6a4 4 0 0 1-4-4V8z"></path><line x1="6" y1="1" x2="6" y2="4"></line><line x1="10" y1="1" x2="10" y2="4"></line><line x1="14" y1="1" x2="14" y2="4"></line></svg>', code: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="16 18 22 12 16 6"></polyline><polyline points="8 6 2 12 8 18"></polyline></svg>', thermometer: '<svg class="stroked" viewBox="0 0 24 24"><path d="M14 14.76V3.5a2.5 2.5 0 0 0-5 0v11.26a4.5 4.5 0 1 0 5 0z"></path></svg>', cast: '<svg class="stroked" viewBox="0 0 24 24"><path d="M2 16.1A5 5 0 0 1 5.9 20M2 12.05A9 9 0 0 1 9.95 20M2 8V6a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v12a2 2 0 0 1-2 2h-6"></path><line x1="2" y1="20" x2="2.01" y2="20"></line></svg>', flag: '<svg class="stroked" viewBox="0 0 24 24"><path d="M4 15s1-1 4-1 5 2 8 2 4-1 4-1V3s-1 1-4 1-5-2-8-2-4 1-4 1z"></path><line x1="4" y1="22" x2="4" y2="15"></line></svg>', eyeOff: '<svg class="stroked" viewBox="0 0 24 24"><path d="M17.94 17.94A10.07 10.07 0 0 1 12 20c-7 0-11-8-11-8a18.45 18.45 0 0 1 5.06-5.94M9.9 4.24A9.12 9.12 0 0 1 12 4c7 0 11 8 11 8a18.5 18.5 0 0 1-2.16 3.19m-6.72-1.07a3 3 0 1 1-4.24-4.24"></path><line x1="1" y1="1" x2="23" y2="23"></line></svg>', battery: '<svg class="stroked" viewBox="0 0 24 24"><rect x="1" y="6" width="18" height="12" rx="2" ry="2"></rect><line x1="23" y1="13" x2="23" y2="11"></line></svg>', disc: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="3"></circle></svg>', frown: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><path d="M16 16s-1.5-2-4-2-4 2-4 2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line></svg>', tool: '<svg class="stroked" viewBox="0 0 24 24"><path d="M14.7 6.3a1 1 0 0 0 0 1.4l1.6 1.6a1 1 0 0 0 1.4 0l3.77-3.77a6 6 0 0 1-7.94 7.94l-6.91 6.91a2.12 2.12 0 0 1-3-3l6.91-6.91a6 6 0 0 1 7.94-7.94l-3.76 3.76z"></path></svg>', cpu: '<svg class="stroked" viewBox="0 0 24 24"><rect x="4" y="4" width="16" height="16" rx="2" ry="2"></rect><rect x="9" y="9" width="6" height="6"></rect><line x1="9" y1="1" x2="9" y2="4"></line><line x1="15" y1="1" x2="15" y2="4"></line><line x1="9" y1="20" x2="9" y2="23"></line><line x1="15" y1="20" x2="15" y2="23"></line><line x1="20" y1="9" x2="23" y2="9"></line><line x1="20" y1="14" x2="23" y2="14"></line><line x1="1" y1="9" x2="4" y2="9"></line><line x1="1" y1="14" x2="4" y2="14"></line></svg>', bold: '<svg class="stroked" viewBox="0 0 24 24"><path d="M6 4h8a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path><path d="M6 12h9a4 4 0 0 1 4 4 4 4 0 0 1-4 4H6z"></path></svg>', hash: '<svg class="stroked" viewBox="0 0 24 24"><line x1="4" y1="9" x2="20" y2="9"></line><line x1="4" y1="15" x2="20" y2="15"></line><line x1="10" y1="3" x2="8" y2="21"></line><line x1="16" y1="3" x2="14" y2="21"></line></svg>', share2: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="18" cy="5" r="3"></circle><circle cx="6" cy="12" r="3"></circle><circle cx="18" cy="19" r="3"></circle><line x1="8.59" y1="13.51" x2="15.42" y2="17.49"></line><line x1="15.41" y1="6.51" x2="8.59" y2="10.49"></line></svg>', plus: '<svg class="stroked" viewBox="0 0 24 24"><line x1="12" y1="5" x2="12" y2="19"></line><line x1="5" y1="12" x2="19" y2="12"></line></svg>', check: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="20 6 9 17 4 12"></polyline></svg>', rotateCcw: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="1 4 1 10 7 10"></polyline><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"></path></svg>', hardDrive: '<svg class="stroked" viewBox="0 0 24 24"><line x1="22" y1="12" x2="2" y2="12"></line><path d="M5.45 5.11L2 12v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6l-3.45-6.89A2 2 0 0 0 16.76 4H7.24a2 2 0 0 0-1.79 1.11z"></path><line x1="6" y1="16" x2="6.01" y2="16"></line><line x1="10" y1="16" x2="10.01" y2="16"></line></svg>', bluetooth: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="6.5 6.5 17.5 17.5 12 23 12 1 17.5 6.5 6.5 17.5"></polyline></svg>', pieChart: '<svg class="stroked" viewBox="0 0 24 24"><path d="M21.21 15.89A10 10 0 1 1 8 2.83"></path><path d="M22 12A10 10 0 0 0 12 2v10z"></path></svg>', headphones: '<svg class="stroked" viewBox="0 0 24 24"><path d="M3 18v-6a9 9 0 0 1 18 0v6"></path><path d="M21 19a2 2 0 0 1-2 2h-1a2 2 0 0 1-2-2v-3a2 2 0 0 1 2-2h3zM3 19a2 2 0 0 0 2 2h1a2 2 0 0 0 2-2v-3a2 2 0 0 0-2-2H3z"></path></svg>', rss: '<svg class="stroked" viewBox="0 0 24 24"><path d="M4 11a9 9 0 0 1 9 9"></path><path d="M4 4a16 16 0 0 1 16 16"></path><circle cx="5" cy="19" r="1"></circle></svg>', wifi: '<svg class="stroked" viewBox="0 0 24 24"><path d="M5 12.55a11 11 0 0 1 14.08 0"></path><path d="M1.42 9a16 16 0 0 1 21.16 0"></path><path d="M8.53 16.11a6 6 0 0 1 6.95 0"></path><line x1="12" y1="20" x2="12.01" y2="20"></line></svg>', cornerUpLeft: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="9 14 4 9 9 4"></polyline><path d="M20 20v-7a4 4 0 0 0-4-4H4"></path></svg>', watch: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="12" r="7"></circle><polyline points="12 9 12 12 13.5 13.5"></polyline><path d="M16.51 17.35l-.35 3.83a2 2 0 0 1-2 1.82H9.83a2 2 0 0 1-2-1.82l-.35-3.83m.01-10.7l.35-3.83A2 2 0 0 1 9.83 1h4.35a2 2 0 0 1 2 1.82l.35 3.83"></path></svg>', info: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg>', userX: '<svg class="stroked" viewBox="0 0 24 24"><path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><line x1="18" y1="8" x2="23" y2="13"></line><line x1="23" y1="8" x2="18" y2="13"></line></svg>', loader: '<svg class="stroked" viewBox="0 0 24 24"><line x1="12" y1="2" x2="12" y2="6"></line><line x1="12" y1="18" x2="12" y2="22"></line><line x1="4.93" y1="4.93" x2="7.76" y2="7.76"></line><line x1="16.24" y1="16.24" x2="19.07" y2="19.07"></line><line x1="2" y1="12" x2="6" y2="12"></line><line x1="18" y1="12" x2="22" y2="12"></line><line x1="4.93" y1="19.07" x2="7.76" y2="16.24"></line><line x1="16.24" y1="7.76" x2="19.07" y2="4.93"></line></svg>', refreshCcw: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="1 4 1 10 7 10"></polyline><polyline points="23 20 23 14 17 14"></polyline><path d="M20.49 9A9 9 0 0 0 5.64 5.64L1 10m22 4l-4.64 4.36A9 9 0 0 1 3.51 15"></path></svg>', folderPlus: '<svg class="stroked" viewBox="0 0 24 24"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path><line x1="12" y1="11" x2="12" y2="17"></line><line x1="9" y1="14" x2="15" y2="14"></line></svg>', gitMerge: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="18" cy="18" r="3"></circle><circle cx="6" cy="6" r="3"></circle><path d="M6 21V9a9 9 0 0 0 9 9"></path></svg>', mic: '<svg class="stroked" viewBox="0 0 24 24"><path d="M12 1a3 3 0 0 0-3 3v8a3 3 0 0 0 6 0V4a3 3 0 0 0-3-3z"></path><path d="M19 10v2a7 7 0 0 1-14 0v-2"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>', copy: '<svg class="stroked" viewBox="0 0 24 24"><rect x="9" y="9" width="13" height="13" rx="2" ry="2"></rect><path d="M5 15H4a2 2 0 0 1-2-2V4a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v1"></path></svg>', zoomIn: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="11" y1="8" x2="11" y2="14"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg>', arrowRightCircle: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><polyline points="12 16 16 12 12 8"></polyline><line x1="8" y1="12" x2="16" y2="12"></line></svg>', alignRight: '<svg class="stroked" viewBox="0 0 24 24"><line x1="21" y1="10" x2="7" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="21" y1="18" x2="7" y2="18"></line></svg>', image: '<svg class="stroked" viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><circle cx="8.5" cy="8.5" r="1.5"></circle><polyline points="21 15 16 10 5 21"></polyline></svg>', maximize2: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="15 3 21 3 21 9"></polyline><polyline points="9 21 3 21 3 15"></polyline><line x1="21" y1="3" x2="14" y2="10"></line><line x1="3" y1="21" x2="10" y2="14"></line></svg>', checkCircle: '<svg class="stroked" viewBox="0 0 24 24"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"></path><polyline points="22 4 12 14.01 9 11.01"></polyline></svg>', sunset: '<svg class="stroked" viewBox="0 0 24 24"><path d="M17 18a5 5 0 0 0-10 0"></path><line x1="12" y1="9" x2="12" y2="2"></line><line x1="4.22" y1="10.22" x2="5.64" y2="11.64"></line><line x1="1" y1="18" x2="3" y2="18"></line><line x1="21" y1="18" x2="23" y2="18"></line><line x1="18.36" y1="11.64" x2="19.78" y2="10.22"></line><line x1="23" y1="22" x2="1" y2="22"></line><polyline points="16 5 12 9 8 5"></polyline></svg>', save: '<svg class="stroked" viewBox="0 0 24 24"><path d="M19 21H5a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h11l5 5v11a2 2 0 0 1-2 2z"></path><polyline points="17 21 17 13 7 13 7 21"></polyline><polyline points="7 3 7 8 15 8"></polyline></svg>', smile: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><path d="M8 14s1.5 2 4 2 4-2 4-2"></path><line x1="9" y1="9" x2="9.01" y2="9"></line><line x1="15" y1="9" x2="15.01" y2="9"></line></svg>', navigation: '<svg class="stroked" viewBox="0 0 24 24"><polygon points="3 11 22 2 13 21 11 13 3 11"></polygon></svg>', cloudLightning: '<svg class="stroked" viewBox="0 0 24 24"><path d="M19 16.9A5 5 0 0 0 18 7h-1.26a8 8 0 1 0-11.62 9"></path><polyline points="13 11 9 17 15 17 11 23"></polyline></svg>', paperclip: '<svg class="stroked" viewBox="0 0 24 24"><path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path></svg>', fastForward: '<svg class="stroked" viewBox="0 0 24 24"><polygon points="13 19 22 12 13 5 13 19"></polygon><polygon points="2 19 11 12 2 5 2 19"></polygon></svg>', xSquare: '<svg class="stroked" viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="9" x2="15" y2="15"></line><line x1="15" y1="9" x2="9" y2="15"></line></svg>', award: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="8" r="7"></circle><polyline points="8.21 13.89 7 23 12 20 17 23 15.79 13.88"></polyline></svg>', zoomOut: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line><line x1="8" y1="11" x2="14" y2="11"></line></svg>', box: '<svg class="stroked" viewBox="0 0 24 24"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg>', thumbsUp: '<svg class="stroked" viewBox="0 0 24 24"><path d="M14 9V5a3 3 0 0 0-3-3l-4 9v11h11.28a2 2 0 0 0 2-1.7l1.38-9a2 2 0 0 0-2-2.3zM7 22H4a2 2 0 0 1-2-2v-7a2 2 0 0 1 2-2h3"></path></svg>', percent: '<svg class="stroked" viewBox="0 0 24 24"><line x1="19" y1="5" x2="5" y2="19"></line><circle cx="6.5" cy="6.5" r="2.5"></circle><circle cx="17.5" cy="17.5" r="2.5"></circle></svg>', sidebar: '<svg class="stroked" viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="9" y1="3" x2="9" y2="21"></line></svg>', square: '<svg class="stroked" viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect></svg>', play: '<svg class="stroked" viewBox="0 0 24 24"><polygon points="5 3 19 12 5 21 5 3"></polygon></svg>', gitCommit: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="12" r="4"></circle><line x1="1.05" y1="12" x2="7" y2="12"></line><line x1="17.01" y1="12" x2="22.96" y2="12"></line></svg>', table: '<svg class="stroked" viewBox="0 0 24 24"><path d="M9 3H5a2 2 0 0 0-2 2v4m6-6h10a2 2 0 0 1 2 2v4M9 3v18m0 0h10a2 2 0 0 0 2-2V9M9 21H5a2 2 0 0 1-2-2V9m0 0h18"></path></svg>', send: '<svg class="stroked" viewBox="0 0 24 24"><line x1="22" y1="2" x2="11" y2="13"></line><polygon points="22 2 15 22 11 13 2 9 22 2"></polygon></svg>', phoneCall: '<svg class="stroked" viewBox="0 0 24 24"><path d="M15.05 5A5 5 0 0 1 19 8.95M15.05 1A9 9 0 0 1 23 8.94m-1 7.98v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path></svg>', speaker: '<svg class="stroked" viewBox="0 0 24 24"><rect x="4" y="2" width="16" height="20" rx="2" ry="2"></rect><circle cx="12" cy="14" r="4"></circle><line x1="12" y1="6" x2="12.01" y2="6"></line></svg>', facebook: '<svg class="filled" version="1.1" viewBox="0 0 512 512"><g></g><path d="M464 0h-416c-26.4 0-48 21.6-48 48v416c0 26.4 21.6 48 48 48h208v-224h-64v-64h64v-32c0-52.9 43.1-96 96-96h64v64h-64c-17.6 0-32 14.4-32 32v32h96l-16 64h-80v224h144c26.4 0 48-21.6 48-48v-416c0-26.4-21.6-48-48-48z"></path></svg> ', codesandbox: '<svg class="stroked" viewBox="0 0 24 24"><path d="M21 16V8a2 2 0 0 0-1-1.73l-7-4a2 2 0 0 0-2 0l-7 4A2 2 0 0 0 3 8v8a2 2 0 0 0 1 1.73l7 4a2 2 0 0 0 2 0l7-4A2 2 0 0 0 21 16z"></path><polyline points="7.5 4.21 12 6.81 16.5 4.21"></polyline><polyline points="7.5 19.79 7.5 14.6 3 12"></polyline><polyline points="21 12 16.5 14.6 16.5 19.79"></polyline><polyline points="3.27 6.96 12 12.01 20.73 6.96"></polyline><line x1="12" y1="22.08" x2="12" y2="12"></line></svg>', camera: '<svg class="stroked" viewBox="0 0 24 24"><path d="M23 19a2 2 0 0 1-2 2H3a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h4l2-3h6l2 3h4a2 2 0 0 1 2 2z"></path><circle cx="12" cy="13" r="4"></circle></svg>', link2: '<svg class="stroked" viewBox="0 0 24 24"><path d="M15 7h3a5 5 0 0 1 5 5 5 5 0 0 1-5 5h-3m-6 0H6a5 5 0 0 1-5-5 5 5 0 0 1 5-5h3"></path><line x1="8" y1="12" x2="16" y2="12"></line></svg>', printer: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="6 9 6 2 18 2 18 9"></polyline><path d="M6 18H4a2 2 0 0 1-2-2v-5a2 2 0 0 1 2-2h16a2 2 0 0 1 2 2v5a2 2 0 0 1-2 2h-2"></path><rect x="6" y="14" width="12" height="8"></rect></svg>', folderMinus: '<svg class="stroked" viewBox="0 0 24 24"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path><line x1="9" y1="14" x2="15" y2="14"></line></svg>', arrowUpRight: '<svg class="stroked" viewBox="0 0 24 24"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg>', truck: '<svg class="stroked" viewBox="0 0 24 24"><rect x="1" y="3" width="15" height="13"></rect><polygon points="16 8 20 8 23 11 23 16 16 16 16 8"></polygon><circle cx="5.5" cy="18.5" r="2.5"></circle><circle cx="18.5" cy="18.5" r="2.5"></circle></svg>', lifeBuoy: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="4"></circle><line x1="4.93" y1="4.93" x2="9.17" y2="9.17"></line><line x1="14.83" y1="14.83" x2="19.07" y2="19.07"></line><line x1="14.83" y1="9.17" x2="19.07" y2="4.93"></line><line x1="14.83" y1="9.17" x2="18.36" y2="5.64"></line><line x1="4.93" y1="19.07" x2="9.17" y2="14.83"></line></svg>', penTool: '<svg class="stroked" viewBox="0 0 24 24"><path d="M12 19l7-7 3 3-7 7-3-3z"></path><path d="M18 13l-1.5-7.5L2 2l3.5 14.5L13 18l5-5z"></path><path d="M2 2l7.59 7.59"></path><circle cx="11" cy="11" r="2"></circle></svg>', atSign: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="12" r="4"></circle><path d="M16 8v5a3 3 0 0 0 6 0v-1a10 10 0 1 0-3.92 7.94"></path></svg>', feather: '<svg class="stroked" viewBox="0 0 24 24"><path d="M20.24 12.24a6 6 0 0 0-8.49-8.49L5 10.5V19h8.5z"></path><line x1="16" y1="8" x2="2" y2="22"></line><line x1="17.5" y1="15" x2="9" y2="15"></line></svg>', trash: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path></svg>', wifiOff: '<svg class="stroked" viewBox="0 0 24 24"><line x1="1" y1="1" x2="23" y2="23"></line><path d="M16.72 11.06A10.94 10.94 0 0 1 19 12.55"></path><path d="M5 12.55a10.94 10.94 0 0 1 5.17-2.39"></path><path d="M10.71 5.05A16 16 0 0 1 22.58 9"></path><path d="M1.42 9a15.91 15.91 0 0 1 4.7-2.88"></path><path d="M8.53 16.11a6 6 0 0 1 6.95 0"></path><line x1="12" y1="20" x2="12.01" y2="20"></line></svg>', cornerLeftDown: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="14 15 9 20 4 15"></polyline><path d="M20 4h-7a4 4 0 0 0-4 4v12"></path></svg>', dollarSign: '<svg class="stroked" viewBox="0 0 24 24"><line x1="12" y1="1" x2="12" y2="23"></line><path d="M17 5H9.5a3.5 3.5 0 0 0 0 7h5a3.5 3.5 0 0 1 0 7H6"></path></svg>', star: '<svg class="stroked" viewBox="0 0 24 24"><polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"></polygon></svg>', cloudOff: '<svg class="stroked" viewBox="0 0 24 24"><path d="M22.61 16.95A5 5 0 0 0 18 10h-1.26a8 8 0 0 0-7.05-6M5 5a8 8 0 0 0 4 15h9a5 5 0 0 0 1.7-.3"></path><line x1="1" y1="1" x2="23" y2="23"></line></svg>', sun: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="12" r="5"></circle><line x1="12" y1="1" x2="12" y2="3"></line><line x1="12" y1="21" x2="12" y2="23"></line><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line><line x1="1" y1="12" x2="3" y2="12"></line><line x1="21" y1="12" x2="23" y2="12"></line><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line></svg>', messageSquare: '<svg class="stroked" viewBox="0 0 24 24"><path d="M21 15a2 2 0 0 1-2 2H7l-4 4V5a2 2 0 0 1 2-2h14a2 2 0 0 1 2 2z"></path></svg>', edit: '<svg class="stroked" viewBox="0 0 24 24"><path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path><path d="M18.5 2.5a2.12 2.12 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path></svg>', anchor: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="5" r="3"></circle><line x1="12" y1="22" x2="12" y2="8"></line><path d="M5 12H2a10 10 0 0 0 20 0h-3"></path></svg>', alertCircle: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line></svg>', chevronsUp: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="17 11 12 6 7 11"></polyline><polyline points="17 18 12 13 7 18"></polyline></svg>', uploadCloud: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="16 16 12 12 8 16"></polyline><line x1="12" y1="12" x2="12" y2="21"></line><path d="M20.39 18.39A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.3"></path><polyline points="16 16 12 12 8 16"></polyline></svg>', twitch: '<svg class="stroked" viewBox="0 0 24 24"><path d="M21 2H3v16h5v4l4-4h5l4-4V2zm-10 9V7m5 4V7"></path></svg>', youtube: '<svg class="filled" version="1.1" viewBox="0 0 512 512"><g></g><path d="M506.9 153.6c0 0-5-35.3-20.4-50.8-19.5-20.4-41.3-20.5-51.3-21.7-71.6-5.2-179.1-5.2-179.1-5.2h-0.2c0 0-107.5 0-179.1 5.2-10 1.2-31.8 1.3-51.3 21.7-15.4 15.5-20.3 50.8-20.3 50.8s-5.1 41.4-5.1 82.9v38.8c0 41.4 5.1 82.9 5.1 82.9s5 35.3 20.3 50.8c19.5 20.4 45.1 19.7 56.5 21.9 41 3.9 174.1 5.1 174.1 5.1s107.6-0.2 179.2-5.3c10-1.2 31.8-1.3 51.3-21.7 15.4-15.5 20.4-50.8 20.4-50.8s5.1-41.4 5.1-82.9v-38.8c-0.1-41.4-5.2-82.9-5.2-82.9zM203.1 322.4v-143.9l138.3 72.2-138.3 71.7z"></path></svg> ', unlock: '<svg class="stroked" viewBox="0 0 24 24"><rect x="3" y="11" width="18" height="11" rx="2" ry="2"></rect><path d="M7 11V7a5 5 0 0 1 9.9-1"></path></svg>', compass: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><polygon points="16.24 7.76 14.12 14.12 7.76 16.24 9.88 9.88 16.24 7.76"></polygon></svg>', plusCircle: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="8" x2="12" y2="16"></line><line x1="8" y1="12" x2="16" y2="12"></line></svg>', creditCard: '<svg class="stroked" viewBox="0 0 24 24"><rect x="1" y="4" width="22" height="16" rx="2" ry="2"></rect><line x1="1" y1="10" x2="23" y2="10"></line></svg>', cloudRain: '<svg class="stroked" viewBox="0 0 24 24"><line x1="16" y1="13" x2="16" y2="21"></line><line x1="8" y1="13" x2="8" y2="21"></line><line x1="12" y1="15" x2="12" y2="23"></line><path d="M20 16.58A5 5 0 0 0 18 7h-1.26A8 8 0 1 0 4 15.25"></path></svg>', trash2: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="3 6 5 6 21 6"></polyline><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path><line x1="10" y1="11" x2="10" y2="17"></line><line x1="14" y1="11" x2="14" y2="17"></line></svg>', skipBack: '<svg class="stroked" viewBox="0 0 24 24"><polygon points="19 20 9 12 19 4 19 20"></polygon><line x1="5" y1="19" x2="5" y2="5"></line></svg>', filePlus: '<svg class="stroked" viewBox="0 0 24 24"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path><polyline points="14 2 14 8 20 8"></polyline><line x1="12" y1="18" x2="12" y2="12"></line><line x1="9" y1="15" x2="15" y2="15"></line></svg>', delete: '<svg class="stroked" viewBox="0 0 24 24"><path d="M21 4H8l-7 8 7 8h13a2 2 0 0 0 2-2V6a2 2 0 0 0-2-2z"></path><line x1="18" y1="9" x2="12" y2="15"></line><line x1="12" y1="9" x2="18" y2="15"></line></svg>', command: '<svg class="stroked" viewBox="0 0 24 24"><path d="M18 3a3 3 0 0 0-3 3v12a3 3 0 0 0 3 3 3 3 0 0 0 3-3 3 3 0 0 0-3-3H6a3 3 0 0 0-3 3 3 3 0 0 0 3 3 3 3 0 0 0 3-3V6a3 3 0 0 0-3-3 3 3 0 0 0-3 3 3 3 0 0 0 3 3h12a3 3 0 0 0 3-3 3 3 0 0 0-3-3z"></path></svg>', clock: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline></svg>', octagon: '<svg class="stroked" viewBox="0 0 24 24"><polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon></svg>', phone: '<svg class="stroked" viewBox="0 0 24 24"><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path></svg>', eye: '<svg class="stroked" viewBox="0 0 24 24"><path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path><circle cx="12" cy="12" r="3"></circle></svg>', phoneOff: '<svg class="stroked" viewBox="0 0 24 24"><path d="M10.68 13.31a16 16 0 0 0 3.41 2.6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7 2 2 0 0 1 1.72 2v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.42 19.42 0 0 1-3.33-2.67m-2.67-3.34a19.79 19.79 0 0 1-3.07-8.63A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91"></path><line x1="23" y1="1" x2="1" y2="23"></line></svg>', codepen: '<svg class="stroked" viewBox="0 0 24 24"><polygon points="12 2 22 8.5 22 15.5 12 22 2 15.5 2 8.5 12 2"></polygon><line x1="12" y1="22" x2="12" y2="15.5"></line><polyline points="22 8.5 12 15.5 2 8.5"></polyline><polyline points="2 15.5 12 8.5 22 15.5"></polyline><line x1="12" y1="2" x2="12" y2="8.5"></line></svg>', dribbble: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><path d="M8.56 2.75c4.37 6.03 6.02 9.42 8.03 17.72m2.54-15.38c-3.72 4.35-8.94 5.66-16.88 5.85m19.5 1.9c-3.5-.93-6.63-.82-8.94 0-2.58.92-5.01 2.86-7.44 6.32"></path></svg>', gift: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="20 12 20 22 4 22 4 12"></polyline><rect x="2" y="7" width="20" height="5"></rect><line x1="12" y1="22" x2="12" y2="7"></line><path d="M12 7H7.5a2.5 2.5 0 0 1 0-5C11 2 12 7 12 7z"></path><path d="M12 7h4.5a2.5 2.5 0 0 0 0-5C13 2 12 7 12 7z"></path></svg>', externalLink: '<svg class="stroked" viewBox="0 0 24 24"><path d="M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"></path><polyline points="15 3 21 3 21 9"></polyline><line x1="10" y1="14" x2="21" y2="3"></line></svg>', zap: '<svg class="stroked" viewBox="0 0 24 24"><polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"></polygon></svg>', trello: '<svg class="stroked" viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><rect x="7" y="7" width="3" height="9"></rect><rect x="14" y="7" width="3" height="5"></rect></svg>', moreVertical: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="12" r="1"></circle><circle cx="12" cy="5" r="1"></circle><circle cx="12" cy="19" r="1"></circle></svg>', micOff: '<svg class="stroked" viewBox="0 0 24 24"><line x1="1" y1="1" x2="23" y2="23"></line><path d="M9 9v3a3 3 0 0 0 5.12 2.12M15 9.34V4a3 3 0 0 0-5.94-.6"></path><path d="M17 16.95A7 7 0 0 1 5 12v-2m14 0v2a7 7 0 0 1-.11 1.23"></path><line x1="12" y1="19" x2="12" y2="23"></line><line x1="8" y1="23" x2="16" y2="23"></line></svg>', share: '<svg class="stroked" viewBox="0 0 24 24"><path d="M4 12v8a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2v-8"></path><polyline points="16 6 12 2 8 6"></polyline><line x1="12" y1="2" x2="12" y2="15"></line></svg>', arrowUp: '<svg class="stroked" viewBox="0 0 24 24"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg>', bellOff: '<svg class="stroked" viewBox="0 0 24 24"><path d="M13.73 21a2 2 0 0 1-3.46 0"></path><path d="M18.63 13A17.89 17.89 0 0 1 18 8"></path><path d="M6.26 6.26A5.86 5.86 0 0 0 6 8c0 7-3 9-3 9h14"></path><path d="M18 8a6 6 0 0 0-9.33-5"></path><line x1="1" y1="1" x2="23" y2="23"></line></svg>', linkedin: '<svg class="stroked" viewBox="0 0 24 24"><path d="M16 8a6 6 0 0 1 6 6v7h-4v-7a2 2 0 0 0-2-2 2 2 0 0 0-2 2v7h-4v-7a6 6 0 0 1 6-6z"></path><rect x="2" y="9" width="4" height="12"></rect><circle cx="4" cy="4" r="2"></circle></svg>', video: '<svg class="stroked" viewBox="0 0 24 24"><polygon points="23 7 16 12 23 17 23 7"></polygon><rect x="1" y="5" width="15" height="14" rx="2" ry="2"></rect></svg>', divideCircle: '<svg class="stroked" viewBox="0 0 24 24"><line x1="8" y1="12" x2="16" y2="12"></line><line x1="12" y1="16" x2="12" y2="16"></line><line x1="12" y1="8" x2="12" y2="8"></line><circle cx="12" cy="12" r="10"></circle></svg>', activity: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="22 12 18 12 15 21 9 3 6 12 2 12"></polyline></svg>', twitter: '<svg class="stroked" viewBox="0 0 24 24"><path d="M23 3a10.9 10.9 0 0 1-3.14 1.53 4.48 4.48 0 0 0-7.86 3v1A10.66 10.66 0 0 1 3 4s-4 9 5 13a11.64 11.64 0 0 1-7 2c9 5 20 0 20-11.5a4.5 4.5 0 0 0-.08-.83A7.72 7.72 0 0 0 23 3z"></path></svg>', mapPin: '<svg class="stroked" viewBox="0 0 24 24"><path d="M21 10c0 7-9 13-9 13s-9-6-9-13a9 9 0 0 1 18 0z"></path><circle cx="12" cy="10" r="3"></circle></svg>', filter: '<svg class="stroked" viewBox="0 0 24 24"><polygon points="22 3 2 3 10 12.46 10 19 14 21 14 12.46 22 3"></polygon></svg>', phoneIncoming: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="16 2 16 8 22 8"></polyline><line x1="23" y1="1" x2="16" y2="8"></line><path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.79 19.79 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6 19.79 19.79 0 0 1-3.07-8.67A2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72 12.84 12.84 0 0 0 .7 2.81 2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.27-1.27a2 2 0 0 1 2.11-.45 12.84 12.84 0 0 0 2.81.7A2 2 0 0 1 22 16.92z"></path></svg>', italic: '<svg class="stroked" viewBox="0 0 24 24"><line x1="19" y1="4" x2="10" y2="4"></line><line x1="14" y1="20" x2="5" y2="20"></line><line x1="15" y1="4" x2="9" y2="20"></line></svg>', chevronsLeft: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="11 17 6 12 11 7"></polyline><polyline points="18 17 13 12 18 7"></polyline></svg>', calendar: '<svg class="stroked" viewBox="0 0 24 24"><rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line></svg>', globe: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><line x1="2" y1="12" x2="22" y2="12"></line><path d="M12 2a15.3 15.3 0 0 1 4 10 15.3 15.3 0 0 1-4 10 15.3 15.3 0 0 1-4-10 15.3 15.3 0 0 1 4-10z"></path></svg>', arrowLeft: '<svg class="stroked" viewBox="0 0 24 24"><line x1="19" y1="12" x2="5" y2="12"></line><polyline points="12 19 5 12 12 5"></polyline></svg>', alignCenter: '<svg class="stroked" viewBox="0 0 24 24"><line x1="18" y1="10" x2="6" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="18" y1="18" x2="6" y2="18"></line></svg>', minusCircle: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><line x1="8" y1="12" x2="16" y2="12"></line></svg>', arrowDownRight: '<svg class="stroked" viewBox="0 0 24 24"><line x1="7" y1="7" x2="17" y2="17"></line><polyline points="17 7 17 17 7 17"></polyline></svg>', framer: '<svg class="stroked" viewBox="0 0 24 24"><path d="M5 16V9h14V2H5l14 14h-7m-7 0l7 7v-7m-7 0h7"></path></svg>', volumeX: '<svg class="stroked" viewBox="0 0 24 24"><polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"></polygon><line x1="23" y1="9" x2="17" y2="15"></line><line x1="17" y1="9" x2="23" y2="15"></line></svg>', slack: '<svg class="stroked" viewBox="0 0 24 24"><path d="M14.5 10c-.83 0-1.5-.67-1.5-1.5v-5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5z"></path><path d="M20.5 10H19V8.5c0-.83.67-1.5 1.5-1.5s1.5.67 1.5 1.5-.67 1.5-1.5 1.5z"></path><path d="M9.5 14c.83 0 1.5.67 1.5 1.5v5c0 .83-.67 1.5-1.5 1.5S8 21.33 8 20.5v-5c0-.83.67-1.5 1.5-1.5z"></path><path d="M3.5 14H5v1.5c0 .83-.67 1.5-1.5 1.5S2 16.33 2 15.5 2.67 14 3.5 14z"></path><path d="M14 14.5c0-.83.67-1.5 1.5-1.5h5c.83 0 1.5.67 1.5 1.5s-.67 1.5-1.5 1.5h-5c-.83 0-1.5-.67-1.5-1.5z"></path><path d="M15.5 19H14v1.5c0 .83.67 1.5 1.5 1.5s1.5-.67 1.5-1.5-.67-1.5-1.5-1.5z"></path><path d="M10 9.5C10 8.67 9.33 8 8.5 8h-5C2.67 8 2 8.67 2 9.5S2.67 11 3.5 11h5c.83 0 1.5-.67 1.5-1.5z"></path><path d="M8.5 5H10V3.5C10 2.67 9.33 2 8.5 2S7 2.67 7 3.5 7.67 5 8.5 5z"></path></svg>', cloud: '<svg class="stroked" viewBox="0 0 24 24"><path d="M18 10h-1.26A8 8 0 1 0 9 20h9a5 5 0 0 0 0-10z"></path></svg>', downloadCloud: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="8 17 12 21 16 17"></polyline><line x1="12" y1="12" x2="12" y2="21"></line><path d="M20.88 18.09A5 5 0 0 0 18 9h-1.26A8 8 0 1 0 3 16.29"></path></svg>', shuffle: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="16 3 21 3 21 8"></polyline><line x1="4" y1="20" x2="21" y2="3"></line><polyline points="21 16 21 21 16 21"></polyline><line x1="15" y1="15" x2="21" y2="21"></line><line x1="4" y1="4" x2="9" y2="9"></line></svg>', rewind: '<svg class="stroked" viewBox="0 0 24 24"><polygon points="11 19 2 12 11 5 11 19"></polygon><polygon points="22 19 13 12 22 5 22 19"></polygon></svg>', upload: '<svg class="stroked" viewBox="0 0 24 24"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"></path><polyline points="17 8 12 3 7 8"></polyline><line x1="12" y1="3" x2="12" y2="15"></line></svg>', trendingDown: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="23 18 13.5 8.5 8.5 13.5 1 6"></polyline><polyline points="17 18 23 18 23 12"></polyline></svg>', pause: '<svg class="stroked" viewBox="0 0 24 24"><rect x="6" y="4" width="4" height="16"></rect><rect x="14" y="4" width="4" height="16"></rect></svg>', arrowDownCircle: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><polyline points="8 12 12 16 16 12"></polyline><line x1="12" y1="8" x2="12" y2="16"></line></svg>', bookmark: '<svg class="stroked" viewBox="0 0 24 24"><path d="M19 21l-7-5-7 5V5a2 2 0 0 1 2-2h10a2 2 0 0 1 2 2z"></path></svg>', alertTriangle: '<svg class="stroked" viewBox="0 0 24 24"><path d="M10.29 3.86L1.82 18a2 2 0 0 0 1.71 3h16.94a2 2 0 0 0 1.71-3L13.71 3.86a2 2 0 0 0-3.42 0z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>', userCheck: '<svg class="stroked" viewBox="0 0 24 24"><path d="M16 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="8.5" cy="7" r="4"></circle><polyline points="17 11 19 13 23 9"></polyline></svg>', tablet: '<svg class="stroked" viewBox="0 0 24 24"><rect x="4" y="2" width="16" height="20" rx="2" ry="2"></rect><line x1="12" y1="18" x2="12.01" y2="18"></line></svg>', alertOctagon: '<svg class="stroked" viewBox="0 0 24 24"><polygon points="7.86 2 16.14 2 22 7.86 22 16.14 16.14 22 7.86 22 2 16.14 2 7.86 7.86 2"></polygon><line x1="12" y1="8" x2="12" y2="12"></line><line x1="12" y1="16" x2="12.01" y2="16"></line></svg>', menu: '<svg class="stroked" viewBox="0 0 24 24"><line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line></svg>', chrome: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><circle cx="12" cy="12" r="4"></circle><line x1="21.17" y1="8" x2="12" y2="8"></line><line x1="3.95" y1="6.06" x2="8.54" y2="14"></line><line x1="10.88" y1="21.94" x2="15.46" y2="14"></line></svg>', shoppingCart: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="9" cy="21" r="1"></circle><circle cx="20" cy="21" r="1"></circle><path d="M1 1h4l2.68 13.39a2 2 0 0 0 2 1.61h9.72a2 2 0 0 0 2-1.61L23 6H6"></path></svg>', folder: '<svg class="stroked" viewBox="0 0 24 24"><path d="M22 19a2 2 0 0 1-2 2H4a2 2 0 0 1-2-2V5a2 2 0 0 1 2-2h5l2 3h9a2 2 0 0 1 2 2z"></path></svg>', users: '<svg class="stroked" viewBox="0 0 24 24"><path d="M17 21v-2a4 4 0 0 0-4-4H5a4 4 0 0 0-4 4v2"></path><circle cx="9" cy="7" r="4"></circle><path d="M23 21v-2a4 4 0 0 0-3-3.87"></path><path d="M16 3.13a4 4 0 0 1 0 7.75"></path></svg>', cornerDownLeft: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="9 10 4 15 9 20"></polyline><path d="M20 4v7a4 4 0 0 1-4 4H4"></path></svg>', monitor: '<svg class="stroked" viewBox="0 0 24 24"><rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect><line x1="8" y1="21" x2="16" y2="21"></line><line x1="12" y1="17" x2="12" y2="21"></line></svg>', minus: '<svg class="stroked" viewBox="0 0 24 24"><line x1="5" y1="12" x2="19" y2="12"></line></svg>', helpCircle: '<svg class="stroked" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10"></circle><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"></path><line x1="12" y1="17" x2="12.01" y2="17"></line></svg>', navigation2: '<svg class="stroked" viewBox="0 0 24 24"><polygon points="12 2 19 21 12 17 5 21 12 2"></polygon></svg>', chevronLeft: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="15 18 9 12 15 6"></polyline></svg>', film: '<svg class="stroked" viewBox="0 0 24 24"><rect x="2" y="2" width="20" height="20" rx="2.18" ry="2.18"></rect><line x1="7" y1="2" x2="7" y2="22"></line><line x1="17" y1="2" x2="17" y2="22"></line><line x1="2" y1="12" x2="22" y2="12"></line><line x1="2" y1="7" x2="7" y2="7"></line><line x1="2" y1="17" x2="7" y2="17"></line><line x1="17" y1="17" x2="22" y2="17"></line><line x1="17" y1="7" x2="22" y2="7"></line></svg>', moon: '<svg class="stroked" viewBox="0 0 24 24"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>', shieldOff: '<svg class="stroked" viewBox="0 0 24 24"><path d="M19.69 14a6.9 6.9 0 0 0 .31-2V5l-8-3-3.16 1.18"></path><path d="M4.73 4.73L4 5v7c0 6 8 10 8 10a20.29 20.29 0 0 0 5.62-4.38"></path><line x1="1" y1="1" x2="23" y2="23"></line></svg>', layout: '<svg class="stroked" viewBox="0 0 24 24"><rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect><line x1="3" y1="9" x2="21" y2="9"></line><line x1="9" y1="21" x2="9" y2="9"></line></svg>', mousePointer: '<svg class="stroked" viewBox="0 0 24 24"><path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"></path><path d="M13 13l6 6"></path></svg>', alignLeft: '<svg class="stroked" viewBox="0 0 24 24"><line x1="17" y1="10" x2="3" y2="10"></line><line x1="21" y1="6" x2="3" y2="6"></line><line x1="21" y1="14" x2="3" y2="14"></line><line x1="17" y1="18" x2="3" y2="18"></line></svg>', heart: '<svg class="stroked" viewBox="0 0 24 24"><path d="M20.84 4.61a5.5 5.5 0 0 0-7.78 0L12 5.67l-1.06-1.06a5.5 5.5 0 0 0-7.78 7.78l1.06 1.06L12 21.23l7.78-7.78 1.06-1.06a5.5 5.5 0 0 0 0-7.78z"></path></svg>', trendingUp: '<svg class="stroked" viewBox="0 0 24 24"><polyline points="23 6 13.5 15.5 8.5 10.5 1 18"></polyline><polyline points="17 6 23 6 23 12"></polyline></svg>', listBullet: '<svg class="stroked" viewBox="0 0 24 24"><g><path style="" d="M21,6 C21,6,10,6,10,6"/><path style="" d="M21,12 C21,12,10,12,10,12"/><path style="" d="M21,18 C21,18,10,18,10,18"/><path style="" d="M5.5,5 C6.05,5,6.5,5.45,6.5,6 C6.5,6.55,6.05,7,5.5,7 C4.95,7,4.5,6.55,4.5,6 C4.5,5.45,4.95,5,5.5,5 z"/><path style="" d="M5.5,11 C6.05,11,6.5,11.45,6.5,12 C6.5,12.55,6.05,13,5.5,13 C4.95,13,4.5,12.55,4.5,12 C4.5,11.45,4.95,11,5.5,11 z"/><path style="" d="M5.5,17 C6.05,17,6.5,17.45,6.5,18 C6.5,18.55,6.05,19,5.5,19 C4.95,19,4.5,18.55,4.5,18 C4.5,17.45,4.95,17,5.5,17 z"/></g></svg> ', indent: '<svg class="stroked" viewBox="0 0 24 24"><g><path style="" d="M21,10 C21,10,8,10,8,10"/><path style="" d="M21,6 C21,6,8,6,8,6"/><path style="" d="M21,14 C21,14,8,14,8,14"/><path style="" d="M21,18 C21,18,8,18,8,18"/><path style="" d="M2.5,9 C2.5,9,5.5,12,5.5,12 C5.5,12,2.5,15,2.5,15"/></g></svg> ', fontBold: '<svg class="stroked" viewBox="0 0 24 24"><g><path style="" d="M13.5,11 C15.71,11,17.5,12.68,17.5,14.75 C17.5,16.82,15.71,18.5,13.5,18.5 C13.5,18.5,8.5,18.5,8.5,18.5 C8.5,18.5,8.5,3.5,8.5,3.5 C8.5,3.5,13.5,3.5,13.5,3.5 C15.71,3.5,17.5,5.18,17.5,7.25 C17.5,9.32,15.71,11,13.5,11 C13.5,11,13.5,11,13.5,11 z"/><path style="" d="M13.5,11 C13.5,11,8.5,11,8.5,11"/><path style="" d="M12.5,11 C14.71,11,16.5,12.68,16.5,14.75 C16.5,16.82,14.71,18.5,12.5,18.5 C12.5,18.5,7.5,18.5,7.5,18.5 C7.5,18.5,7.5,3.5,7.5,3.5 C7.5,3.5,12.5,3.5,12.5,3.5 C14.71,3.5,16.5,5.18,16.5,7.25 C16.5,9.32,14.71,11,12.5,11 C12.5,11,12.5,11,12.5,11 z"/><path style="" d="M12.5,11 C12.5,11,7.5,11,7.5,11"/></g></svg> ', fontItalic: '<svg class="stroked" viewBox="0 0 24 24"><g><path style="" d="M17.00,4.50 C17.00,4.50,13.00,4.50,13.00,4.50"/><path style="" d="M11.00,19.50 C11.00,19.50,7.00,19.50,7.00,19.50"/><path style="" d="M15.00,4.50 C15.00,4.50,9.00,19.50,9.00,19.50"/></g></svg> ', fontUnderline: '<svg class="stroked" viewBox="0 0 24 24"><g><path style="" d="M7.5,3.5 C7.5,3.5,7.5,10.74,7.5,13.5 C7.5,16.26,9.74,18.5,12.5,18.5 C15.26,18.5,17.5,16.26,17.5,13.5 C17.5,10.74,17.5,3.5,17.5,3.5"/><path style="" d="M7.5,21.5 C7.5,21.5,17.5,21.5,17.5,21.5"/></g></svg> ', outdent: '<svg class="stroked" viewBox="0 0 24 24"><g><path style="" d="M21,10 C21,10,8,10,8,10"/><path style="" d="M21,6 C21,6,8,6,8,6"/><path style="" d="M21,14 C21,14,8,14,8,14"/><path style="" d="M21,18 C21,18,8,18,8,18"/><path style="" d="M5.5,9 C5.5,9,2.5,12,2.5,12 C2.5,12,5.5,15,5.5,15"/></g></svg> ', listNumber: '<svg class="stroked" viewBox="0 0 24 24"><g><path style="" d="M21,6 C21,6,10,6,10,6"/><path style="" d="M21,12 C21,12,10,12,10,12"/><path style="" d="M21,18 C21,18,10,18,10,18"/><path style="" d="M4.5,5 C4.5,5,5.5,4,5.5,4 C5.5,4,5.5,8,5.5,8"/><path style="" d="M4.5,10 C4.5,10,5.50,10,5.50,10 C6.05,10,6.5,10.45,6.5,11.00 C6.5,11.00,6.5,11.00,6.5,11.00 C6.5,11.55,6.05,12,5.50,12 C5.50,12,5.50,12,5.50,12 C4.95,12,4.5,12.45,4.5,13.00 C4.5,13.00,4.5,14,4.5,14 C4.5,14,6.5,14,6.5,14"/><path style="" d="M4.5,16 C4.5,16,5.50,16,5.50,16 C6.05,16,6.5,16.45,6.5,17.00 C6.5,17.00,6.5,17.00,6.5,17.00 C6.5,17.55,6.05,18,5.50,18 C5.50,18,4.5,18,4.5,18 C4.5,18,5.50,18,5.50,18 C6.05,18,6.5,18.45,6.5,19.00 C6.5,19.00,6.5,19.00,6.5,19.00 C6.5,19.55,6.05,20,5.50,20 C5.50,20,4.5,20,4.5,20"/></g></svg> ', resize: '<svg class="stroked" version="1.1" viewBox="0, 0, 24, 24"><g><path d="M9,3 L3,3 L3,9"/><path d="M15,21 L21,21 L21,15"/><path d="M3,3 L10,10"/><path d="M21,21 L14,14"/></g></svg> ', bug: '<svg class="stroked" viewBox="0 0 24 24"><g><path style="" d="M8,6 C8,3.79,9.79,2,12,2 C14.21,2,16,3.79,16,6 C16,6,8,6,8,6 z"/><path style="" d="M20,7 C20,7,18,9,18,9"/><path style="" d="M20,19 C20,19,18,17,18,17"/><path style="" d="M21,13 C21,13,18,13,18,13"/><path style="" d="M16.44,9 C17.30,9,18.00,9.70,18.00,10.56 C18.00,10.56,18.00,15.00,18.00,15.00 C18.00,18.31,15.31,21,12,21 C8.69,21,6,18.31,6,15.00 C6,15.00,6,10.56,6,10.56 C6,9.70,6.70,9,7.56,9 C7.56,9,16.44,9,16.44,9 z"/><path style="" d="M4,7 C4,7,6,9,6,9"/><path style="" d="M4,19 C4,19,6,17,6,17"/><path style="" d="M3,13 C3,13,6,13,6,13"/><path style="" d="M12,12 C12,12,12,17,12,17"/></g></svg> ', blog: '<svg class="stroked" viewBox="0 0 24 24"><g><path style="" d="M21,10.02 C21,10.02,21,15,21,15 C21,15.53,20.79,16.04,20.41,16.41 C20.04,16.79,19.53,17,19,17 C19,17,7,17,7,17 C5.67,18.33,4.33,19.67,3,21 C3,21,3,5,3,5 C3,4.47,3.21,3.96,3.59,3.59 C3.96,3.21,4.47,3,5,3 C8.53,3,10.49,3,14.02,3"/><path style="" d="M19,2 C19.54,1.46,20.32,1.25,21.05,1.45 C21.78,1.65,22.35,2.22,22.55,2.95 C22.75,3.68,22.54,4.46,22,5 C22,5,15.5,11.5,15.5,11.5 C14.17,11.83,12.83,12.17,11.5,12.5 C11.83,11.17,12.17,9.83,12.5,8.5 C15.67,5.33,15.83,5.17,19,2 z"/><path style="" d="M14.60,3"/><path style="" d="M21,8.77"/><path style="" d="M7,7 C7,7,10,7,10,7"/><path style="" d="M7,10 C7,10,9,10,9,10"/></g></svg> ', sortAscending: '<svg class="stroked" viewBox="0 0 24 24"><g><path d="M16.5,10.5 C16.5,10.5,7.5,10.5,7.5,10.5"/><path d="M14.5,6.5 C14.5,6.5,9.5,6.5,9.5,6.5"/><path d="M18.5,14.5 C18.5,14.5,5.5,14.5,5.5,14.5"/><path d="M20.5,18.5 C20.5,18.5,3.5,18.5,3.5,18.5"/></g></svg> ', npm: '<svg class="filled" version="1.1" viewBox="0 0 512 512"><g></g><path d="M0 0v512h512v-512h-512zM416 416h-64v-256h-96v256h-160v-320h320v320z"></path></svg> ', game: '<svg class="filled" version="1.1" viewBox="0 0 704 512"><g></g><path d="M528 96.79v-0.79h-336c-88.36 0-160 71.64-160 160s71.64 160 160 160c52.34 0 98.82-25.14 128.01-64h63.98c29.19 38.86 75.66 64 128.01 64 88.37 0 160-71.63 160-160 0-82.97-63.15-151.18-144-159.21zM288 288h-64v64h-64v-64h-64v-64h64v-64h64v64h64v64zM480 288c-17.67 0-32-14.33-32-32s14.33-32 32-32 32 14.33 32 32-14.33 32-32 32zM576 288c-17.67 0-32-14.33-32-32 0-17.67 14.33-32 32-32s32 14.33 32 32c0 17.67-14.33 32-32 32z"></path></svg> ', google: '<svg class="filled" version="1.1" viewBox="0 0 512 512"><g></g><path d="M256 0c-141.4 0-256 114.6-256 256s114.6 256 256 256 256-114.6 256-256-114.6-256-256-256zM259.8 448c-106.1 0-192-85.9-192-192s85.9-192 192-192c51.8 0 95.2 18.9 128.6 50.2l-52.1 50.2c-14.3-13.7-39.2-29.6-76.5-29.6-65.6 0-119 54.3-119 121.2s53.5 121.2 119 121.2c76 0 104.5-54.6 108.9-82.8h-108.9v-65.8h181.3c1.6 9.6 3 19.2 3 31.8 0.1 109.7-73.4 187.6-184.3 187.6z"></path></svg> ', discord: '<svg class="filled" version="1.1" viewBox="0 0 1013 768"><g></g><path d="M858.38 64.32c-60.41-28.44-130.58-50.8-204.05-63.60l-5.01-0.72c-8.35 14.47-17.31 32.35-25.34 50.74l-1.44 3.7c-34.87-5.53-75.06-8.69-116.00-8.69s-81.14 3.16-120.37 9.25l4.37-0.56c-9.48-22.09-18.44-39.97-28.27-57.29l1.49 2.86c-78.56 13.64-148.78 36.05-214.41 66.65l5.19-2.17c-132.30 195.75-168.17 386.63-150.24 574.80v0c73.25 54.65 158.46 98.55 250.43 127.12l5.97 1.60c19.28-25.64 37.51-54.63 53.29-85.10l1.63-3.45c-33.48-12.62-61.98-26.51-88.96-42.66l2.48 1.38c7.25-5.26 14.35-10.68 21.2-15.94 75.07 36.14 163.23 57.26 256.32 57.26s181.25-21.12 259.94-58.83l-3.62 1.56c6.93 5.66 14.03 11.08 21.2 15.94-24.54 14.80-53.09 28.72-82.88 40.10l-3.75 1.26c17.37 33.87 35.61 62.84 56.05 90.05l-1.14-1.58c98.00-30.05 183.28-73.93 258.78-130.22l-2.22 1.58c21.04-218.22-35.95-407.35-150.63-575.04zM338.33 523.56c-49.97 0-91.26-45.35-91.26-101.14s39.85-101.54 91.10-101.54 92.21 45.75 91.34 101.54-40.25 101.14-91.18 101.14zM674.99 523.56c-50.05 0-91.18-45.35-91.18-101.14s39.85-101.54 91.18-101.54 91.97 45.75 91.10 101.54-40.17 101.14-91.10 101.14z"></path></svg> ' };
var pt = (e, t, i, o) => {
  e.setAttribute("xmlns", "http://www.w3.org/2000/svg");
  for (let l of [...e.querySelectorAll("path, polygon, line, circle, rect, ellipse, polyline")]) {
    if (t !== undefined)
      l.setAttribute("fill", t);
    if (i !== undefined)
      l.setAttribute("stroke", i);
    if (o !== undefined)
      l.setAttribute("stroke-width", String(o));
  }
  let s = e.querySelectorAll("[style]");
  e.removeAttribute("style");
  for (let l of [...s]) {
    let { fill: a2, stroke: r, strokeWidth: p, strokeLinecap: h2, strokeLinejoin: d } = l.style;
    if (a2)
      l.setAttribute("fill", a.fromCss(a2).html);
    if (r)
      l.setAttribute("stroke", a.fromCss(r).html);
    if (p)
      l.setAttribute("strokeWidth", p);
    if (h2)
      l.setAttribute("strokeLinecap", h2);
    if (d)
      l.setAttribute("strokeLinejoin", d);
    l.removeAttribute("style");
  }
  return `url(data:image/svg+xml;charset=UTF-8,${encodeURIComponent(e.outerHTML)})`;
};
var c = new Proxy(ae3, { get(e, t) {
  let i = ae3[t];
  if (t && !i)
    console.warn(`icon ${t} does not exist`);
  if (!i)
    i = ae3.square;
  return (...o) => {
    let s = m.div();
    s.innerHTML = i;
    let n = s.querySelector("svg"), l = new Set(n.classList);
    l.add("xin-icon");
    let a2 = Bn.svg({ class: Array.from(l).join(" "), viewBox: n.getAttribute("viewBox") }, ...o, ...n.children);
    return a2.style.strokeWidth = sn.xinIconStrokeWidth("2px"), a2.style.stroke = sn.xinIconStroke(l.has("filled") ? "none" : "currentColor"), a2.style.fill = sn.xinIconFill(l.has("stroked") ? "none" : "currentColor"), a2.style.height = sn.xinIconSize("16px"), a2;
  };
} });

class dt extends B {
  icon = "";
  size = 0;
  fill = "";
  stroke = "";
  strokeWidth = 1;
  constructor() {
    super();
    this.initAttributes("icon", "size", "fill", "stroke", "strokeWidth");
  }
  render() {
    super.render(), this.textContent = "";
    let e = {};
    if (this.size)
      e.height = this.size + "px", this.style.setProperty("--xin-icon-size", `${this.size}px`);
    if (this.stroke)
      e.stroke = this.stroke, e.strokeWidth = this.strokeWidth;
    e.fill = this.fill, this.append(c[this.icon]({ style: e }));
  }
}
var u1 = dt.elementCreator({ tag: "xin-icon", styleSpec: { ":host": { display: "inline-flex", stroke: "currentColor", strokeWidth: sn.iconStrokeWidth("2px"), strokeLinejoin: sn.iconStrokeLinejoin("round"), strokeLinecap: sn.iconStrokeLinecap("round"), fill: sn.iconFill("none") }, ":host, :host svg": { height: sn.xinIconSize("16px") } } });
var ht = () => {};

class ut extends B {
  babylonReady;
  BABYLON;
  static styleSpec = { ":host": { display: "block", position: "relative" }, ":host canvas": { width: "100%", height: "100%" }, ":host .babylonVRicon": { height: 50, width: 80, backgroundColor: "transparent", filter: "drop-shadow(0 0 4px #000c)", backgroundImage: pt(c.xrColor()), backgroundPosition: "center", backgroundRepeat: "no-repeat", border: "none", borderRadius: 5, borderStyle: "none", outline: "none", transition: "transform 0.125s ease-out" }, ":host .babylonVRicon:hover": { transform: "scale(1.1)" } };
  content = m.canvas({ part: "canvas" });
  constructor() {
    super();
    this.babylonReady = (async () => {
      let { BABYLON: e } = await L3("https://cdn.babylonjs.com/babylon.js", "BABYLON");
      return e;
    })();
  }
  scene;
  engine;
  sceneCreated = ht;
  update = ht;
  _update = () => {
    if (this.scene) {
      if (this.update !== undefined)
        this.update(this, this.BABYLON);
      if (this.scene.activeCamera !== undefined)
        this.scene.render();
    }
  };
  onResize() {
    if (this.engine)
      this.engine.resize();
  }
  loadScene = async (e, t, i) => {
    let { BABYLON: o } = await L3("https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js", "BABYLON");
    o.SceneLoader.Append(e, t, this.scene, i);
  };
  loadUI = async (e) => {
    let { BABYLON: t } = await L3("https://cdn.babylonjs.com/gui/babylon.gui.min.js", "BABYLON"), i = t.GUI.AdvancedDynamicTexture.CreateFullscreenUI("GUI", true, this.scene), { snippetId: o, jsonUrl: s, data: n, size: l } = e;
    if (l)
      i.idealWidth = l, i.renderAtIdealSize = true;
    let a2;
    if (o)
      a2 = await i.parseFromSnippetAsync(o);
    else if (s)
      a2 = await i.parseFromURLAsync(s);
    else if (n)
      a2 = i.parseContent(n);
    else
      return null;
    let r = i.getChildren()[0], p = r.children.reduce((h2, d) => {
      return h2[d.name] = d, h2;
    }, {});
    return { advancedTexture: i, gui: a2, root: r, widgets: p };
  };
  connectedCallback() {
    super.connectedCallback();
    let { canvas: e } = this.parts;
    this.babylonReady.then(async (t) => {
      if (this.BABYLON = t, this.engine = new t.Engine(e, true), this.scene = new t.Scene(this.engine), this.sceneCreated)
        await this.sceneCreated(this, t);
      if (this.scene.activeCamera === undefined)
        new t.ArcRotateCamera("default-camera", -Math.PI / 2, Math.PI / 2.5, 3, new t.Vector3(0, 0, 0)).attachControl(this.parts.canvas, true);
      this.engine.runRenderLoop(this._update);
    });
  }
}
var m1 = ut.elementCreator({ tag: "xin-3d" });

class re3 extends B {
  content = null;
  src = "";
  json = "";
  config = { renderer: "svg", loop: true, autoplay: true };
  static bodymovinAvailable;
  animation;
  static styleSpec = { ":host": { width: 400, height: 400, display: "inline-block" } };
  _loading = false;
  get loading() {
    return this._loading;
  }
  constructor() {
    super();
    if (this.initAttributes("src", "json"), re3.bodymovinAvailable === undefined)
      re3.bodymovinAvailable = L3("https://cdnjs.cloudflare.com/ajax/libs/bodymovin/5.12.2/lottie.min.js", "bodymovin");
  }
  doneLoading = () => {
    this._loading = false;
  };
  load = ({ bodymovin: e }) => {
    if (this._loading = true, this.config.container = this.shadowRoot !== null ? this.shadowRoot : undefined, this.json !== "")
      this.config.animationData = this.json, delete this.config.path;
    else if (this.src !== "")
      delete this.config.animationData, this.config.path = this.src;
    else
      console.log("%c<xin-lottie>%c expected either %cjson%c (animation data) or %csrc% c(url) but found neither.", "color: #44f; background: #fff; padding: 0 5px", "color: default", "color: #44f; background: #fff; padding: 0 5px", "color: default", "color: #44f; background: #fff; padding: 0 5px", "color: default");
    if (this.animation) {
      this.animation.destroy();
      let t = this.shadowRoot;
      if (t !== null)
        t.querySelector("svg")?.remove();
    }
    this.animation = e.loadAnimation(this.config), this.animation.addEventListener("DOMLoaded", this.doneLoading);
  };
  render() {
    super.render(), re3.bodymovinAvailable.then(this.load).catch((e) => {
      console.error(e);
    });
  }
}
var M1 = re3.elementCreator({ tag: "xin-lottie" });
var { button: Te3, slot: Vi, div: ge3 } = m;

class yt extends B {
  arrows = false;
  dots = false;
  loop = false;
  maxVisibleItems = 1;
  snapDelay = 0.1;
  snapDuration = 0.25;
  auto = 0;
  lastAutoAdvance = Date.now();
  interval;
  autoAdvance = () => {
    if (this.auto > 0 && this.auto * 1000 < Date.now() - this.lastAutoAdvance)
      this.forward();
  };
  _page = 0;
  get page() {
    return this._page;
  }
  set page(e) {
    let { scroller: t, back: i, forward: o } = this.parts;
    if (this.lastPage <= 0)
      o.disabled = i.disabled = true, e = 0;
    else
      e = Math.max(0, Math.min(this.lastPage, e)), e = isNaN(e) ? 0 : e;
    if (this._page !== e)
      this._page = isNaN(e) ? 0 : e, this.animateScroll(this._page * t.offsetWidth), i.disabled = this.page <= 0 && !this.loop, o.disabled = this.page >= this.lastPage && !this.loop;
  }
  get visibleItems() {
    return [...this.children].filter((e) => getComputedStyle(e).display !== "none");
  }
  get lastPage() {
    return Math.max(Math.ceil(this.visibleItems.length / (this.maxVisibleItems || 1)) - 1, 0);
  }
  static styleSpec = { ":host": { display: "flex", flexDirection: "column", position: "relative" }, ":host svg": { height: On.carouselIconSize }, ":host button": { outline: "none", border: "none", boxShadow: "none", background: "transparent", color: On.carouselButtonColor, padding: 0 }, ":host::part(back), :host::part(forward)": { position: "absolute", top: 0, bottom: 0, width: On.carouseButtonWidth, zIndex: 2 }, ":host::part(back)": { left: 0 }, ":host::part(forward)": { right: 0 }, ":host button:disabled": { opacity: 0.5, pointerEvents: "none" }, ":host button:hover": { color: On.carouselButtonHoverColor }, ":host button:active": { color: On.carouselButtonActiveColor }, ":host::part(pager)": { position: "relative" }, ":host::part(scroller)": { overflow: "auto hidden", position: "relative" }, ":host::part(grid)": { display: "grid", justifyItems: "center" }, ":host *::-webkit-scrollbar, *::-webkit-scrollbar-thumb": { display: "none" }, ":host .dot": { background: On.carouselButtonColor, borderRadius: On.carouselDotSize, height: On.carouselDotSize, width: On.carouselDotSize, transition: On.carouselDotTransition }, ":host .dot:not(.current):hover": { background: On.carouselButtonHoverColor, height: On.carouselDotSize150, width: On.carouselDotSize150, margin: On.carouselDotSize_25 }, ":host .dot:not(.current):active": { background: On.carouselButtonActiveColor }, ":host .dot.current": { background: On.carouselDotCurrentColor }, ":host::part(progress)": { display: "flex", gap: On.carouselDotSpacing, justifyContent: "center", padding: On.carouselProgressPadding } };
  easing = (e) => {
    return Math.sin(e * Math.PI * 0.5);
  };
  indicateCurrent = () => {
    let { scroller: e, progress: t } = this.parts, i = e.scrollLeft / e.offsetWidth;
    [...t.children].forEach((o, s) => {
      o.classList.toggle("current", Math.floor(s / this.maxVisibleItems - i) === 0);
    }), this.lastAutoAdvance = Date.now(), clearTimeout(this.snapTimer), this.snapTimer = setTimeout(this.snapPosition, this.snapDelay * 1000);
  };
  snapPosition = () => {
    let { scroller: e } = this.parts, t = Math.round(e.scrollLeft / e.offsetWidth);
    if (t !== this.page)
      this.page = t > this.page ? Math.ceil(t) : Math.floor(t);
    this.lastAutoAdvance = Date.now();
  };
  back = () => {
    this.page = this.page > 0 ? this.page - 1 : this.lastPage;
  };
  forward = () => {
    this.page = this.page < this.lastPage ? this.page + 1 : 0;
  };
  handleDotClick = (e) => {
    let { progress: t } = this.parts, i = [...t.children].indexOf(e.target);
    if (i > -1)
      this.page = Math.floor(i / this.maxVisibleItems);
  };
  snapTimer;
  animationFrame;
  animateScroll(e, t = -1, i = 0) {
    cancelAnimationFrame(this.animationFrame);
    let { scroller: o } = this.parts;
    if (t === -1) {
      t = o.scrollLeft, i = Date.now(), this.animationFrame = requestAnimationFrame(() => {
        this.animateScroll(e, t, i);
      });
      return;
    }
    let s = (Date.now() - i) / 1000;
    if (s >= this.snapDuration || Math.abs(o.scrollLeft - e) < 2)
      o.scrollLeft = e, this.animationFrame = null;
    else
      o.scrollLeft = t + this.easing(s / this.snapDuration) * (e - t), this.animationFrame = requestAnimationFrame(() => {
        this.animateScroll(e, t, i);
      });
  }
  content = () => [ge3({ part: "pager" }, Te3({ title: "previous slide", part: "back" }, c.chevronLeft()), ge3({ title: "slides", role: "group", part: "scroller" }, ge3({ part: "grid" }, Vi())), Te3({ title: "next slide", part: "forward" }, c.chevronRight())), ge3({ title: "choose slide to display", role: "group", part: "progress" })];
  constructor() {
    super();
    this.initAttributes("dots", "arrows", "maxVisibleItems", "snapDuration", "loop", "auto");
  }
  connectedCallback() {
    super.connectedCallback(), this.ariaRoleDescription = "carousel", this.ariaOrientation = "horizontal", this.ariaReadOnly = "true";
    let { back: e, forward: t, scroller: i, progress: o } = this.parts;
    e.addEventListener("click", this.back), t.addEventListener("click", this.forward), i.addEventListener("scroll", this.indicateCurrent), o.addEventListener("click", this.handleDotClick), this.lastAutoAdvance = Date.now(), this.interval = setInterval(this.autoAdvance, 100);
  }
  disconnectedCallback() {
    clearInterval(this.interval);
  }
  render() {
    super.render();
    let { dots: e, arrows: t, visibleItems: i, lastPage: o } = this, { progress: s, back: n, forward: l, grid: a2 } = this.parts;
    i.forEach((r) => {
      r.role = "group";
    }), a2.style.gridTemplateColumns = `${100 / this.maxVisibleItems / (1 + this.lastPage)}% `.repeat(i.length).trim(), a2.style.width = (1 + this.lastPage) * 100 + "%", s.textContent = "", s.append(...i.map((r, p) => Te3({ title: `item ${p + 1}`, class: "dot" }))), this.indicateCurrent(), s.style.display = e && o > 0 ? "" : "none", n.hidden = l.hidden = !(t && o > 0);
  }
}
var A1 = yt.elementCreator({ tag: "xin-carousel", styleSpec: { ":host": { _carouselIconSize: 24, _carouselButtonColor: "#0004", _carouselButtonHoverColor: "#0006", _carouselButtonActiveColor: "#000c", _carouseButtonWidth: 48, _carouselDotCurrentColor: "#0008", _carouselDotSize: 8, _carouselDotSpacing: On.carouselDotSize, _carouselProgressPadding: 12, _carouselDotTransition: "0.125s ease-in-out" }, ":host:focus": { outline: "none", boxShadow: "none" } } });
var xt = "https://cdnjs.cloudflare.com/ajax/libs/ace/1.23.2/";
var gt = "ace/theme/tomorrow";
var qi = async () => {
  let { ace: e } = await L3(`${xt}ace.min.js`);
  return e;
};
var _i = async (e, t = "html", i = {}, o = gt) => {
  let s = await qi();
  s.config.set("basePath", xt);
  let n = s.edit(e, { mode: `ace/mode/${t}`, tabSize: 2, useSoftTabs: true, useWorker: false, ...i });
  return n.setTheme(o), { ace: s, editor: n };
};

class Q3 extends B {
  source = "";
  get value() {
    return this.editor === undefined ? this.source : this.editor.getValue();
  }
  set value(e) {
    if (this.editor === undefined)
      this.source = e;
    else
      this.editor.setValue(e), this.editor.clearSelection(), this.editor.session.getUndoManager().reset();
  }
  mode = "javascript";
  disabled = false;
  role = "code editor";
  _ace;
  _editor;
  _editorPromise;
  options = {};
  theme = gt;
  get ace() {
    return this._ace;
  }
  get editor() {
    return this._editor;
  }
  static styleSpec = { ":host": { display: "block", position: "relative", width: "100%", height: "100%" } };
  constructor() {
    super();
    this.initAttributes("mode", "theme", "disabled");
  }
  onResize() {
    if (this.editor !== undefined)
      this.editor.resize(true);
  }
  connectedCallback() {
    if (super.connectedCallback(), this.source === "")
      this.value = this.textContent !== null ? this.textContent.trim() : "";
    if (this._editorPromise === undefined)
      this._editorPromise = _i(this, this.mode, this.options, this.theme), this._editorPromise.then(({ ace: e, editor: t }) => {
        this._ace = e, this._editor = t, t.setValue(this.source, 1), t.clearSelection(), t.session.getUndoManager().reset();
      });
  }
  render() {
    if (super.render(), this._editorPromise !== undefined)
      this._editorPromise.then(({ editor: e }) => e.setReadOnly(this.disabled));
  }
}
var fe3 = Q3.elementCreator({ tag: "xin-code" });
var { input: Pe3 } = m;
var ft = a.fromCss("#8888");

class vt extends B {
  value = ft.rgba;
  color = ft;
  static styleSpec = { ":host": { _gap: 8, _swatchSize: 32, _cssWidth: 72, _alphaWidth: 72, display: "inline-flex", gap: On.gap, alignItems: "center" }, ':host input[type="color"]': { border: 0, width: On.swatchSize, height: On.swatchSize, background: "transparent" }, ":host::part(alpha)": { width: On.alphaWidth }, ":host::part(css)": { width: On.cssWidth, fontFamily: "monospace" } };
  content = [Pe3({ title: "base color", type: "color", part: "rgb" }), Pe3({ type: "range", title: "opacity", part: "alpha", min: 0, max: 1, step: 0.05 }), Pe3({ title: "css color spec", part: "css" })];
  valueChanged = false;
  update = (e) => {
    let { rgb: t, alpha: i, css: o } = this.parts;
    if (e.type === "input")
      this.color = a.fromCss(t.value), this.color.a = Number(i.value), o.value = this.color.html;
    else
      this.color = a.fromCss(o.value), t.value = this.color.html.substring(0, 7), i.value = String(this.color.a);
    t.style.opacity = String(this.color.a), this.value = this.color.rgba, this.valueChanged = true;
  };
  connectedCallback() {
    super.connectedCallback();
    let { rgb: e, alpha: t, css: i } = this.parts;
    e.addEventListener("input", this.update), t.addEventListener("input", this.update), i.addEventListener("change", this.update);
  }
  render() {
    if (this.valueChanged) {
      this.valueChanged = false;
      return;
    }
    let { rgb: e, alpha: t, css: i } = this.parts;
    this.color = a.fromCss(this.value), e.value = this.color.html.substring(0, 7), e.style.opacity = String(this.color.a), t.value = String(this.color.a), i.value = this.color.html;
  }
}
var mt = vt.elementCreator({ tag: "xin-color" });
var V3 = m.div({ style: { content: " ", position: "fixed", top: 0, left: 0, right: 0, bottom: 0 } });
var me3 = { passive: true };
var z3 = (e, t, i = "move") => {
  if (!e.type.startsWith("touch")) {
    let { clientX: s, clientY: n } = e;
    V3.style.cursor = i, _3(V3), document.body.append(V3);
    let l = (a2) => {
      let r = a2.clientX - s, p = a2.clientY - n;
      if (t(r, p, a2) === true)
        V3.removeEventListener("mousemove", l), V3.removeEventListener("mouseup", l), V3.remove();
    };
    V3.addEventListener("mousemove", l, me3), V3.addEventListener("mouseup", l, me3);
  } else if (e instanceof TouchEvent) {
    let s = e.changedTouches[0], n = s.identifier, l = s.clientX, a2 = s.clientY, r = e.target, p = 0, h2 = 0, d = (g2) => {
      let v3 = [...g2.touches].find((H2) => H2.identifier === n);
      if (v3 !== undefined)
        p = v3.clientX - l, h2 = v3.clientY - a2;
      if (g2.type === "touchmove")
        g2.stopPropagation(), g2.preventDefault();
      if (t(p, h2, g2) === true || v3 === undefined)
        r.removeEventListener("touchmove", d), r.removeEventListener("touchend", d), r.removeEventListener("touchcancel", d);
    };
    r.addEventListener("touchmove", d), r.addEventListener("touchend", d, me3), r.addEventListener("touchcancel", d, me3);
  }
};
var X3 = (e = "body *") => [...document.querySelectorAll(e)].map((t) => parseFloat(getComputedStyle(t).zIndex)).reduce((t, i) => isNaN(t) || Number(t) < i ? i : Number(t), 0);
var _3 = (e, t = "body *") => {
  e.style.zIndex = String(X3(t) + 1);
};
var { slot: Gi } = m;

class N3 extends B {
  static floats = new Set;
  drag = false;
  remainOnResize = "remove";
  remainOnScroll = "remain";
  content = Gi();
  static styleSpec = { ":host": { position: "fixed" } };
  constructor() {
    super();
    this.initAttributes("drag", "remainOnResize", "remainOnScroll");
  }
  reposition = (e) => {
    if (e.target?.closest(".no-drag"))
      return;
    if (this.drag) {
      _3(this);
      let i = this.offsetLeft, o = this.offsetTop;
      z3(e, (s, n, l) => {
        if (this.style.left = `${i + s}px`, this.style.top = `${o + n}px`, this.style.right = "auto", this.style.bottom = "auto", l.type === "mouseup")
          return true;
      });
    }
  };
  connectedCallback() {
    super.connectedCallback(), N3.floats.add(this);
    let e = { passive: true };
    this.addEventListener("touchstart", this.reposition, e), this.addEventListener("mousedown", this.reposition, e), _3(this);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), N3.floats.delete(this);
  }
}
var Ie3 = N3.elementCreator({ tag: "xin-float" });
window.addEventListener("resize", () => {
  Array.from(N3.floats).forEach((e) => {
    if (e.remainOnResize === "hide")
      e.hidden = true;
    else if (e.remainOnResize === "remove")
      e.remove();
  });
}, { passive: true });
document.addEventListener("scroll", (e) => {
  if (e.target instanceof HTMLElement && e.target.closest(N3.tagName))
    return;
  Array.from(N3.floats).forEach((t) => {
    if (t.remainOnScroll === "hide")
      t.hidden = true;
    else if (t.remainOnScroll === "remove")
      t.remove();
  });
}, { passive: true, capture: true });
var bt = (e) => {
  let { content: t, target: i, position: o, remainOnScroll: s, remainOnResize: n, draggable: l } = e, a2 = Array.isArray(t) ? Ie3(...t) : Ie3(t);
  if (Ki(a2, i, o, s, n, l), e.class)
    a2.setAttribute("class", e.class);
  return document.body.append(a2), a2;
};
var Ki = (e, t, i, o, s, n = false) => {
  {
    let { position: H2 } = getComputedStyle(e);
    if (H2 !== "fixed")
      e.style.position = "fixed";
    if (s)
      e.remainOnResize = s;
    if (o)
      e.remainOnScroll = o;
    _3(e);
  }
  e.drag = n;
  let { left: l, top: a2, width: r, height: p } = t.getBoundingClientRect(), h2 = l + r * 0.5, d = a2 + p * 0.5, g2 = window.innerWidth, v3 = window.innerHeight;
  if (i === "side")
    i = (h2 < g2 * 0.5 ? "e" : "w") + (d < v3 * 0.5 ? "s" : "n");
  else if (i === "auto" || i === undefined)
    i = (d < v3 * 0.5 ? "s" : "n") + (h2 < g2 * 0.5 ? "e" : "w");
  if (e.style.top = e.style.left = e.style.right = e.style.bottom = e.style.transform = "", i.length === 2) {
    let [H2, ne2] = i;
    switch (H2) {
      case "n":
        e.style.bottom = (v3 - a2).toFixed(2) + "px";
        break;
      case "e":
        e.style.left = (l + r).toFixed(2) + "px";
        break;
      case "s":
        e.style.top = (a2 + p).toFixed(2) + "px";
        break;
      case "w":
        e.style.right = (g2 - l).toFixed(2) + "px";
        break;
    }
    switch (ne2) {
      case "n":
        e.style.bottom = (v3 - a2 - p).toFixed(2) + "px";
        break;
      case "e":
        e.style.left = l.toFixed(2) + "px";
        break;
      case "s":
        e.style.top = a2.toFixed(2) + "px";
        break;
      case "w":
        e.style.right = (g2 - l - r).toFixed(2) + "px";
        break;
    }
    e.style.transform = "";
  } else if (i === "n")
    e.style.bottom = (v3 - a2).toFixed(2) + "px", e.style.left = h2.toFixed(2) + "px", e.style.transform = "translateX(-50%)";
  else if (i === "s")
    e.style.top = (a2 + p).toFixed(2) + "px", e.style.left = h2.toFixed(2) + "px", e.style.transform = "translateX(-50%)";
  else if (i === "e")
    e.style.left = (l + r).toFixed(2) + "px", e.style.top = d.toFixed(2) + "px", e.style.transform = "translateY(-50%)";
  else if (i === "w")
    e.style.right = (g2 - l).toFixed(2) + "px", e.style.top = d.toFixed(2) + "px", e.style.transform = "translateY(-50%)";
  e.style.setProperty("--max-height", `calc(100vh - ${e.style.top || e.style.bottom})`), e.style.setProperty("--max-width", `calc(100vw - ${e.style.left || e.style.right})`);
};
function Oe3(e, t = true) {
  return (i, o) => {
    let s = e(i), n = e(o);
    for (let l in s)
      if (s[l] !== n[l])
        return (Array.isArray(t) ? t[l] !== false : t) ? s[l] > n[l] ? 1 : -1 : s[l] > n[l] ? -1 : 1;
    return 0;
  };
}
var { button: Zi, span: kt, input: Yi } = m;
var Ct = (e, t) => {
  return !!e.find((i) => {
    if (i === null || t == null)
      return false;
    else if (Array.isArray(i))
      return Ct(i, t);
    else if (i.value === t || i === t)
      return true;
  });
};

class Z2 extends B {
  editable = false;
  showIcon = false;
  hideCaption = false;
  options = "";
  value = "";
  placeholder = "";
  filter = "";
  localized = false;
  disabled = false;
  setValue = (e, t = false) => {
    if (this.value !== e)
      this.value = e;
    if (t)
      this.dispatchEvent(new Event("action"));
  };
  getValue = () => this.value;
  get selectOptions() {
    return typeof this.options === "string" ? this.options.split(",").map((e) => e.trim() || null) : this.options;
  }
  buildOptionMenuItem = (e) => {
    if (e === null)
      return null;
    let { setValue: t, getValue: i } = this, o, s, n;
    if (typeof e === "string")
      s = n = e;
    else
      ({ icon: o, caption: s, value: n } = e);
    if (this.localized)
      s = f2(s);
    let { options: l } = e;
    if (l)
      return { icon: o, caption: s, checked: () => Ct(l, i()), menuItems: l.map(this.buildOptionMenuItem) };
    return { icon: o, caption: s, checked: () => i() === n, action: typeof n === "function" ? async () => {
      let a2 = await n();
      if (a2 !== undefined)
        t(a2, true);
    } : () => {
      if (typeof n === "string")
        t(n, true);
    } };
  };
  get optionsMenu() {
    let e = this.selectOptions.map(this.buildOptionMenuItem);
    if (this.filter === "")
      return e;
    let t = (i) => {
      if (i === null)
        return true;
      else if (i.menuItems)
        return i.menuItems = i.menuItems.filter(t), i.menuItems.length > 0;
      else
        return i.caption.toLocaleLowerCase().includes(this.filter);
    };
    return e.filter(t);
  }
  handleChange = (e) => {
    let { value: t } = this.parts, i = t.value || "";
    if (this.value !== String(i))
      this.value = i, this.dispatchEvent(new Event("change"));
    this.filter = "", e.stopPropagation(), e.preventDefault();
  };
  handleKey = (e) => {
    if (e.key === "Enter")
      e.preventDefault();
  };
  filterMenu = en(() => {
    this.filter = this.parts.value.value.toLocaleLowerCase(), W3(0), this.popOptions();
  });
  popOptions = (e) => {
    if (e && e.type === "click")
      this.filter = "";
    this.poppedOptions = this.optionsMenu, B3({ target: this, menuItems: this.poppedOptions, showChecked: true });
  };
  content = () => [Zi({ part: "button", onClick: this.popOptions }, kt(), Yi({ part: "value", value: this.value, tabindex: 0, onKeydown: this.handleKey, onInput: this.filterMenu, onChange: this.handleChange }), c.chevronDown())];
  constructor() {
    super();
    this.initAttributes("options", "editable", "placeholder", "showIcon", "hideCaption", "localized", "disabled");
  }
  get allOptions() {
    let e = [];
    function t(i) {
      for (let o of i)
        if (typeof o === "string")
          e.push({ caption: o, value: o });
        else if (o?.value)
          e.push(o);
        else if (o?.options)
          t(o.options);
    }
    return t(this.selectOptions), e;
  }
  findOption() {
    return this.allOptions.find((t) => t.value === this.value) || { caption: this.value, value: this.value };
  }
  localeChanged = () => {
    this.queueRender();
  };
  connectedCallback() {
    if (super.connectedCallback(), this.localized)
      S2.allInstances.add(this);
  }
  disconnectedCallback() {
    if (super.disconnectedCallback(), this.localized)
      S2.allInstances.delete(this);
  }
  render() {
    super.render();
    let { value: e, button: t } = this.parts;
    t.disabled = this.disabled;
    let i = e.previousElementSibling, o = this.findOption(), s = kt();
    if (e.value = this.localized ? f2(o.caption) : o.caption, o.icon)
      if (o.icon instanceof HTMLElement)
        s = o.icon.cloneNode(true);
      else
        s = c[o.icon]();
    i.replaceWith(s), e.setAttribute("placeholder", this.localized ? f2(this.placeholder) : this.placeholder), e.style.pointerEvents = this.editable ? "" : "none", e.readOnly = !this.editable;
  }
}
var T3 = Z2.elementCreator({ tag: "xin-select", styleSpec: { ":host": { "--gap": "8px", "--touch-size": "44px", "--padding": "0 8px", "--value-padding": "0 8px", "--icon-width": "24px", "--fieldWidth": "140px", display: "inline-flex", position: "relative" }, ":host button": { display: "flex", alignItems: "center", justifyItems: "center", gap: On.gap, textAlign: "left", height: On.touchSize, padding: On.padding, position: "relative", width: "100%" }, ":host:not([show-icon]) button > :first-child": { display: "none" }, ":host[hide-caption] button > :nth-child(2)": { display: "none" }, ':host [part="value"]': { width: On.fieldWidth, padding: On.valuePadding, height: On.touchSize, lineHeight: On.touchSize, boxShadow: "none", whiteSpace: "nowrap", outline: "none", background: "transparent", flex: "1" }, ':host [part="value"]:not(:focus)': { overflow: "hidden", textOverflow: "ellipsis", background: "transparent" } } });
var { span: zt } = m;
var { i18n: b3 } = be({ i18n: { locale: window.navigator.language, locales: [window.navigator.language], languages: [window.navigator.language], emoji: [""], stringMap: {}, localeOptions: [{ icon: zt(), caption: window.navigator.language, value: window.navigator.language }] } });
tn.localeOptions = { toDOM(e, t) {
  if (e instanceof Z2)
    e.options = t;
} };
var Bt = () => {
  let e = Array.from(S2.allInstances);
  for (let t of e)
    t.localeChanged();
};
Z(b3.locale.xinPath, Bt);
var oo2 = Oe3((e) => [e.caption.toLocaleLowerCase()]);
function f2(e) {
  if (e.endsWith(""))
    return f2(e.substring(0, e.length - 1)) + "";
  let t = b3.locales.xinValue.indexOf(b3.locale.xinValue);
  if (t > -1) {
    let i = b3.stringMap[e.toLocaleLowerCase()], o = i && i[t];
    if (o)
      e = e.toLocaleLowerCase() === e ? o.toLocaleLowerCase() : o.valueOf();
  }
  return e;
}

class Lt extends B {
  hideCaption = false;
  content = () => {
    return T3({ part: "select", showIcon: true, title: f2("Language"), bindValue: b3.locale, bindLocaleOptions: b3.localeOptions });
  };
  constructor() {
    super();
    this.initAttributes("hideCaption");
  }
  render() {
    super.render(), this.parts.select.toggleAttribute("hide-caption", this.hideCaption);
  }
}
var hn2 = Lt.elementCreator({ tag: "xin-locale-picker" });

class S2 extends B {
  static allInstances = new Set;
  contents = () => m.xinSlot();
  refString = "";
  constructor() {
    super();
    this.initAttributes("refString");
  }
  connectedCallback() {
    super.connectedCallback(), S2.allInstances.add(this);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), S2.allInstances.delete(this);
  }
  localeChanged() {
    if (!this.refString)
      this.refString = this.textContent || "";
    this.textContent = this.refString ? f2(this.refString) : "";
  }
  render() {
    super.render(), this.localeChanged();
  }
}
var Y2 = S2.elementCreator({ tag: "xin-localized", styleSpec: { ":host": { pointerEvents: "none" } } });
var St = (e, t) => {
  t = t.toLocaleLowerCase();
  let i = !!t.match(/\^|ctrl/), o = !!t.match(/|meta/), s = !!t.match(/||alt|option/), n = !!t.match(/|shift/), l = t.slice(-1);
  return e.key === l && e.metaKey === o && e.ctrlKey === i && e.altKey === s && e.shiftKey === n;
};
var { div: At, button: je2, span: A2, a: ao, xinSlot: ro } = m;
Ue("xin-menu-helper", { ".xin-menu": { overflow: "hidden auto", maxHeight: `calc(${On.maxHeight} - ${sn.menuInset("8px")})`, borderRadius: On.spacing50, background: sn.menuBg("#fafafa"), boxShadow: sn.menuShadow(`${On.spacing13} ${On.spacing50} ${On.spacing} #0004`) }, ".xin-menu > div": { width: sn.menuWidth("auto") }, ".xin-menu-trigger": { paddingLeft: 0, paddingRight: 0, minWidth: sn.touchSize("48px") }, ".xin-menu-separator": { display: "inline-block", content: " ", height: "1px", width: "100%", background: sn.menuSeparatorColor("#2224"), margin: sn.menuSeparatorMargin("8px 0") }, ".xin-menu-item": { boxShadow: "none", border: "none !important", display: "grid", alignItems: "center", justifyContent: "flex-start", textDecoration: "none", gridTemplateColumns: "0px 1fr 30px", width: "100%", gap: 0, background: "transparent", padding: sn.menuItemPadding("0 16px"), height: sn.menuItemHeight("48px"), lineHeight: sn.menuItemHeight("48px"), textAlign: "left" }, ".xin-menu-item, .xin-menu-item > span": { color: sn.menuItemColor("#222") }, ".xin-menu-with-icons .xin-menu-item": { gridTemplateColumns: "30px 1fr 30px" }, ".xin-menu-item svg": { stroke: sn.menuItemIconColor("#222") }, ".xin-menu-item.xin-menu-item-checked": { background: sn.menuItemHoverBg("#eee") }, ".xin-menu-item > span:nth-child(2)": { whiteSpace: "nowrap", overflow: "hidden", textOverflow: "ellipsis", textAlign: "left" }, ".xin-menu-item:hover": { boxShadow: "none !important", background: sn.menuItemHoverBg("#eee") }, ".xin-menu-item:active": { boxShadow: "none !important", background: sn.menuItemActiveBg("#aaa"), color: sn.menuItemActiveColor("#000") }, ".xin-menu-item:active svg": { stroke: sn.menuItemIconActiveColor("#000") } });
var co = (e, t) => {
  let i = e.checked && e.checked() && "check" || false, o = e?.icon || i || A2(" ");
  if (typeof o === "string")
    o = c[o]();
  let s;
  if (typeof e?.action === "string")
    s = ao({ class: "xin-menu-item", href: e.action }, o, t.localized ? A2(f2(e.caption)) : A2(e.caption), A2(e.shortcut || " "));
  else
    s = je2({ class: "xin-menu-item", onClick: e.action }, o, t.localized ? A2(f2(e.caption)) : A2(e.caption), A2(e.shortcut || " "));
  if (s.classList.toggle("xin-menu-item-checked", i !== false), e?.enabled && !e.enabled())
    s.setAttribute("disabled", "");
  return s;
};
var po = (e, t) => {
  let i = e.checked && e.checked() && "check" || false, o = e?.icon || i || A2(" ");
  if (typeof o === "string")
    o = c[o]();
  let s = je2({ class: "xin-menu-item", disabled: !(!e.enabled || e.enabled()), onClick(n) {
    B3(Object.assign({}, t, { menuItems: e.menuItems, target: s, submenuDepth: (t.submenuDepth || 0) + 1, position: "side" })), n.stopPropagation(), n.preventDefault();
  } }, o, t.localized ? A2(f2(e.caption)) : A2(e.caption), c.chevronRight({ style: { justifySelf: "flex-end" } }));
  return s;
};
var ho = (e, t) => {
  if (e === null)
    return A2({ class: "xin-menu-separator" });
  else {
    let i = e?.action ? co(e, t) : po(e, t);
    if (t.showChecked && e.checked && e.checked())
      requestAnimationFrame(() => {
        i.scrollIntoView({ block: "center" });
      });
    return i;
  }
};
var uo = (e) => {
  let { target: t, width: i, menuItems: o } = e, s = o.find((n) => n?.icon || n?.checked);
  return At({ class: s ? "xin-menu xin-menu-with-icons" : "xin-menu", onClick() {
    W3(0);
  } }, At({ style: { minWidth: t.offsetWidth + "px", width: typeof i === "number" ? `${i}px` : i }, onMousedown(n) {
    n.preventDefault(), n.stopPropagation();
  } }, ...o.map((n) => ho(n, e))));
};
var ee2;
var U3 = [];
var W3 = (e = 0) => {
  let t = U3.splice(e);
  for (let i of t)
    i.menu.remove();
  return ee2 = t[0], e > 0 ? U3[e - 1] : undefined;
};
document.body.addEventListener("mousedown", (e) => {
  if (e.target && !U3.find((t) => t.target.contains(e.target)))
    W3(0);
});
document.body.addEventListener("keydown", (e) => {
  if (e.key === "Escape")
    W3(0);
});
var B3 = (e) => {
  e = Object.assign({ submenuDepth: 0 }, e);
  let { target: t, position: i, submenuDepth: o } = e;
  if (ee2 && !document.body.contains(ee2?.menu))
    ee2 = undefined;
  if (U3.length && !document.body.contains(U3[0].menu))
    U3.splice(0);
  if (o === 0 && ee2?.target === t)
    return;
  let s = W3(o);
  if (ee2?.target === t)
    return;
  if (s && s.target === t) {
    W3();
    return;
  }
  if (!e.menuItems?.length)
    return;
  let n = uo(e), l = bt({ content: n, target: t, position: i });
  l.remainOnScroll = "remove", U3.push({ target: t, menu: l });
};
function Et(e, t) {
  for (let i of e) {
    if (!i)
      continue;
    let { shortcut: o } = i, { menuItems: s } = i;
    if (o) {
      if (St(t, o))
        return i;
    } else if (s) {
      let n = Et(s, t);
      if (n)
        return n;
    }
  }
  return;
}

class Ht2 extends B {
  menuItems = [];
  menuWidth = "auto";
  localized = false;
  showMenu = (e) => {
    if (e.type === "click" || e.code === "Space")
      B3({ target: this.parts.trigger, width: this.menuWidth, localized: this.localized, menuItems: this.menuItems }), e.stopPropagation(), e.preventDefault();
  };
  content = () => je2({ tabindex: 0, part: "trigger", onClick: this.showMenu }, ro());
  handleShortcut = async (e) => {
    let t = Et(this.menuItems, e);
    if (t) {
      if (t.action instanceof Function)
        t.action();
    }
  };
  constructor() {
    super();
    this.initAttributes("menuWidth", "localized", "icon"), this.addEventListener("keydown", this.showMenu);
  }
  connectedCallback() {
    super.connectedCallback(), document.addEventListener("keydown", this.handleShortcut, true);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), document.removeEventListener("keydown", this.handleShortcut);
  }
}
var zn2 = Ht2.elementCreator({ tag: "xin-menu", styleSpec: { ":host": { display: "inline-block" }, ":host button > xin-slot": { display: "flex", alignItems: "center", gap: sn.xinMenuTriggerGap("10px") } } });
var De3 = {};
Si(De3, { init: () => Ve3, draggedElement: () => vo });
var yo = () => !!document.querySelector(".drag-source");
var It = (e, t) => {
  if (!e)
    return false;
  for (let i of e)
    if (i === "special/any")
      return true;
    else if (i.indexOf("*") > -1) {
      let [o, s] = i.split("/"), [n, l] = t.split("/");
      if ((o === "*" || o === n) && (s === "*" || s === l))
        return true;
    } else if (i === t)
      return true;
};
var be3 = (e) => {
  for (let t of [...document.querySelectorAll(`.${e}`)])
    t.classList.remove(e);
};
var Ot = () => {
  be3("drag-over"), be3("drag-source"), be3("drag-target");
};
var Fe3 = (e, t = ";") => {
  return (e || "").split(t).map((i) => i.trim()).filter((i) => i !== "");
};
var jt = (e) => {
  if (!e)
    e = [];
  let t = [...document.querySelectorAll("[data-drop]")];
  for (let i of t) {
    let o = Fe3(i.dataset.drop);
    if (e.find((s) => It(o, s)))
      i.classList.add("drag-target");
    else
      i.classList.remove("drag-target");
  }
};
function xo(e) {
  let t = e.target?.closest('[draggable="true"],a[href]');
  if (!t)
    return;
  t.classList.add("drag-source");
  let i = t.matches('[draggable="true"]') ? Fe3(t.dataset.drag || "text/html") : Fe3(t.dataset.drag || "url");
  for (let o of i) {
    let s = t.dataset.dragContent || (o === "text/html" ? t.innerHTML : t.textContent);
    e.dataTransfer?.setData(o, s || "");
  }
  jt(e.dataTransfer?.types), e.stopPropagation();
}
function Tt(e) {
  if (!yo())
    jt(e.dataTransfer?.types);
  let t = e.target.closest(".drag-target");
  if (t && e.dataTransfer)
    t.classList.add("drag-over"), e.dataTransfer.dropEffect = "copy";
  else
    e.preventDefault(), e.stopPropagation();
}
function go() {
  be3("drag-over");
}
function fo(e) {
  let t = e.target.closest(".drag-target");
  if (t) {
    let i = (t.dataset?.drop || "").split(";");
    for (let o of i)
      if (It(e.dataTransfer?.types, o))
        if (o === "text/html")
          t.innerHTML = e.dataTransfer?.getData(o) || "";
        else
          t.textContent = e.dataTransfer?.getData(o) || "";
  }
  Ot();
}
var vo = () => document.querySelector(".drag-source");
var Pt = false;
var Ve3 = () => {
  if (Pt)
    return;
  document.body.addEventListener("dragstart", xo), document.body.addEventListener("dragenter", Tt), document.body.addEventListener("dragover", Tt), document.body.addEventListener("drop", fo), document.body.addEventListener("dragleave", go), document.body.addEventListener("dragend", Ot), window.addEventListener("dragover", (e) => e.preventDefault()), window.addEventListener("drop", (e) => e.preventDefault()), Pt = true;
};
function Co(e, t, i) {
  let o = e.find((s) => s[t] !== undefined && s[t] !== null);
  if (o !== undefined) {
    let s = o[t];
    switch (typeof s) {
      case "string":
        if (s.match(/^\d+(\.\d+)?$/))
          return 6 * i;
        else if (s.includes(" "))
          return 20 * i;
        else
          return 12 * i;
      case "number":
        return 6 * i;
      case "boolean":
        return 5 * i;
      case "object":
        return false;
      default:
        return 8 * i;
    }
  }
  return false;
}
var { div: te2, span: ke3, button: wo, template: Mo } = m;
var Vt = (e) => e;

class Dt extends B {
  select = false;
  multiple = false;
  nosort = false;
  nohide = false;
  noreorder = false;
  selectionChanged = () => {};
  localized = false;
  selectedKey = Symbol("selected");
  selectBinding = (e, t) => {
    e.toggleAttribute("aria-selected", t[this.selectedKey] === true);
  };
  pinnedTop = 0;
  pinnedBottom = 0;
  maxVisibleRows = 1e4;
  get value() {
    return { array: this.array, filter: this.filter, columns: this.columns };
  }
  set value(e) {
    let { array: t, columns: i, filter: o } = w(e);
    if (this._array !== t || this._columns !== i || this._filter !== o)
      this.queueRender();
    this._array = t || [], this._columns = i || null, this._filter = o || Vt;
  }
  rowData = { visible: [], pinnedTop: [], pinnedBottom: [] };
  _array = [];
  _columns = null;
  _filter = Vt;
  charWidth = 15;
  rowHeight = 30;
  minColumnWidth = 30;
  get virtual() {
    return this.rowHeight > 0 ? { height: this.rowHeight } : undefined;
  }
  constructor() {
    super();
    this.rowData = be({ [this.instanceId]: this.rowData })[this.instanceId], this.initAttributes("rowHeight", "charWidth", "minColumnWidth", "select", "multiple", "pinnedTop", "pinnedBottom", "nosort", "nohide", "noreorder", "localized");
  }
  get array() {
    return this._array;
  }
  set array(e) {
    this._array = w(e), this.queueRender();
  }
  get filter() {
    return this._filter;
  }
  set filter(e) {
    if (this._filter !== e)
      this._filter = e, this.queueRender();
  }
  get sort() {
    if (this._sort)
      return this._sort;
    let e = this._columns?.find((i) => i.sort === "ascending" || i.sort === "descending");
    if (!e)
      return;
    let { prop: t } = e;
    return e.sort === "ascending" ? (i, o) => i[t] > o[t] ? 1 : -1 : (i, o) => i[t] > o[t] ? -1 : 1;
  }
  set sort(e) {
    if (this._sort !== e)
      this._sort = e, this.queueRender();
  }
  get columns() {
    if (!Array.isArray(this._columns)) {
      let { _array: e } = this;
      this._columns = Object.keys(e[0] || {}).map((t) => {
        let i = Co(e, t, this.charWidth);
        return { name: t.replace(/([a-z])([A-Z])/g, "$1 $2").toLocaleLowerCase(), prop: t, align: typeof e[0][t] === "number" || e[0][t] !== "" && !isNaN(e[0][t]) ? "right" : "left", visible: i !== false, width: i ? i : 0 };
      });
    }
    return this._columns;
  }
  set columns(e) {
    this._columns = e, this.queueRender();
  }
  get visibleColumns() {
    return this.columns.filter((e) => e.visible !== false);
  }
  content = null;
  getColumn(e) {
    let t = (e.touches !== undefined ? e.touches[0].clientX : e.clientX) - this.getBoundingClientRect().x, i = e.touches !== undefined ? 20 : 5, o = 0, s = [];
    return this.visibleColumns.find((l) => {
      if (l.visible !== false)
        return o += l.width, s.push(o), Math.abs(t - o) < i;
    });
  }
  setCursor = (e) => {
    if (this.getColumn(e) !== undefined)
      this.style.cursor = "col-resize";
    else
      this.style.cursor = "";
  };
  resizeColumn = (e) => {
    let t = this.getColumn(e);
    if (t !== undefined) {
      let i = Number(t.width), o = e.touches !== undefined, s = o ? e.touches[0].identifier : undefined;
      z3(e, (n, l, a2) => {
        if ((o ? [...a2.touches].find((h2) => h2.identifier === s) : true) === undefined)
          return true;
        let p = i + n;
        if (t.width = p > this.minColumnWidth ? p : this.minColumnWidth, this.setColumnWidths(), a2.type === "mouseup")
          return true;
      }, "col-resize");
    }
  };
  selectRow(e, t = true) {
    if (t)
      e[this.selectedKey] = true;
    else
      delete e[this.selectedKey];
  }
  selectRows(e, t = true) {
    for (let i of e || this.array)
      this.selectRow(i, t);
  }
  deSelect(e) {
    this.selectRows(e, false);
  }
  rangeStart;
  updateSelection = (e) => {
    if (!this.select && !this.multiple)
      return;
    let { target: t } = e;
    if (!(t instanceof HTMLElement))
      return;
    let i = t.closest(".tr");
    if (!(i instanceof HTMLElement))
      return;
    let o = mn(i);
    if (o === false)
      return;
    let s = e, n = window.getSelection();
    if (n !== null)
      n.removeAllRanges();
    let l = this.visibleRows;
    if (this.multiple && s.shiftKey && l.length > 0 && this.rangeStart !== o) {
      let a2 = this.rangeStart === undefined || this.rangeStart[this.selectedKey] === true, [r, p] = [this.rangeStart !== undefined ? l.indexOf(this.rangeStart) : 0, l.indexOf(o)].sort((h2, d) => h2 - d);
      if (r > -1)
        for (let h2 = r;h2 <= p; h2++) {
          let d = l[h2];
          this.selectRow(d, a2);
        }
    } else if (this.multiple && s.metaKey) {
      this.selectRow(o, !o[this.selectedKey]);
      let a2 = l.indexOf(o), r = l[a2 + 1], p = a2 > 0 ? l[a2 - 1] : undefined;
      if (r !== undefined && r[this.selectedKey] === true)
        this.rangeStart = r;
      else if (p !== undefined && p[this.selectedKey] === true)
        this.rangeStart = p;
      else
        this.rangeStart = undefined;
    } else
      this.rangeStart = o, this.deSelect(), this.selectRow(o, true);
    this.selectionChanged(this.visibleSelectedRows);
    for (let a2 of Array.from(this.querySelectorAll(".tr"))) {
      let r = mn(a2);
      this.selectBinding(a2, r);
    }
  };
  connectedCallback() {
    super.connectedCallback(), this.addEventListener("mousemove", this.setCursor), this.addEventListener("mousedown", this.resizeColumn), this.addEventListener("touchstart", this.resizeColumn, { passive: true }), this.addEventListener("mouseup", this.updateSelection), this.addEventListener("touchend", this.updateSelection);
  }
  setColumnWidths() {
    this.style.setProperty("--grid-columns", this.visibleColumns.map((e) => e.width + "px").join(" ")), this.style.setProperty("--grid-row-width", this.visibleColumns.reduce((e, t) => e + t.width, 0) + "px");
  }
  sortByColumn = (e, t = "auto") => {
    for (let i of this.columns.filter((o) => w(o.sort) !== false))
      if (w(i) === e) {
        if (t === "auto")
          i.sort = i.sort === "ascending" ? "descending" : "ascending";
        else
          i.sort = t;
        this.queueRender();
      } else
        delete i.sort;
  };
  popColumnMenu = (e, t) => {
    let { sortByColumn: i } = this, o = this.columns.filter((l) => l.visible === false), s = this.queueRender.bind(this), n = [];
    if (!this.nosort && t.sort !== false)
      n.push({ caption: this.localized ? `${f2("Sort")} ${f2("Ascending")}` : "Sort Ascending", icon: "sortAscending", action() {
        i(t);
      } }, { caption: this.localized ? `${f2("Sort")} ${f2("Descending")}` : "Sort Ascending", icon: "sortDescending", action() {
        i(t, "descending");
      } });
    if (!this.nohide) {
      if (n.length)
        n.push(null);
      n.push({ caption: this.localized ? `${f2("Hide")} ${f2("Column")}` : "Hide Column", icon: "eyeOff", enabled: () => t.visible !== true, action() {
        t.visible = false, s();
      } }, { caption: this.localized ? `${f2("Show")} ${f2("Column")}` : "Show Column", icon: "eye", enabled: () => o.length > 0, menuItems: o.map((l) => {
        return { caption: l.name || l.prop, action() {
          delete l.visible, s();
        } };
      }) });
    }
    B3({ target: e, localized: this.localized, menuItems: n });
  };
  get captionSpan() {
    return this.localized ? Y2 : ke3;
  }
  headerCell = (e) => {
    let { popColumnMenu: t } = this, i = "none", o;
    switch (e.sort) {
      case "ascending":
        o = c.sortAscending(), i = "descending";
        break;
      case false:
        break;
      default:
        break;
      case "descending":
        i = "ascending", o = c.sortDescending();
    }
    let s = !(this.nosort && this.nohide) ? wo({ class: "menu-trigger", onClick(n) {
      t(n.target, e), n.stopPropagation();
    } }, o || c.moreVertical()) : {};
    return e.headerCell !== undefined ? e.headerCell(e) : ke3({ class: "th", role: "columnheader", ariaSort: i, style: { ...this.cellStyle, justifyContent: e.align || "left" } }, this.captionSpan(typeof e.name === "string" ? e.name : e.prop), ke3({ style: { flex: "1" } }), s);
  };
  dataCell = (e) => {
    if (e.dataCell !== undefined)
      return e.dataCell(e);
    return ke3({ class: "td", role: "cell", style: { ...this.cellStyle, justifyContent: e.align || "left" }, bindText: `^.${e.prop}` });
  };
  get visibleRows() {
    return w(this.rowData.visible);
  }
  get visibleSelectedRows() {
    return this.visibleRows.filter((e) => e[this.selectedKey]);
  }
  get selectedRows() {
    return this.array.filter((e) => e[this.selectedKey]);
  }
  rowTemplate(e) {
    return Mo(te2({ class: "tr", role: "row", bind: { value: "^", binding: { toDOM: this.selectBinding } } }, ...e.map(this.dataCell)));
  }
  draggedColumn;
  dropColumn = (e) => {
    let t = e.target.closest(".drag-over"), i = Array.from(t.parentElement.children).indexOf(t), o = this.visibleColumns[i], s = this.columns.indexOf(this.draggedColumn), n = this.columns.indexOf(o);
    this.columns.splice(s, 1), this.columns.splice(n, 0, this.draggedColumn), console.log({ event: e, target: t, targetIndex: i, draggedIndex: s, droppedIndex: n }), this.queueRender(), e.preventDefault(), e.stopPropagation();
  };
  render() {
    super.render(), this.rowData.pinnedTop = this.pinnedTop > 0 ? this._array.slice(0, this.pinnedTop) : [], this.rowData.pinnedBottom = this.pinnedBottom > 0 ? this._array.slice(this._array.length - this.pinnedBottom) : [], this.rowData.visible = this.filter(this._array.slice(this.pinnedTop, Math.min(this.maxVisibleRows, this._array.length - this.pinnedTop - this.pinnedBottom)));
    let { sort: e } = this;
    if (e)
      this.rowData.visible.sort(e);
    this.textContent = "", this.style.display = "flex", this.style.flexDirection = "column";
    let { visibleColumns: t } = this;
    if (this.style.setProperty("--row-height", `${this.rowHeight}px`), this.setColumnWidths(), !this.noreorder)
      Ve3();
    let i = this.instanceId + "-column-header", o = t.map((s) => {
      let n = this.headerCell(s);
      if (!this.noreorder)
        n.setAttribute("draggable", "true"), n.dataset.drag = i, n.dataset.drop = i, n.addEventListener("dragstart", () => {
          this.draggedColumn = s;
        }), n.addEventListener("drop", this.dropColumn);
      return n;
    });
    if (this.append(te2({ class: "thead", role: "rowgroup", style: { touchAction: "none" } }, te2({ class: "tr", role: "row" }, ...o))), this.pinnedTop > 0)
      this.append(te2({ part: "pinnedTopRows", class: "tbody", role: "rowgroup", style: { flex: "0 0 auto", overflow: "hidden", height: `${this.rowHeight * this.pinnedTop}px` }, bindList: { value: this.rowData.pinnedTop, virtual: this.virtual } }, this.rowTemplate(t)));
    if (this.append(te2({ part: "visibleRows", class: "tbody", role: "rowgroup", style: { content: " ", minHeight: "100px", flex: "1 1 100px", overflow: "hidden auto" }, bindList: { value: this.rowData.visible, virtual: this.virtual } }, this.rowTemplate(t))), this.pinnedBottom > 0)
      this.append(te2({ part: "pinnedBottomRows", class: "tbody", role: "rowgroup", style: { flex: "0 0 auto", overflow: "hidden", height: `${this.rowHeight * this.pinnedBottom}px` }, bindList: { value: this.rowData.pinnedBottom, virtual: this.virtual } }, this.rowTemplate(t)));
  }
}
var On2 = Dt.elementCreator({ tag: "xin-table", styleSpec: { ":host": { overflow: "auto hidden" }, ":host .thead, :host .tbody": { width: On.gridRowWidth }, ":host .tr": { display: "grid", gridTemplateColumns: On.gridColumns, height: On.rowHeight, lineHeight: On.rowHeight }, ":host .td, :host .th": { overflow: "hidden", whiteSpace: "nowrap", textOverflow: "ellipsis", display: "flex", alignItems: "center" }, ":host .th .menu-trigger": { color: "currentColor", background: "none", padding: 0, lineHeight: On.touchSize, height: On.touchSize, width: On.touchSize }, ':host [draggable="true"]': { cursor: "ew-resize" }, ':host [draggable="true"]:active': { background: sn.draggedHeaderBg("#0004"), color: sn.draggedHeaderColor("#fff") }, ":host .drag-over": { background: sn.dropHeaderBg("#fff4") } } });
var { dialog: So, button: Re3, header: Ao, footer: Eo, xinSlot: We3, h3: Ue3, p: $e3, label: Ho, input: To, div: Po } = m;

class qt extends B {
  static async alert(e, t = "Alert") {
    return new Promise((i) => {
      let o = Ge3({ removeOnClose: true, closeOnBackgroundClick: true, dialogWillClose() {
        i();
      } }, Ue3({ slot: "header" }, t), $e3(e));
      document.body.append(o), o.showModal();
    });
  }
  static async confirm(e, t = "Confirm") {
    return new Promise((i) => {
      let o = Ge3({ removeOnClose: true, dialogWillClose(s) {
        i(s === "confirm");
      } }, Ue3({ slot: "header" }, t), $e3(e), Re3({ slot: "footer", onClick() {
        o.close();
      } }, "Cancel"));
      document.body.append(o), o.showModal();
    });
  }
  static async prompt(e, t = "Prompt", i = "") {
    return new Promise((o) => {
      let s = To({ value: i }), n = Ge3({ removeOnClose: true, dialogWillClose(l) {
        o(l === "confirm" ? s.value : null);
      }, initialFocus() {
        s.focus();
      } }, Ue3({ slot: "header" }, t), $e3(Ho({ style: { display: "flex", flexDirection: "column", alignItems: "stretch", gap: 5 } }, Po(e), s)), Re3({ slot: "footer", onClick() {
        n.close();
      } }, "Cancel"));
      document.body.append(n), n.showModal();
    });
  }
  removeOnClose = false;
  closeOnBackgroundClick = false;
  constructor() {
    super();
    this.initAttributes("removeOnClose", "closeOnBackgroundClick"), P(this, "click", () => {
      if (this.closeOnBackgroundClick)
        this.close();
    });
  }
  dialogWillClose = (e = "cancel") => {
    console.log("dialog will close with", e);
  };
  initialFocus() {
    this.parts.ok.focus();
  }
  #e = (e) => {};
  showModal = () => {
    return this.style.zIndex = String(X3()), new Promise((e) => {
      this.#e = e, this.parts.dialog.showModal(), requestAnimationFrame(() => {
        this.initialFocus();
      });
    });
  };
  close = (e = "cancel") => {
    if (this.dialogWillClose(e), this.#e(e), this.parts.dialog.close(), this.removeOnClose)
      this.remove();
  };
  ok = () => {
    this.close("confirm");
  };
  content = () => So({ part: "dialog" }, Ao(We3({ name: "header" })), We3(), Eo(We3({ name: "footer" }), Re3({ part: "ok", onClick: this.ok }, "OK")));
}
var Ge3 = qt.elementCreator({ tag: "tosi-dialog", styleSpec: { ":host > dialog::backdrop": { backdropFilter: "blur(8px)" }, ":host > dialog:not([open])": { display: "none" }, ":host > dialog[open]": { minWidth: 300, border: 0, borderRadius: 10, overflow: "hidden", maxHeight: "calc(100% - 20px)", padding: 0, display: "flex", flexDirection: "column", gap: 5, _dialogShadow: sn.menuShadow("0 5px 10px #0004"), _dialogBackground: sn.background("#fafafa"), _dialogColor: sn.textColor("#222"), boxShadow: On.dialogShadow, background: On.dialogBackground, color: On.dialogColor }, ":host > dialog > *": { padding: "0 20px" }, ":host > dialog > header": { display: "flex", justifyContent: "center", gap: 10 }, ":host > dialog > footer": { display: "flex", justifyContent: "flex-end", gap: 10, paddingBottom: 20 } } });
var { div: E2, slot: jo } = m;

class P3 extends B {
  static angleSize = 15;
  static gridSize = 8;
  static snapAngle = false;
  static snapToGrid = false;
  static styleSpec = { ":host": { "--handle-bg": "#fff4", "--handle-color": "#2228", "--handle-hover-bg": "#8ff8", "--handle-hover-color": "#222", "--handle-size": "20px", "--handle-padding": "2px" }, ":host ::slotted(*)": { position: "absolute" }, ":host > :not(style,slot)": { boxSizing: "border-box", content: '" "', position: "absolute", display: "flex", height: On.handleSize, width: On.handleSize, padding: On.handlePadding, "--text-color": On.handleColor, background: On.handleBg }, ":host > .drag-size": { top: 0, bottom: 0, left: 0, right: 0, height: "auto", width: "auto", background: "transparent", cursor: "ew-resize" }, ':host > [part="rotate"]': { transform: `translateY(${On.handleSize_50})` }, ":host > [locked] > svg:first-child, :host > :not([locked]) > svg+svg": { display: "none" }, ":host .icon-unlock": { opacity: 0.5 }, ":host svg": { pointerEvents: "none" }, ":host > *:hover": { "--text-color": On.handleHoverColor, background: On.handleHoverBg } };
  static snappedCoords(e, t) {
    let { gridSize: i } = P3;
    return P3.snapToGrid || e.shiftKey ? t.map((o) => Math.round(o / i) * i) : t;
  }
  static snappedAngle(e, t) {
    let { angleSize: i } = P3;
    return P3.snapAngle || e.shiftKey ? Math.round(t / i) * i : t;
  }
  get locked() {
    let e = this.parentElement;
    if (e.style.inset)
      return { left: true, top: true, bottom: true, right: true };
    let t = e.style.right.match(/\d/) !== null, i = !t || e.style.left.match(/\d/) !== null, o = e.style.bottom.match(/\d/) !== null, s = !o || e.style.top.match(/\d/) !== null;
    return { left: i, top: s, bottom: o, right: t };
  }
  set locked(e) {
    let { bottom: t, right: i } = e, { left: o, top: s } = e, n = this.parentElement, l = n.offsetLeft, a2 = n.offsetTop, r = n.offsetWidth, p = n.offsetHeight, h2 = n.offsetParent.offsetWidth - l - r, d = n.offsetParent.offsetHeight - a2 - p;
    if (Object.assign(n.style, { left: "", right: "", top: "", bottom: "", width: "", height: "" }), !i)
      o = true;
    if (!t)
      s = true;
    if (o)
      n.style.left = l + "px";
    if (i)
      n.style.right = h2 + "px";
    if (o && i)
      n.style.width = "auto";
    else
      n.style.width = r + "px";
    if (s)
      n.style.top = a2 + "px";
    if (t)
      n.style.bottom = d + "px";
    if (s && t)
      n.style.height = "auto";
    else
      n.style.height = p + "px";
    this.queueRender();
  }
  get coords() {
    let { top: e, left: t, right: i, bottom: o } = this.parentElement.style;
    return { top: parseFloat(e), left: parseFloat(t), right: parseFloat(i), bottom: parseFloat(o) };
  }
  get left() {
    return this.parentElement.offsetLeft;
  }
  get width() {
    return this.parentElement.offsetWidth;
  }
  get right() {
    return this.parentElement.offsetParent.offsetWidth - (this.left + this.width);
  }
  get top() {
    return this.parentElement.offsetTop;
  }
  get height() {
    return this.parentElement.offsetHeight;
  }
  get bottom() {
    return this.parentElement.offsetParent.offsetHeight - (this.top + this.height);
  }
  triggerChange = () => {
    this.parentElement.dispatchEvent(new Event("change", { bubbles: true, composed: true }));
  };
  adjustPosition = (e) => {
    let { locked: t } = this;
    this.locked = t;
    let i = this.parentElement, { top: o, left: s, bottom: n, right: l } = this.coords;
    z3(e, (a2, r, p) => {
      if ([a2, r] = P3.snappedCoords(p, [a2, r]), !isNaN(o))
        i.style.top = o + r + "px";
      if (!isNaN(n))
        i.style.bottom = n - r + "px";
      if (!isNaN(s))
        i.style.left = s + a2 + "px";
      if (!isNaN(l))
        i.style.right = l - a2 + "px";
      if (p.type === "mouseup")
        return this.triggerChange(), true;
    });
  };
  resize = (e) => {
    let t = this.parentElement, { locked: i } = this;
    this.locked = Object.assign({ left: true, top: true, right: true, bottom: true });
    let [o, s] = [this.right, this.bottom];
    z3(e, (n, l, a2) => {
      let r = o - n, p = s - l;
      if ([r, p] = P3.snappedCoords(a2, [r, p]), t.style.right = r + "px", t.style.bottom = p + "px", a2.type === "mouseup")
        return this.locked = i, this.triggerChange(), true;
    });
  };
  adjustSize = (e) => {
    let t = this.parentElement, { locked: i } = this, o = e.target.getAttribute("part");
    this.locked = Object.assign({ left: true, right: true, top: true, bottom: true });
    let s = this[o];
    z3(e, (n, l, a2) => {
      let [r] = P3.snappedCoords(a2, [s + (["left", "right"].includes(o) ? n : l) * (["right", "bottom"].includes(o) ? -1 : 1)]);
      if (t.style[o] = r + "px", a2.type === "mouseup")
        return this.locked = i, this.triggerChange(), true;
    });
  };
  get rect() {
    return this.parentElement.getBoundingClientRect();
  }
  get center() {
    let e = this.parentElement.getBoundingClientRect();
    return { x: e.x + e.width * 0.5, y: e.y + e.height * 0.5 };
  }
  get element() {
    return this.parentElement;
  }
  adjustRotation = (e) => {
    let { center: t } = this, { transformOrigin: i } = this.element.style;
    if (!i)
      this.element.style.transformOrigin = "50% 50%";
    z3(e, (o, s, n) => {
      let { clientX: l, clientY: a2 } = n, r = l - t.x, p = a2 - t.y, h2 = p > 0 ? 90 : -90;
      if (r !== 0)
        h2 = Math.atan2(p, r) * 180 / Math.PI;
      if (h2 = P3.snappedAngle(n, h2), h2 === 0)
        this.element.style.transformOrigin = "", this.element.style.transform = "";
      else
        this.element.style.transform = `rotate(${h2}deg)`;
      return this.triggerChange(), n.type === "mouseup";
    });
  };
  toggleLock = (e) => {
    let { locked: t } = this, i = e.target.title.split(" ")[1];
    t[i] = !t[i], this.locked = t, this.queueRender(), e.stopPropagation(), e.preventDefault();
  };
  content = () => [E2({ part: "move", style: { top: "50%", left: "50%", transform: "translate(-50%,-50%)" } }, c.move()), E2({ part: "left", title: "resize left", class: "drag-size", style: { left: "-6px", width: "8px" } }), E2({ part: "right", title: "resize right", class: "drag-size", style: { left: "calc(100% - 2px)", width: "8px" } }), E2({ part: "top", title: "resize top", class: "drag-size", style: { top: "-6px", height: "8px", cursor: "ns-resize" } }), E2({ part: "bottom", title: "resize bottom", class: "drag-size", style: { top: "calc(100% - 2px)", height: "8px", cursor: "ns-resize" } }), E2({ part: "resize", style: { top: "100%", left: "100%" } }, c.resize()), E2({ part: "rotate", style: { top: "50%", right: "0" } }, c.refreshCw()), E2({ part: "lockLeft", title: "lock left", style: { top: "50%", left: 0, transform: "translate(-100%, -50%)" } }, c.unlock(), c.lock()), E2({ part: "lockRight", title: "lock right", style: { top: "50%", left: "100%", transform: "translate(0%, -50%)" } }, c.unlock(), c.lock()), E2({ part: "lockTop", title: "lock top", style: { top: 0, left: "50%", transform: "translate(-50%, -100%)" } }, c.unlock(), c.lock()), E2({ part: "lockBottom", title: "lock bottom", style: { top: "100%", left: "50%", transform: "translate(-50%, 0%)" } }, c.unlock(), c.lock()), jo()];
  constructor() {
    super();
    this.initAttributes("rotationSnap", "positionSnap");
  }
  connectedCallback() {
    super.connectedCallback();
    let { left: e, right: t, top: i, bottom: o, lockLeft: s, lockRight: n, lockTop: l, lockBottom: a2, move: r, resize: p, rotate: h2 } = this.parts, d = { passive: true };
    [e, t, i, o].forEach((g2) => {
      g2.addEventListener("mousedown", this.adjustSize, d), g2.addEventListener("touchstart", this.adjustSize, d);
    }), [s, n, l, a2].forEach((g2) => {
      g2.addEventListener("click", this.toggleLock);
    }), p.addEventListener("mousedown", this.resize, d), r.addEventListener("mousedown", this.adjustPosition, d), h2.addEventListener("mousedown", this.adjustRotation, d), p.addEventListener("touchstart", this.resize, d), r.addEventListener("touchstart", this.adjustPosition, d), h2.addEventListener("touchstart", this.adjustRotation, d);
  }
  render() {
    if (super.render(), !this.parentElement)
      return;
    let { lockLeft: e, lockRight: t, lockTop: i, lockBottom: o } = this.parts, { left: s, right: n, top: l, bottom: a2 } = this.locked;
    e.toggleAttribute("locked", s), t.toggleAttribute("locked", n), i.toggleAttribute("locked", l), o.toggleAttribute("locked", a2);
  }
}
var Wn2 = P3.elementCreator({ tag: "xin-editable" });
var { div: Vo, input: Do, button: Je3, span: qo } = m;
var _t = (e) => e;
var Nt2 = "null filter, everything matches";
var Ut2 = { contains: { caption: "contains", negative: "does not contain", makeTest: (e) => {
  return e = e.toLocaleLowerCase(), (t) => String(t).toLocaleLowerCase().includes(e);
} }, hasTags: { caption: "has tags", makeTest: (e) => {
  let t = e.split(/[\s,]/).map((i) => i.trim().toLocaleLowerCase()).filter((i) => i !== "");
  return (i) => Array.isArray(i) && t.find((o) => !i.includes(o)) === undefined;
} }, doesNotHaveTags: { caption: "does not have tags", makeTest: (e) => {
  let t = e.split(/[\s,]/).map((i) => i.trim().toLocaleLowerCase()).filter((i) => i !== "");
  return (i) => Array.isArray(i) && t.find((o) => i.includes(o)) === undefined;
} }, equals: { caption: "=", negative: "", makeTest: (e) => {
  if (isNaN(Number(e)))
    return e = String(e).toLocaleLowerCase(), (i) => String(i).toLocaleLowerCase() === e;
  let t = Number(e);
  return (i) => Number(i) === t;
} }, after: { caption: "is after", negative: "is before", makeTest: (e) => {
  let t = new Date(e);
  return (i) => new Date(i) > t;
} }, greaterThan: { caption: ">", negative: "", makeTest: (e) => {
  if (!isNaN(Number(e))) {
    let t = Number(e);
    return (i) => Number(i) > t;
  }
  return e = e.toLocaleLowerCase(), (t) => String(t).toLocaleLowerCase() > e;
} }, truthy: { caption: "is true/non-empty/non-zero", negative: "is false/empty/zero", needsValue: false, makeTest: () => (e) => !!e }, isTrue: { caption: "= true", needsValue: false, makeTest: () => (e) => e === true }, isFalse: { caption: "= false", needsValue: false, makeTest: () => (e) => e === false } };
var _o = { description: "anything", test: () => true };
function Rt(e) {
  return e.options[e.selectedIndex]?.caption || "";
}

class $t extends B {
  fields = [];
  filters = Ut2;
  haystack = "*";
  condition = "contains";
  needle = "";
  content = () => [T3({ part: "haystack" }), T3({ part: "condition" }), Do({ part: "needle", type: "search" }), qo({ part: "padding" }), Je3({ part: "remove", title: "delete" }, c.trash())];
  filter = _o;
  constructor() {
    super();
    this.initAttributes("haystack", "condition", "needle");
  }
  get state() {
    let { haystack: e, needle: t, condition: i } = this.parts;
    return { haystack: e.value, needle: t.value, condition: i.value };
  }
  set state(e) {
    Object.assign(this, e);
  }
  buildFilter = () => {
    let { haystack: e, condition: t, needle: i } = this.parts, o = t.value.startsWith("~"), s = o ? t.value.slice(1) : t.value, n = this.filters[s];
    i.hidden = n.needsValue === false;
    let l = n.needsValue === false ? n.makeTest(undefined) : n.makeTest(i.value), a2 = e.value, r;
    if (a2 !== "*")
      r = o ? (d) => !l(d[a2]) : (d) => l(d[a2]);
    else
      r = o ? (d) => Object.values(d).find((g2) => !l(g2)) !== undefined : (d) => Object.values(d).find((g2) => l(g2)) !== undefined;
    let p = n.needsValue !== false ? ` "${i.value}"` : "", h2 = `${Rt(e)} ${Rt(t)}${p}`;
    this.filter = { description: h2, test: r }, this.parentElement?.dispatchEvent(new Event("change"));
  };
  connectedCallback() {
    super.connectedCallback();
    let { haystack: e, condition: t, needle: i, remove: o } = this.parts;
    e.addEventListener("change", this.buildFilter), t.addEventListener("change", this.buildFilter), i.addEventListener("input", this.buildFilter), e.value = this.haystack, t.value = this.condition, i.value = this.needle, o.addEventListener("click", () => {
      let { parentElement: s } = this;
      this.remove(), s?.dispatchEvent(new Event("change"));
    });
  }
  render() {
    super.render();
    let { haystack: e, condition: t, needle: i } = this.parts;
    if (e.options = [{ caption: "any field", value: "*" }, ...this.fields.map((o) => o.prop)], t.options = Object.keys(this.filters).map((o) => {
      let s = this.filters[o];
      return s.negative !== undefined ? [{ caption: s.caption, value: o }, { caption: s.negative, value: "~" + o }] : { caption: s.caption, value: o };
    }).flat(), this.haystack !== "")
      e.value = this.haystack;
    if (this.condition !== "")
      t.value = this.condition;
    if (this.needle !== "")
      i.value = this.needle;
    this.buildFilter();
  }
}
var Ke3 = $t.elementCreator({ tag: "xin-filter-part", styleSpec: { ":host": { display: "flex" }, ":host .xin-icon:": { verticalAlign: "middle", pointerEvents: "none" }, ':host [part="haystack"], :host [part="condition"]': { flex: "1" }, ':host [part="needle"]': { flex: 2 }, ':host [hidden]+[part="padding"]': { display: "block", content: " ", flex: "1 1 auto" } } });

class Gt2 extends B {
  _fields = [];
  get fields() {
    return this._fields;
  }
  set fields(e) {
    this._fields = e, this.queueRender();
  }
  get state() {
    let { filterContainer: e } = this.parts;
    return [...e.children].map((t) => t.state);
  }
  set state(e) {
    let { fields: t, filters: i } = this, { filterContainer: o } = this.parts;
    o.textContent = "";
    for (let s of e)
      o.append(Ke3({ fields: t, filters: i, ...s }));
  }
  filter = _t;
  description = Nt2;
  addFilter = () => {
    let { fields: e, filters: t } = this, { filterContainer: i } = this.parts;
    i.append(Ke3({ fields: e, filters: t }));
  };
  content = () => [Je3({ part: "add", title: "add filter condition", onClick: this.addFilter, class: "round" }, c.plus()), Vo({ part: "filterContainer" }), Je3({ part: "reset", title: "reset filter", onClick: this.reset }, c.x())];
  filters = Ut2;
  reset = () => {
    let { fields: e, filters: t } = this, { filterContainer: i } = this.parts;
    this.description = Nt2, this.filter = _t, i.textContent = "", i.append(Ke3({ fields: e, filters: t })), this.dispatchEvent(new Event("change"));
  };
  buildFilter = () => {
    let { filterContainer: e } = this.parts;
    if (e.children.length === 0) {
      this.reset();
      return;
    }
    let t = [...e.children].map((o) => o.filter), i = t.map((o) => o.test);
    this.description = t.map((o) => o.description).join(", "), this.filter = (o) => o.filter((s) => i.find((n) => n(s) === false) === undefined), this.dispatchEvent(new Event("change"));
  };
  connectedCallback() {
    super.connectedCallback();
    let { filterContainer: e } = this.parts;
    e.addEventListener("change", this.buildFilter), this.reset();
  }
  render() {
    super.render();
  }
}
var Yn2 = Gt2.elementCreator({ tag: "xin-filter", styleSpec: { ":host": { height: "auto", display: "grid", gridTemplateColumns: "32px calc(100% - 64px) 32px", alignItems: "center" }, ':host [part="filterContainer"]': { display: "flex", flexDirection: "column", alignItems: "stretch", flex: "1 1 auto" }, ':host [part="haystack"]': { _fieldWidth: "100px" }, ':host [part="condition"]': { _fieldWidth: "60px" }, ':host [part="needle"]': { _fieldWidth: "80px" }, ':host [part="add"], :host [part="reset"]': { "--button-size": "var(--touch-size, 32px)", borderRadius: "999px", height: "var(--button-size)", lineHeight: "var(--button-size)", margin: "0", padding: "0", textAlign: "center", width: "var(--button-size)", flex: "0 0 var(--button-size)" } } });
var { form: Ro, slot: Qe2, xinSlot: Kt, label: Wo, input: Uo, span: $o } = m;
function q3(e, t, i) {
  if (i !== "" && i !== false)
    e.setAttribute(t, i);
  else
    e.removeAttribute(t);
}
function Go(e) {
  switch (e.type) {
    case "checkbox":
      return e.checked;
    case "radio": {
      let t = e.parentElement?.querySelector(`input[type="radio"][name="${e.name}"]:checked`);
      return t ? t.value : null;
    }
    case "range":
    case "number":
      return Number(e.value);
    default:
      return Array.isArray(e.value) && e.value.length === 0 ? null : e.value;
  }
}
function Jt(e, t) {
  if (!(e instanceof HTMLElement))
    ;
  else if (e instanceof HTMLInputElement)
    switch (e.type) {
      case "checkbox":
        e.checked = t;
        break;
      case "radio":
        e.checked = t === e.value;
        break;
      default:
        e.value = String(t || "");
    }
  else if (t != null || e.value != null)
    e.value = String(t || "");
}

class Xe3 extends B {
  caption = "";
  key = "";
  type = "";
  optional = false;
  pattern = "";
  placeholder = "";
  min = "";
  max = "";
  step = "";
  fixedPrecision = -1;
  value = null;
  content = Wo(Kt({ part: "caption" }), $o({ part: "field" }, Kt({ part: "input", name: "input" }), Uo({ part: "valueHolder" })));
  constructor() {
    super();
    this.initAttributes("caption", "key", "type", "optional", "pattern", "placeholder", "min", "max", "step", "fixedPrecision", "prefix", "suffix");
  }
  valueChanged = false;
  handleChange = () => {
    let { input: e, valueHolder: t } = this.parts, i = e.children[0] || t;
    if (i !== t)
      t.value = i.value;
    this.value = Go(i), this.valueChanged = true;
    let o = this.closest("xin-form");
    if (o && this.key !== "")
      switch (this.type) {
        case "checkbox":
          o.fields[this.key] = i.checked;
          break;
        case "number":
        case "range":
          if (this.fixedPrecision > -1)
            i.value = Number(i.value).toFixed(this.fixedPrecision), o.fields[this.key] = Number(i.value);
          else
            o.fields[this.key] = Number(i.value);
          break;
        default:
          o.fields[this.key] = i.value;
      }
  };
  initialize(e) {
    let t = e.fields[this.key] !== undefined ? e.fields[this.key] : this.value;
    if (t != null && t !== "") {
      if (e.fields[this.key] == null)
        e.fields[this.key] = t;
      this.value = t;
    }
  }
  connectedCallback() {
    super.connectedCallback();
    let { input: e, valueHolder: t } = this.parts, i = this.closest(Ce3.tagName);
    if (i instanceof Ce3)
      this.initialize(i);
    t.addEventListener("change", this.handleChange), e.addEventListener("change", this.handleChange, true);
  }
  render() {
    if (this.valueChanged) {
      this.valueChanged = false;
      return;
    }
    let { input: e, caption: t, valueHolder: i, field: o } = this.parts;
    if (t.textContent?.trim() === "")
      t.append(this.caption !== "" ? this.caption : this.key);
    if (this.type === "text") {
      e.textContent = "";
      let s = m.textarea({ value: this.value });
      if (this.placeholder)
        s.setAttribute("placeholder", this.placeholder);
      e.append(s);
    } else if (this.type === "color")
      e.textContent = "", e.append(mt({ value: this.value }));
    else if (e.children.length === 0) {
      if (q3(i, "placeholder", this.placeholder), q3(i, "type", this.type), q3(i, "pattern", this.pattern), q3(i, "min", this.min), q3(i, "max", this.max), this.step)
        q3(i, "step", this.step);
      else if (this.fixedPrecision > 0 && this.type === "number")
        q3(i, "step", Math.pow(10, -this.fixedPrecision));
    }
    if (Jt(i, this.value), Jt(e.children[0], this.value), this.prefix ? o.setAttribute("prefix", this.prefix) : o.removeAttribute("prefix"), this.suffix ? o.setAttribute("suffix", this.suffix) : o.removeAttribute("suffix"), i.classList.toggle("hidden", e.children.length > 0), e.children.length > 0)
      i.setAttribute("tabindex", "-1");
    else
      i.removeAttribute("tabindex");
    e.style.display = e.children.length === 0 ? "none" : "", q3(i, "required", !this.optional);
  }
}

class Ce3 extends B {
  context = {};
  value = {};
  get isValid() {
    return [...this.querySelectorAll("*")].filter((t) => t.required !== undefined).find((t) => !t.reportValidity()) === undefined;
  }
  static styleSpec = { ":host": { display: "flex", flexDirection: "column" }, ":host::part(header), :host::part(footer)": { display: "flex" }, ":host::part(content)": { display: "flex", flexDirection: "column", overflow: "hidden auto", height: "100%", width: "100%", position: "relative", boxSizing: "border-box" }, ":host form": { display: "flex", flex: "1 1 auto", position: "relative", overflow: "hidden" } };
  content = [Qe2({ part: "header", name: "header" }), Ro({ part: "form" }, Qe2({ part: "content" })), Qe2({ part: "footer", name: "footer" })];
  getField = (e) => {
    return this.querySelector(`xin-field[key="${e}"]`);
  };
  get fields() {
    if (typeof this.value === "string")
      try {
        this.value = JSON.parse(this.value);
      } catch (i) {
        console.log("<xin-form> could not use its value, expects valid JSON"), this.value = {};
      }
    let { getField: e } = this, t = this.dispatchEvent.bind(this);
    return new Proxy(this.value, { get(i, o) {
      return i[o];
    }, set(i, o, s) {
      if (i[o] !== s) {
        i[o] = s;
        let n = e(o);
        if (n)
          n.value = s;
        t(new Event("change"));
      }
      return true;
    } });
  }
  set fields(e) {
    let t = [...this.querySelectorAll(Xe3.tagName)];
    for (let i of t)
      i.value = e[i.key];
  }
  submit = () => {
    this.parts.form.dispatchEvent(new Event("submit"));
  };
  handleSubmit = (e) => {
    e.preventDefault(), e.stopPropagation(), this.submitCallback(this.value, this.isValid);
  };
  submitCallback = (e, t) => {
    console.log("override submitCallback to handle this data", { value: e, isValid: t });
  };
  connectedCallback() {
    super.connectedCallback();
    let { form: e } = this.parts;
    e.addEventListener("submit", this.handleSubmit);
  }
}
var sl = Xe3.elementCreator({ tag: "xin-field", styleSpec: { ':host [part="field"]': { position: "relative", display: "flex", alignItems: "center", gap: sn.prefixSuffixGap("8px") }, ':host [part="field"][prefix]::before': { content: "attr(prefix)" }, ':host [part="field"][suffix]::after': { content: "attr(suffix)" }, ':host [part="field"] > *, :host [part="input"] > *': { width: "100%" }, ":host textarea": { resize: "none" }, ':host input[type="checkbox"]': { width: "fit-content" }, ":host .hidden": { position: "absolute", pointerEvents: "none", opacity: 0 } } });
var nl = Ce3.elementCreator({ tag: "xin-form" });
var { div: G3, slot: Zt2, span: Xo, button: Zo } = m;

class Yt extends B {
  value = 0;
  localized = false;
  makeTab(e, t, i) {
    let o = t.getAttribute("name"), s = t.querySelector('template[role="tab"]')?.content.cloneNode(true) || (this.localized ? Y2(o) : Xo(o));
    return G3(s, { part: "tab", tabindex: 0, role: "tab", ariaControls: i }, t.hasAttribute("data-close") ? Zo({ title: "close", class: "close" }, c.x()) : {});
  }
  static styleSpec = { ":host": { display: "flex", flexDirection: "column", position: "relative", overflow: "hidden", boxShadow: "none !important" }, slot: { position: "relative", display: "block", flex: "1", overflow: "hidden", overflowY: "auto" }, 'slot[name="after-tabs"]': { flex: "0 0 auto" }, "::slotted([hidden])": { display: "none !important" }, ":host::part(tabpanel)": { display: "flex", flexDirection: "column", overflowX: "auto" }, ":host::part(tabrow)": { display: "flex" }, ":host .tabs": { display: "flex", userSelect: "none", whiteSpace: "nowrap" }, ":host .tabs > div": { padding: `${On.spacing50} ${On.spacing}`, cursor: "default", display: "flex", alignItems: "baseline" }, ':host .tabs > [aria-selected="true"]': { "--text-color": On.xinTabsSelectedColor, color: On.textColor }, ":host .elastic": { flex: "1" }, ":host .border": { background: "var(--xin-tabs-bar-color, #ccc)" }, ":host .border > .selected": { content: " ", width: 0, height: "var(--xin-tabs-bar-height, 2px)", background: On.xinTabsSelectedColor, transition: "ease-out 0.2s" }, ":host button.close": { border: 0, background: "transparent", textAlign: "center", marginLeft: On.spacing50, padding: 0 }, ":host button.close > svg": { height: "12px" } };
  onCloseTab = null;
  content = [G3({ role: "tabpanel", part: "tabpanel" }, G3({ part: "tabrow" }, G3({ class: "tabs", part: "tabs" }), G3({ class: "elastic" }), Zt2({ name: "after-tabs" })), G3({ class: "border" }, G3({ class: "selected", part: "selected" }))), Zt2()];
  constructor() {
    super();
    this.initAttributes("localized");
  }
  addTabBody(e, t = false) {
    if (!e.hasAttribute("name"))
      throw console.error("element has no name attribute", e), Error("element has no name attribute");
    if (this.append(e), this.setupTabs(), t)
      this.value = this.bodies.length - 1;
    this.queueRender();
  }
  removeTabBody(e) {
    e.remove(), this.setupTabs(), this.queueRender();
  }
  keyTab = (e) => {
    let { tabs: t } = this.parts, i = [...t.children].indexOf(e.target);
    switch (e.key) {
      case "ArrowLeft":
        this.value = (i + Number(t.children.length) - 1) % t.children.length, t.children[this.value].focus(), e.preventDefault();
        break;
      case "ArrowRight":
        this.value = (i + 1) % t.children.length, t.children[this.value].focus(), e.preventDefault();
        break;
      case " ":
        this.pickTab(e), e.preventDefault();
        break;
      default:
    }
  };
  get bodies() {
    return [...this.children].filter((e) => e.hasAttribute("name"));
  }
  pickTab = (e) => {
    let { tabs: t } = this.parts, i = e.target, o = i.closest("button.close") !== null, s = i.closest(".tabs > div"), n = [...t.children].indexOf(s);
    if (o) {
      let l = this.bodies[n];
      if (!this.onCloseTab || this.onCloseTab(l) !== false)
        this.removeTabBody(this.bodies[n]);
    } else if (n > -1)
      this.value = n;
  };
  setupTabs = () => {
    let { tabs: e } = this.parts, t = [...this.children].filter((i) => !i.hasAttribute("slot") && i.hasAttribute("name"));
    if (e.textContent = "", this.value >= t.length)
      this.value = t.length - 1;
    for (let i in t) {
      let o = t[i], s = `${this.instanceId}-${i}`;
      o.id = s;
      let n = this.makeTab(this, o, s);
      e.append(n);
    }
  };
  connectedCallback() {
    super.connectedCallback();
    let { tabs: e } = this.parts;
    e.addEventListener("click", this.pickTab), e.addEventListener("keydown", this.keyTab), this.setupTabs(), S2.allInstances.add(this);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), S2.allInstances.delete(this);
  }
  localeChanged = () => {
    this.queueRender();
  };
  onResize() {
    this.queueRender();
  }
  render() {
    let { tabs: e, selected: t } = this.parts, i = this.bodies;
    for (let o = 0;o < i.length; o++) {
      let s = i[o], n = e.children[o];
      if (this.value === Number(o))
        n.setAttribute("aria-selected", "true"), t.style.marginLeft = `${n.offsetLeft - e.offsetLeft}px`, t.style.width = `${n.offsetWidth}px`, s.toggleAttribute("hidden", false);
      else
        n.toggleAttribute("aria-selected", false), s.toggleAttribute("hidden", true);
    }
  }
}
var ei = Yt.elementCreator({ tag: "xin-tabs" });
var { div: we2, xinSlot: ts, style: is, button: K3, h4: zl, pre: os, code: Bl } = m;
var ss = () => "https://cdn.jsdelivr.net/npm/sucrase@3.35.0/+esm";
var ns = (async () => {}).constructor;

class Ze3 extends B {
  persistToDom = false;
  prettier = false;
  prefix = "lx";
  storageKey = "live-example-payload";
  context = {};
  uuid = crypto.randomUUID();
  remoteId = "";
  lastUpdate = 0;
  interval;
  static insertExamples(e, t = {}) {
    let i = [...e.querySelectorAll(".language-html,.language-js,.language-css")].filter((o) => !o.closest(Ze3.tagName)).map((o) => ({ block: o.parentElement, language: o.classList[0].split("-").pop(), code: o.innerText }));
    for (let o = 0;o < i.length; o += 1) {
      let s = [i[o]];
      while (o < i.length - 1 && i[o].block.nextElementSibling === i[o + 1].block)
        s.push(i[o + 1]), o += 1;
      let n = ii({ context: t });
      s[0].block.parentElement.insertBefore(n, s[0].block), s.forEach((l) => {
        switch (l.language) {
          case "js":
            n.js = l.code;
            break;
          case "html":
            n.html = l.code;
            break;
          case "css":
            n.css = l.code;
            break;
        }
        l.block.remove();
      }), n.showDefaultTab();
    }
  }
  constructor() {
    super();
    this.initAttributes("persistToDom", "prettier");
  }
  get activeTab() {
    let { editors: e } = this.parts;
    return [...e.children].find((t) => t.getAttribute("hidden") === null);
  }
  getEditorValue(e) {
    return this.parts[e].value;
  }
  setEditorValue(e, t) {
    let i = this.parts[e];
    i.value = t;
  }
  get css() {
    return this.getEditorValue("css");
  }
  set css(e) {
    this.setEditorValue("css", e);
  }
  get html() {
    return this.getEditorValue("html");
  }
  set html(e) {
    this.setEditorValue("html", e);
  }
  get js() {
    return this.getEditorValue("js");
  }
  set js(e) {
    this.setEditorValue("js", e);
  }
  updateUndo = () => {
    let { activeTab: e } = this, { undo: t, redo: i } = this.parts;
    if (e instanceof Q3 && e.editor !== undefined) {
      let o = e.editor.session.getUndoManager();
      t.disabled = !o.hasUndo(), i.disabled = !o.hasRedo();
    } else
      t.disabled = true, i.disabled = true;
  };
  undo = () => {
    let { activeTab: e } = this;
    if (e instanceof Q3)
      e.editor.undo();
  };
  redo = () => {
    let { activeTab: e } = this;
    if (e instanceof Q3)
      e.editor.redo();
  };
  get isMaximized() {
    return this.classList.contains("-maximize");
  }
  flipLayout = () => {
    this.classList.toggle("-vertical");
  };
  exampleMenu = () => {
    B3({ target: this.parts.exampleWidgets, width: "auto", menuItems: [{ icon: "edit2", caption: "view/edit code", action: this.showCode }, { icon: "edit", caption: "view/edit code in a new window", action: this.openEditorWindow }, null, { icon: this.isMaximized ? "minimize" : "maximize", caption: this.isMaximized ? "restore preview" : "maximize preview", action: this.toggleMaximize }] });
  };
  handleShortcuts = (e) => {
    if (e.metaKey || e.ctrlKey) {
      let t = false;
      switch (e.key) {
        case "s":
        case "r":
          this.refresh(), t = true;
          break;
        case "/":
          this.flipLayout();
          break;
        case "c":
          if (e.shiftKey)
            this.copy(), t = true;
          break;
      }
      if (t)
        e.preventDefault(), e.stopPropagation();
    }
  };
  content = () => [we2({ part: "example" }, is({ part: "style" }), K3({ title: "example menu", part: "exampleWidgets", onClick: this.exampleMenu }, c.code())), we2({ class: "code-editors", part: "codeEditors", onKeydown: this.handleShortcuts, hidden: true }, ei({ part: "editors", onChange: this.updateUndo }, fe3({ name: "js", mode: "javascript", part: "js" }), fe3({ name: "html", mode: "html", part: "html" }), fe3({ name: "css", mode: "css", part: "css" }), we2({ slot: "after-tabs", class: "row" }, K3({ title: "undo", part: "undo", class: "transparent", onClick: this.undo }, c.cornerUpLeft()), K3({ title: "redo", part: "redo", class: "transparent", onClick: this.redo }, c.cornerUpRight()), K3({ title: "flip direction (/ | ^/)", class: "transparent", onClick: this.flipLayout }, c.columns({ class: "layout-indicator" })), K3({ title: "copy as markdown (C | ^C)", class: "transparent", onClick: this.copy }, c.copy()), K3({ title: "reload (R | ^R)", class: "transparent", onClick: this.refreshRemote }, c.refreshCw()), K3({ title: "close code", class: "transparent", onClick: this.closeCode }, c.x())))), ts({ part: "sources", hidden: true })];
  connectedCallback() {
    super.connectedCallback();
    let { sources: e } = this.parts;
    this.initFromElements([...e.children]), addEventListener("storage", this.remoteChange), this.interval = setInterval(this.remoteChange, 500), this.undoInterval = setInterval(this.updateUndo, 250);
  }
  disconnectedCallback() {
    super.disconnectedCallback();
    let { storageKey: e, remoteKey: t } = this;
    clearInterval(this.interval), clearInterval(this.undoInterval), localStorage.setItem(e, JSON.stringify({ remoteKey: t, sentAt: Date.now(), close: true }));
  }
  copy = () => {
    let e = this.js !== "" ? "```js\n" + this.js.trim() + "\n```\n" : "", t = this.html !== "" ? "```html\n" + this.html.trim() + "\n```\n" : "", i = this.css !== "" ? "```css\n" + this.css.trim() + "\n```\n" : "";
    navigator.clipboard.writeText(e + t + i);
  };
  toggleMaximize = () => {
    this.classList.toggle("-maximize");
  };
  get remoteKey() {
    return this.remoteId !== "" ? this.prefix + "-" + this.remoteId : this.prefix + "-" + this.uuid;
  }
  remoteChange = (e) => {
    let t = localStorage.getItem(this.storageKey);
    if (e instanceof StorageEvent && e.key !== this.storageKey)
      return;
    if (t === null)
      return;
    let { remoteKey: i, sentAt: o, css: s, html: n, js: l, close: a2 } = JSON.parse(t);
    if (o <= this.lastUpdate)
      return;
    if (i !== this.remoteKey)
      return;
    if (a2 === true)
      window.close();
    console.log("received new code", o, this.lastUpdate), this.lastUpdate = o, this.css = s, this.html = n, this.js = l, this.refresh();
  };
  showCode = () => {
    this.classList.add("-maximize"), this.classList.toggle("-vertical", this.offsetHeight > this.offsetWidth), this.parts.codeEditors.hidden = false;
  };
  closeCode = () => {
    if (this.remoteId !== "")
      window.close();
    else
      this.classList.remove("-maximize"), this.parts.codeEditors.hidden = true;
  };
  openEditorWindow = () => {
    let { storageKey: e, remoteKey: t, css: i, html: o, js: s, uuid: n, prefix: l } = this, a2 = location.href.split("?")[0] + `?${l}=${n}`;
    localStorage.setItem(e, JSON.stringify({ remoteKey: t, sentAt: Date.now(), css: i, html: o, js: s })), window.open(a2);
  };
  refreshRemote = () => {
    let { remoteKey: e, css: t, html: i, js: o } = this;
    localStorage.setItem(this.storageKey, JSON.stringify({ remoteKey: e, sentAt: Date.now(), css: t, html: i, js: o }));
  };
  updateSources = () => {
    if (this.persistToDom) {
      let { sources: e } = this.parts;
      e.innerText = "";
      for (let t of ["js", "css", "html"])
        if (this[t])
          e.append(os({ class: `language-${t}`, innerHTML: this[t] }));
    }
  };
  refresh = async () => {
    if (this.remoteId !== "")
      return;
    let { transform: e } = await import(ss()), { example: t, style: i } = this.parts, o = we2({ class: "preview" });
    o.innerHTML = this.html, i.innerText = this.css;
    let s = t.querySelector(".preview");
    if (s)
      s.replaceWith(o);
    else
      t.insertBefore(o, this.parts.exampleWidgets);
    let n = { preview: o, ...this.context };
    try {
      let l = this.js;
      for (let r of Object.keys(this.context))
        l = l.replace(new RegExp(`import \\{(.*)\\} from '${r}'`, "g"), `const {$1} = ${r.replace(/-/g, "")}`);
      if (new ns(...Object.keys(n).map((r) => r.replace(/-/g, "")), e(l, { transforms: ["typescript"] }).code)(...Object.values(n)).catch((r) => console.error(r)), this.persistToDom)
        this.updateSources();
    } catch (l) {
      console.error(l), window.alert(`Error: ${l}, the console may have more information`);
    }
  };
  initFromElements(e) {
    for (let t of e) {
      t.hidden = true;
      let [i, ...o] = t.innerHTML.split(`
`);
      if (["js", "html", "css"].includes(i)) {
        let s = o.filter((l) => l.trim() !== "").map((l) => l.match(/^\s*/)[0].length).sort()[0], n = (s > 0 ? o.map((l) => l.substring(s)) : o).join(`
`);
        this.parts[i].value = n;
      } else {
        let s = ["js", "html", "css"].find((n) => t.matches(`.language-${n}`));
        if (s)
          this.parts[s].value = s === "html" ? t.innerHTML : t.innerText;
      }
    }
  }
  showDefaultTab() {
    let { editors: e } = this.parts;
    if (this.js !== "")
      e.value = 0;
    else if (this.html !== "")
      e.value = 1;
    else if (this.css !== "")
      e.value = 2;
  }
  render() {
    if (super.render(), this.remoteId !== "") {
      let e = localStorage.getItem(this.storageKey);
      if (e !== null) {
        let { remoteKey: t, sentAt: i, css: o, html: s, js: n } = JSON.parse(e);
        if (this.remoteKey !== t)
          return;
        this.lastUpdate = i, this.css = o, this.html = s, this.js = n, this.parts.example.hidden = true, this.parts.codeEditors.hidden = false, this.classList.add("-maximize"), this.updateUndo();
      }
    } else
      this.refresh();
  }
}
var ii = Ze3.elementCreator({ tag: "xin-example", styleSpec: { ":host": { "--xin-example-height": "320px", "--code-editors-bar-bg": "#777", "--code-editors-bar-color": "#fff", "--widget-bg": "#fff8", "--widget-color": "#000", position: "relative", display: "flex", height: "var(--xin-example-height)", background: "var(--background)", boxSizing: "border-box" }, ":host.-maximize": { position: "fixed", left: "0", top: "0", height: "100vh", width: "100vw", margin: "0 !important" }, ".-maximize": { zIndex: 101 }, ":host.-vertical": { flexDirection: "column" }, ":host .layout-indicator": { transition: "0.5s ease-out", transform: "rotateZ(270deg)" }, ":host.-vertical .layout-indicator": { transform: "rotateZ(180deg)" }, ":host.-maximize .hide-if-maximized, :host:not(.-maximize) .show-if-maximized": { display: "none" }, ':host [part="example"]': { flex: "1 1 50%", height: "100%", position: "relative", overflowX: "auto" }, ":host .preview": { height: "100%", position: "relative", overflow: "hidden", boxShadow: "inset 0 0 0 2px #8883" }, ':host [part="editors"]': { flex: "1 1 200px", height: "100%", position: "relative" }, ':host [part="exampleWidgets"]': { position: "absolute", left: "5px", bottom: "5px", "--widget-color": "var(--brand-color)", borderRadius: "5px", width: "44px", height: "44px", lineHeight: "44px", zIndex: "100" }, ':host [part="exampleWidgets"] svg': { stroke: "var(--widget-color)" }, ":host .code-editors": { overflow: "hidden", background: "white", position: "relative", top: "0", right: "0", flex: "1 1 50%", height: "100%", flexDirection: "column", zIndex: "10" }, ":host .code-editors:not([hidden])": { display: "flex" }, ":host .code-editors > h4": { padding: "5px", margin: "0", textAlign: "center", background: "var(--code-editors-bar-bg)", color: "var(--code-editors-bar-color)", cursor: "move" }, ":host button.transparent, :host .sizer": { width: "32px", height: "32px", lineHeight: "32px", textAlign: "center", padding: "0", margin: "0" }, ":host .sizer": { cursor: "nwse-resize" } } });
var ls = new URL(window.location.href).searchParams;
var ti = ls.get("lx");
if (ti)
  document.title += " [code editor]", document.body.textContent = "", document.body.append(ii({ remoteId: ti }));
var { div: cs } = m;

class oe3 extends B {
  coords = "65.01715565258993,25.48081004203459,12";
  content = cs({ style: { width: "100%", height: "100%" } });
  get map() {
    return this._map;
  }
  mapStyle = "mapbox://styles/mapbox/streets-v12";
  token = "";
  static mapboxCSSAvailable;
  static mapboxAvailable;
  _map;
  static styleSpec = { ":host": { display: "inline-block", position: "relative", width: "400px", height: "400px", textAlign: "left" } };
  constructor() {
    super();
    if (this.initAttributes("coords", "token", "mapStyle"), oe3.mapboxCSSAvailable === undefined)
      oe3.mapboxCSSAvailable = He3("https://api.mapbox.com/mapbox-gl-js/v1.4.1/mapbox-gl.css").catch((e) => {
        console.error("failed to load mapbox-gl.css", e);
      }), oe3.mapboxAvailable = L3("https://api.mapbox.com/mapbox-gl-js/v1.4.1/mapbox-gl.js").catch((e) => {
        console.error("failed to load mapbox-gl.js", e);
      });
  }
  connectedCallback() {
    if (super.connectedCallback(), !this.token)
      console.error("mapbox requires an access token which you can provide via the token attribute");
  }
  render() {
    if (super.render(), !this.token)
      return;
    let { div: e } = this.parts, [t, i, o] = this.coords.split(",").map((s) => Number(s));
    if (this.map)
      this.map.remove();
    oe3.mapboxAvailable.then(({ mapboxgl: s }) => {
      console.log("%cmapbox may complain about missing css -- don't panic!", "background: orange; color: black; padding: 0 5px;"), s.accessToken = this.token, this._map = new s.Map({ container: e, style: this.mapStyle, zoom: o, center: [i, t] }), this._map.on("render", () => this._map.resize());
    });
  }
}
var Hl = oe3.elementCreator({ tag: "xin-map" });
function ni(e, t) {
  if (t == null)
    t = "";
  else if (typeof t !== "string")
    t = String(t);
  return t.replace(/\{\{([^}]+)\}\}/g, (i, o) => {
    let s = f[`${e}${o.startsWith("[") ? o : "." + o}`];
    return s === undefined ? i : ni(e, String(s));
  });
}

class li extends B {
  src = "";
  value = "";
  content = null;
  elements = false;
  context = {};
  options = {};
  constructor() {
    super();
    this.initAttributes("src", "elements", "context");
  }
  connectedCallback() {
    if (super.connectedCallback(), this.src !== "")
      (async () => {
        let e = await fetch(this.src);
        this.value = await e.text();
      })();
    else if (this.value === "")
      if (this.elements)
        this.value = this.innerHTML;
      else
        this.value = this.textContent != null ? this.textContent : "";
  }
  didRender = () => {};
  render() {
    super.render(), f[this.instanceId] = typeof this.context === "string" ? JSON.parse(this.context) : this.context;
    let e = ni(this.instanceId, this.value);
    if (this.elements) {
      let t = e.split(`
`).reduce((i, o) => {
        if (o.startsWith("<") || i.length === 0)
          i.push(o);
        else {
          let s = i[i.length - 1];
          if (!s.startsWith("<") || !s.endsWith(">"))
            i[i.length - 1] += `
` + o;
          else
            i.push(o);
        }
        return i;
      }, []);
      this.innerHTML = t.map((i) => i.startsWith("<") && i.endsWith(">") ? i : k(i, this.options)).join("");
    } else
      this.innerHTML = k(e, this.options);
    this.didRender();
  }
}
var Fl = li.elementCreator({ tag: "xin-md" });
var { div: Ye2, span: Me3, button: et } = m;
var he3 = 86400000;
var us = [0, 1, 2, 3, 4, 5, 6];
var ys = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12];
var tt = (e, t = 2, i = "0") => String(e).padStart(t, i);
var ue3 = (e, t, i) => new Date(`${e}-${tt(t)}-${tt(i)}`);

class ai extends B {
  month = NaN;
  year = NaN;
  minDate = ue3(new Date().getFullYear() - 100, 1, 1).toISOString().split("T")[0];
  maxDate = ue3(new Date().getFullYear() + 10, 12, 31).toISOString().split("T")[0];
  weekStart = 0;
  selectable = false;
  multiple = false;
  range = false;
  disabled = false;
  readonly = false;
  selectedDays = [];
  value = "";
  get endDay() {
    return 1 - this.weekStart;
  }
  get months() {
    return ys.map((e) => ({ caption: ue3(2025, e, 1).toString().split(" ")[1], value: String(e) }));
  }
  get years() {
    let e = Number(this.minDate.split("-")[0]), t = Number(this.maxDate.split("-")[0]), i = [];
    for (let o = e;o <= t; o++)
      i.push(String(o));
    return i;
  }
  monthChanged = (e, t) => {};
  gotoMonth(e, t) {
    if (this.month !== t || this.year !== e)
      this.month = t, this.year = e, this.monthChanged(e, t);
  }
  setMonth = () => {
    this.gotoMonth(Number(this.parts.year.value), Number(this.parts.month.value));
  };
  get to() {
    return this.selectedDays[1] || "";
  }
  set to(e) {
    this.selectedDays[1] = e, this.selectedDays.splice(2);
  }
  get from() {
    return this.selectedDays[0] || "";
  }
  set from(e) {
    this.selectedDays[0] = e, this.selectedDays.splice(2);
  }
  clickDate = (e) => {
    let t = e.target.getAttribute("title");
    this.selectDate(t);
  };
  keyDate = (e) => {
    let t = false;
    switch (e.code) {
      case "Space":
        let i = e.target.getAttribute("title");
        this.selectDate(i), t = true;
        break;
      case "Tab":
        break;
      default:
        console.log(e);
    }
    if (t)
      e.preventDefault(), e.stopPropagation();
  };
  #e = "";
  selectDate = (e) => {
    if (this.#e = e, this.range) {
      if (!this.to)
        this.selectedDays = [e, e];
      else if (this.from === e && this.to === e)
        this.selectedDays = [];
      else if (this.from === e)
        this.from = this.to;
      else if (this.to === e)
        this.to = this.from;
      else if (e < this.from)
        this.from = e;
      else if (e > this.to)
        this.to = e;
      else if (e < this.from)
        this.from = e;
      else
        this.to = e;
      this.value = `${this.from},${this.to}`;
    } else if (this.multiple) {
      if (this.selectedDays.includes(e))
        this.selectedDays.splice(this.selectedDays.indexOf(e), 1);
      else
        this.selectedDays.push(e), this.selectedDays.sort();
      this.value = this.selectedDays.join(",");
    } else if (this.selectable)
      if (this.selectedDays.includes(e))
        this.value = "", this.selectedDays = [];
      else
        this.value = e, this.selectedDays = [e];
  };
  nextMonth = () => {
    if (this.month < 12)
      this.gotoMonth(this.year, this.month + 1);
    else
      this.gotoMonth(this.year + 1, 1);
  };
  previousMonth = () => {
    if (this.month > 1)
      this.gotoMonth(this.year, this.month - 1);
    else
      this.gotoMonth(this.year - 1, 12);
  };
  checkDay = (e) => {
    if (!this.range)
      return this.selectedDays.includes(e);
    else if (this.range)
      return this.from && e >= this.from && e <= this.to;
    return false;
  };
  dateMenuItem = (e, t = "") => {
    return e = e.split("T")[0], { caption: t || e, enabled: () => !e.startsWith(`${this.year}-${tt(this.month)}-`), action: () => {
      this.gotoDate(e);
    } };
  };
  jumpMenu = () => {
    B3({ target: this.parts.jump, menuItems: [this.dateMenuItem(new Date().toISOString(), "This Month"), ...this.selectedDays.length === 0 ? [] : [null], ...this.selectedDays.map((e) => this.dateMenuItem(e))] });
  };
  content = () => [Ye2({ part: "header" }, et({ part: "previous", onClick: this.previousMonth }, c.chevronLeft()), Me3({ style: { flex: "1" } }), et({ part: "jump", onClick: this.jumpMenu }, c.calendar()), T3({ part: "month", options: this.months, onChange: this.setMonth }), T3({ part: "year", options: [this.year], onChange: this.setMonth }), Me3({ style: { flex: "1" } }), et({ part: "next", onClick: this.nextMonth }, c.chevronRight())), Ye2({ part: "week" }), Ye2({ part: "days" })];
  gotoDate(e) {
    let t = new Date(e);
    this.gotoMonth(t.getFullYear(), t.getMonth() + 1);
  }
  constructor() {
    super();
    this.initAttributes("month", "year", "weekStart", "minDate", "maxDate", "selectable", "multiple", "range", "disabled", "readonly");
  }
  connectedCallback() {
    super.connectedCallback();
    let e = new Date(this.value.split(",").pop() || Date.now());
    if (isNaN(this.month))
      this.month = e.getMonth() + 1;
    if (isNaN(this.year))
      this.year = e.getFullYear();
  }
  days = [];
  render() {
    let { week: e, days: t, jump: i, month: o, year: s, previous: n, next: l } = this.parts;
    this.selectedDays = this.value ? this.value.split(",") : [];
    let a2 = ue3(this.year, this.month, 1), r = new Date(a2.valueOf() - (7 + a2.getDay() - this.weekStart) % 7 * he3), p = this.month === 12 ? 1 : this.month + 1, h2 = new Date(ue3(this.year + (this.month === 12 ? 1 : 0), p, 1).valueOf() - he3), d = new Date(h2.valueOf() + (this.weekStart * 2 + 5 + this.endDay - h2.getDay()) % 7 * he3), g2 = us.map((w3) => new Date(r.valueOf() + w3 * he3).toString().split(" ")[0]);
    this.days = [];
    let v3 = new Date().toISOString().split("T")[0];
    for (let w3 = r.valueOf();w3 <= d.valueOf(); w3 += he3) {
      let M3 = new Date(w3), O2 = M3.toISOString().split("T")[0];
      this.days.push({ date: M3, selected: false, inMonth: M3.getMonth() + 1 === this.month, isToday: O2 === v3, isWeekend: M3.getDay() % 6 === 0, inRange: !!(this.from && O2 >= this.from && O2 <= this.to) });
    }
    o.value = String(this.month), s.value = String(this.year);
    let ne2 = (o.disabled = s.disabled = i.disabled = n.disabled = l.disabled = this.disabled || this.readonly) || !this.selectable && !this.range && !this.multiple;
    s.options = this.years, e.textContent = "", e.append(...g2.map((w3) => Me3({ class: "day" }, w3))), t.textContent = "";
    let Se3 = null, { to: zi, from: Bi } = this;
    if (t.append(...this.days.map((w3) => {
      let M3 = ["date"];
      if (w3.inMonth)
        M3.push("in-month");
      if (w3.isToday)
        M3.push("today");
      let O2 = w3.date.toISOString().split("T")[0];
      if (this.checkDay(O2))
        M3.push("checked");
      if (M3.push(w3.isWeekend ? "weekend" : "weekday"), this.range) {
        if (zi === O2)
          M3.push("range-end");
        if (Bi === O2)
          M3.push("range-start");
      }
      let at = Me3({ class: M3.join(" "), title: O2, onClick: this.clickDate, onKeydown: this.keyDate, tabindex: "0" }, w3.date.getDate());
      if (O2 === this.#e)
        Se3 = at;
      return at;
    })), Se3)
      Se3.focus();
  }
}
var $l = ai.elementCreator({ tag: "tosi-month", styleSpec: { ":host": { display: "block" }, ":host [part=header]": { display: "flex", alignItems: "stretch", justifyContent: "stretch" }, ":host[disabled]": { pointerEvents: "none", opacity: sn.disabledOpacity(0.6) }, ':host [part="month"], :host [part="year"]': { _fieldWidth: "4em", flex: "1" }, ":host [part=week], :host [part=days]": { display: "grid", gridTemplateColumns: "auto auto auto auto auto auto auto", justifyItems: "stretch" }, ":host .today": { background: sn.monthTodayBackground("transparent"), boxShadow: sn.monthTodayShadow("none"), backdropFilter: sn.monthTodayBackdropFilter("brightness(0.9)"), fontWeight: sn.monthTodayFontWeight("800") }, ":host .day, :host .date": { padding: 5, display: "flex", justifyContent: "center", userSelect: "none" }, ":host .day": { color: sn.monthDayColor("hotpink"), background: sn.monthDayBackground("white"), fontWeight: sn.monthDayFontWeight("800") }, ":host .date": { cursor: "default" }, ":host .weekend": { background: sn.monthWeekendBackground("#eee") }, ":host .date:not(.in-month)": { opacity: 0.5 }, ":host .date.checked": { color: sn.monthDateCheckedColor("white"), background: sn.monthDateCheckedBackground("hotpink") }, ":host:not([range]) .date.checked": { borderRadius: sn.monthDateCheckedBorderRadius("10px") }, ":host .range-start": { borderTopLeftRadius: sn.monthDateCheckedBorderRadius("10px"), borderBottomLeftRadius: sn.monthDateCheckedBorderRadius("10px") }, ":host .range-end": { borderTopRightRadius: sn.monthDateCheckedBorderRadius("10px"), borderBottomRightRadius: sn.monthDateCheckedBorderRadius("10px") } } });
var { div: it, button: gs } = m;
var fs = { error: "red", warn: "orange", info: "royalblue", log: "gray", success: "green", progress: "royalblue" };

class se3 extends B {
  static singleton;
  static styleSpec = { ":host": { _notificationSpacing: 8, _notificationWidth: 360, _notificationPadding: `${On.notificationSpacing} ${On.notificationSpacing50} ${On.notificationSpacing} ${On.notificationSpacing200}`, _notificationBg: "#fafafa", _notificationAccentColor: "#aaa", _notificationTextColor: "#444", _notificationIconSize: On.notificationSpacing300, _notificationButtonSize: 48, _notificationBorderWidth: "3px 0 0", _notificationBorderRadius: On.notificationSpacing50, position: "fixed", left: 0, right: 0, bottom: 0, paddingBottom: On.notificationSpacing, width: On.notificationWidth, display: "flex", flexDirection: "column-reverse", margin: "0 auto", gap: On.notificationSpacing, maxHeight: "50vh", overflow: "hidden auto", boxShadow: "none !important" }, ":host *": { color: On.notificationTextColor }, ":host .note": { display: "grid", background: On.notificationBg, padding: On.notificationPadding, gridTemplateColumns: `${On.notificationIconSize} 1fr ${On.notificationButtonSize}`, gap: On.notificationSpacing, alignItems: "center", borderRadius: On.notificationBorderRadius, boxShadow: `0 2px 8px #0006, inset 0 0 0 2px ${On.notificationAccentColor}`, borderColor: On.notificationAccentColor, borderWidth: On.notificationBorderWidth, borderStyle: "solid", transition: "0.5s ease-in", transitionProperty: "margin, opacity", zIndex: 1 }, ":host .note .icon": { stroke: On.notificationAccentColor }, ":host .note button": { display: "flex", lineHeight: On.notificationButtonSize, padding: 0, margin: 0, height: On.notificationButtonSize, width: On.notificationButtonSize, background: "transparent", alignItems: "center", justifyContent: "center", boxShadow: "none", border: "none", position: "relative" }, ":host .note button:hover svg": { stroke: On.notificationAccentColor }, ":host .note button:active svg": { borderRadius: 99, stroke: On.notificationBg, background: On.notificationAccentColor, padding: On.spacing50 }, ":host .note svg": { height: On.notificationIconSize, width: On.notificationIconSize, pointerEvents: "none" }, ":host .message": { display: "flex", flexDirection: "column", alignItems: "center", gap: On.notificationSpacing }, ":host .note.closing": { opacity: 0, zIndex: 0 } };
  static removeNote(e) {
    e.classList.add("closing"), e.style.marginBottom = -e.offsetHeight + "px";
    let t = () => {
      e.remove();
    };
    e.addEventListener("transitionend", t), setTimeout(t, 1000);
  }
  static post(e) {
    let { message: t, duration: i, type: o, close: s, progress: n, icon: l, color: a2 } = Object.assign({ type: "info", duration: -1 }, typeof e === "string" ? { message: e } : e);
    if (!this.singleton)
      this.singleton = vs();
    let r = this.singleton;
    document.body.append(r), r.style.zIndex = String(X3() + 1);
    let p = a2 || fs[o], h2 = n || o === "progress" ? m.progress() : {}, d = () => {
      if (s)
        s();
      se3.removeNote(v3);
    }, g2 = l instanceof SVGElement ? l : l ? c[l]({ class: "icon" }) : c.info({ class: "icon" }), v3 = it({ class: `note ${o}`, style: { _notificationAccentColor: p } }, g2, it({ class: "message" }, it(t), h2), gs({ class: "close", title: "close", apply(H2) {
      H2.addEventListener("click", d);
    } }, c.x()));
    if (r.shadowRoot.append(v3), h2 instanceof HTMLProgressElement && n instanceof Function) {
      h2.setAttribute("max", String(100)), h2.value = n();
      let H2 = setInterval(() => {
        if (!r.shadowRoot.contains(v3)) {
          clearInterval(H2);
          return;
        }
        let ne2 = n();
        if (h2.value = ne2, ne2 >= 100)
          se3.removeNote(v3);
      }, 1000);
    }
    if (i > 0)
      setTimeout(() => {
        se3.removeNote(v3);
      }, i * 1000);
    return v3.scrollIntoView(), d;
  }
  content = null;
}
var vs = se3.elementCreator({ tag: "xin-notification" });
var ks = async (e, t = "SHA-1") => {
  let o = new TextEncoder().encode(e), s = await crypto.subtle.digest(t, o);
  return Array.from(new Uint8Array(s)).map((a2) => a2.toString(16).padStart(2, "0")).join("");
};
var Cs = async (e) => {
  let t = await ks(e), i = await fetch(`https://weakpass.com/api/v1/search/${t}`);
  if (i.ok) {
    let o = await i.json();
    console.log("password found in weakpass database", o);
  }
  return i.status !== 404;
};
var { span: ot, xinSlot: ws } = m;

class ci extends B {
  minLength = 8;
  goodLength = 12;
  indicatorColors = "#f00,#f40,#f80,#ef0,#8f0,#0a2";
  descriptionColors = "#000,#000,#000,#000,#000,#fff";
  issues = { tooShort: true, short: true, noUpper: true, noLower: true, noNumber: true, noSpecial: true };
  issueDescriptions = { tooShort: "too short", short: "short", noUpper: "no upper case", noLower: "no lower case", noNumber: "no digits", noSpecial: "no unusual characters" };
  value = 0;
  strengthDescriptions = ["unacceptable", "very weak", "weak", "moderate", "strong", "very strong"];
  constructor() {
    super();
    this.initAttributes("minLength", "goodLength", "indicatorColors");
  }
  strength(e) {
    return this.issues = { tooShort: e.length < this.minLength, short: e.length < this.goodLength, noUpper: !e.match(/[A-Z]/), noLower: !e.match(/[a-z]/), noNumber: !e.match(/[0-9]/), noSpecial: !e.match(/[^a-zA-Z0-9]/) }, this.issues.tooShort ? 0 : Object.values(this.issues).filter((t) => !t).length - 1;
  }
  async isBreached() {
    let e = this.querySelector("input")?.value;
    if (!e || typeof e !== "string")
      return true;
    return await Cs(e);
  }
  updateIndicator = (e) => {
    let { level: t, description: i } = this.parts, o = this.indicatorColors.split(","), s = this.descriptionColors.split(","), n = this.strength(e);
    if (this.value !== n)
      this.value = n, this.dispatchEvent(new Event("change"));
    t.style.width = `${(n + 1) * 16.67}%`, this.style.setProperty("--indicator-color", o[n]), this.style.setProperty("--description-color", s[n]), i.textContent = this.strengthDescriptions[n];
  };
  update = (e) => {
    let t = e.target.closest("input");
    this.updateIndicator(t?.value || "");
  };
  content = () => [ws({ onInput: this.update }), ot({ part: "meter" }, ot({ part: "level" }), ot({ part: "description" }))];
  render() {
    super.render();
    let e = this.querySelector("input");
    this.updateIndicator(e?.value);
  }
}
var ta = ci.elementCreator({ tag: "xin-password-strength", styleSpec: { ":host": { display: "inline-flex", flexDirection: "column", gap: On.spacing50, position: "relative" }, ":host xin-slot": { display: "flex" }, ':host [part="meter"]': { display: "block", position: "relative", height: sn.meterHeight("24px"), background: sn.indicatorBg("white"), borderRadius: sn.meterRadius("4px"), boxShadow: sn.meterShadow(`inset 0 0 0 2px ${On.indicatorColor}`) }, ':host [part="level"]': { height: sn.levelHeight("20px"), content: '" "', display: "inline-block", width: 0, transition: "0.15s ease-out", background: On.indicatorColor, margin: sn.levelMargin("2px"), borderRadius: sn.levelRadius("2px") }, ':host [part="description"]': { position: "absolute", inset: "0", color: On.descriptionColor, height: sn.meterHeight("24px"), lineHeight: sn.meterHeight("24px"), textAlign: "center" } } });
var { span: st } = m;

class pi extends B {
  iconSize = 24;
  min = 1;
  max = 5;
  step = 1;
  value = null;
  icon = "star";
  ratingFill = "#f91";
  ratingStroke = "#e81";
  emptyFill = "#ccc";
  emptyStroke = "none";
  readonly = false;
  hollow = false;
  static styleSpec = { ":host": { display: "inline-block", position: "relative", width: "fit-content" }, ":host::part(container)": { position: "relative", display: "inline-block" }, ":host::part(empty), :host::part(filled)": { height: "100%", whiteSpace: "nowrap", overflow: "hidden" }, ":host::part(empty)": { pointerEvents: "none", _xinIconFill: On.emptyFill, _xinIconStroke: On.emptyStroke }, ":host::part(filled)": { position: "absolute", left: 0, _xinIconFill: On.ratingFill, _xinIconStroke: On.ratingStroke }, ":host svg": { transform: "scale(0.9)", pointerEvents: "all !important", transition: "0.25s ease-in-out" }, ":host svg:hover": { transform: "scale(1)" }, ":host svg:active": { transform: "scale(1.1)" } };
  constructor() {
    super();
    this.initAttributes("max", "min", "icon", "step", "ratingStroke", "ratingColor", "emptyStroke", "emptyColor", "readonly", "iconSize", "hollow");
  }
  content = () => st({ part: "container" }, st({ part: "empty" }), st({ part: "filled" }));
  displayValue(e) {
    let { empty: t, filled: i } = this.parts, o = Math.round((e || 0) / this.step) * this.step;
    i.style.width = o / this.max * t.offsetWidth + "px";
  }
  update = (e) => {
    if (this.readonly)
      return;
    let { empty: t } = this.parts, i = e instanceof MouseEvent ? e.pageX - t.getBoundingClientRect().x : 0, o = Math.min(Math.max(this.min, Math.round(i / t.offsetWidth * this.max / this.step + this.step * 0.5) * this.step), this.max);
    if (e.type === "click")
      this.value = o;
    else if (e.type === "mousemove")
      this.displayValue(o);
    else
      this.displayValue(this.value || 0);
  };
  handleKey = (e) => {
    let t = Number(this.value);
    if (t == null)
      t = Math.round((this.min + this.max) * 0.5 * this.step) * this.step;
    let i = false;
    switch (e.key) {
      case "ArrowUp":
      case "ArrowRight":
        t += this.step, i = true;
        break;
      case "ArrowDown":
      case "ArrowLeft":
        t -= this.step, i = true;
        break;
    }
    if (this.value = Math.max(Math.min(t, this.max), this.min), i)
      e.stopPropagation(), e.preventDefault();
  };
  connectedCallback() {
    super.connectedCallback();
    let { container: e } = this.parts;
    e.tabIndex = 0, e.addEventListener("mousemove", this.update, true), e.addEventListener("mouseleave", this.update), e.addEventListener("blur", this.update), e.addEventListener("click", this.update), e.addEventListener("keydown", this.handleKey);
  }
  _renderedIcon = "";
  render() {
    super.render();
    let e = this.iconSize + "px";
    if (this.style.setProperty("--rating-fill", this.ratingFill), this.style.setProperty("--rating-stroke", this.ratingStroke), this.style.setProperty("--empty-fill", this.emptyFill), this.style.setProperty("--empty-stroke", this.emptyStroke), this.style.setProperty("--xin-icon-size", e), this.readonly)
      this.role = "image";
    else
      this.role = "slider";
    this.ariaLabel = `rating ${this.value} out of ${this.max}`, this.ariaValueMax = String(this.max), this.ariaValueMin = String(this.min), this.ariaValueNow = this.value === null ? String(-1) : String(this.value);
    let { empty: t, filled: i } = this.parts;
    if (t.classList.toggle("hollow", this.hollow), this._renderedIcon !== this.icon) {
      this._renderedIcon = this.icon;
      for (let o = 0;o < this.max; o++)
        t.append(c[this.icon]()), i.append(c[this.icon]());
    }
    this.displayValue(this.value);
  }
}
var aa = pi.elementCreator({ tag: "xin-rating" });
var { xinSlot: di, div: Ss, button: As, span: hi } = m;
var Es = [{ caption: "Title", tagType: "H1" }, { caption: "Heading", tagType: "H2" }, { caption: "Subheading", tagType: "H3" }, { caption: "Minor heading", tagType: "H4" }, { caption: "Body", tagType: "P" }, { caption: "Code Block", tagType: "PRE" }];
function ui(e = Es) {
  return T3({ title: "paragraph style", slot: "toolbar", class: "block-style", options: e.map(({ caption: t, tagType: i }) => ({ caption: t, value: `formatBlock,${i}` })) });
}
function ye3(e = "10px") {
  return hi({ slot: "toolbar", style: { flex: `0 0 ${e}`, content: " " } });
}
function I3(e, t, i) {
  return As({ slot: "toolbar", dataCommand: t, title: e }, i);
}
var Hs = () => [I3("left-justify", "justifyLeft", c.alignLeft()), I3("center", "justifyCenter", c.alignCenter()), I3("right-justify", "justifyRight", c.alignRight()), ye3(), I3("bullet list", "insertUnorderedList", c.listBullet()), I3("numbered list", "insertOrderedList", c.listNumber()), ye3(), I3("indent", "indent", c.indent()), I3("indent", "outdent", c.outdent())];
var yi = () => [I3("bold", "bold", c.fontBold()), I3("italic", "italic", c.fontItalic()), I3("underline", "underline", c.fontUnderline())];
var Ts = () => [ui(), ye3(), ...yi()];
var Ps = () => [ui(), ye3(), ...Hs(), ye3(), ...yi()];

class xi extends B {
  widgets = "default";
  isInitialized = false;
  get value() {
    return this.isInitialized ? this.parts.doc.innerHTML : this.savedValue || this.innerHTML;
  }
  set value(e) {
    if (this.isInitialized)
      this.parts.doc.innerHTML = e;
    else
      this.innerHTML = e;
  }
  blockElement(e) {
    let { doc: t } = this.parts;
    while (e.parentElement !== null && e.parentElement !== t)
      e = e.parentElement;
    return e.parentElement === t ? e : undefined;
  }
  get selectedBlocks() {
    let { doc: e } = this.parts, t = window.getSelection();
    if (t === null)
      return [];
    let i = [];
    for (let o = 0;o < t.rangeCount; o++) {
      let s = t.getRangeAt(o);
      if (!e.contains(s.commonAncestorContainer))
        continue;
      let n = this.blockElement(s.startContainer), l = this.blockElement(s.endContainer);
      i.push(n);
      while (n !== l && n !== null)
        n = n.nextElementSibling, i.push(n);
    }
    return i;
  }
  get selectedText() {
    let e = window.getSelection();
    if (e === null)
      return "";
    return this.selectedBlocks.length ? e.toString() : "";
  }
  selectionChange = () => {};
  handleSelectChange = (e) => {
    let t = e.target.closest(Z2.tagName);
    if (t == null)
      return;
    this.doCommand(t.value);
  };
  handleButtonClick = (e) => {
    let t = e.target.closest("button");
    if (t == null)
      return;
    this.doCommand(t.dataset.command);
  };
  content = [di({ name: "toolbar", part: "toolbar", onClick: this.handleButtonClick, onChange: this.handleSelectChange }), Ss({ part: "doc", contenteditable: true, style: { flex: "1 1 auto", outline: "none" } }), di({ part: "content" })];
  constructor() {
    super();
    this.initAttributes("widgets");
  }
  doCommand(e) {
    if (e === undefined)
      return;
    let t = e.split(",");
    console.log("execCommand", t[0], false, ...t.slice(1)), document.execCommand(t[0], false, ...t.slice(1));
  }
  updateBlockStyle() {
    let e = this.parts.toolbar.querySelector(".block-style");
    if (e === null)
      return;
    let t = this.selectedBlocks.map((i) => i.tagName);
    t = [...new Set(t)], e.value = t.length === 1 ? `formatBlock,${t[0]}` : "";
  }
  connectedCallback() {
    super.connectedCallback();
    let { doc: e, content: t } = this.parts;
    if (t.innerHTML !== "" && e.innerHTML === "")
      e.innerHTML = t.innerHTML, t.innerHTML = "";
    this.isInitialized = true, t.style.display = "none", document.addEventListener("selectionchange", (i) => {
      this.updateBlockStyle(), this.selectionChange(i, this);
    });
  }
  render() {
    let { toolbar: e } = this.parts;
    if (super.render(), e.children.length === 0)
      switch (this.widgets) {
        case "minimal":
          e.append(...Ts());
          break;
        case "default":
          e.append(...Ps());
          break;
      }
  }
}
var xa = xi.elementCreator({ tag: "xin-word", styleSpec: { ":host": { display: "flex", flexDirection: "column", height: "100%" }, ':host [part="toolbar"]': { padding: 4, display: "flex", gap: "0px", flex: "0 0 auto", flexWrap: "wrap" }, ':host [part="toolbar"] > button': { _xinIconSize: 18 } } });
var { div: js, slot: Fs, label: Vs, span: Ds, input: gi } = m;

class fi2 extends B {
  choices = "";
  other = "";
  multiple = false;
  name = "";
  placeholder = "Please specify";
  localized = false;
  value = null;
  get values() {
    return (this.value || "").split(",").map((e) => e.trim()).filter((e) => e !== "");
  }
  content = () => [Fs(), js({ part: "options" }, gi({ part: "custom", hidden: true }))];
  static styleSpec = { ":host": { display: "inline-flex", gap: sn.segmentedOptionGap("8px"), alignItems: sn.segmentedAlignItems("center") }, ":host, :host::part(options)": { flexDirection: sn.segmentedDirection("row") }, ":host label": { display: "inline-grid", alignItems: "center", gap: sn.segmentedOptionGap("8px"), gridTemplateColumns: sn.segmentedOptionGridColumns("0px 24px 1fr"), padding: sn.segmentedOptionPadding("4px 12px"), font: sn.segmentedOptionFont("16px") }, ":host label:focus": { outline: "none", boxShadow: sn.segmentedFocusShadow(`inset 0 0 0 2px ${sn.segmentedOptionCurrentBackground("#44a")}`), borderRadius: sn.segmentedOptionsBorderRadius("8px") }, ":host label:has(:checked)": { color: sn.segmentedOptionCurrentColor("#eee"), background: sn.segmentedOptionCurrentBackground("#44a") }, ":host label:has(:checked):focus": { boxShadow: sn.segmentedCurrentFocusShadow(`inset 0 0 0 2px ${sn.segmentedOptionCurrentColor("#eee")}`) }, ":host svg": { height: sn.segmentOptionIconSize("16px"), stroke: sn.segmentedOptionIconColor("currentColor") }, ":host label.no-icon": { gap: 0, gridTemplateColumns: sn.segmentedOptionGridColumns("0px 1fr") }, ':host input[type="radio"], :host input[type="checkbox"]': { visibility: sn.segmentedInputVisibility("hidden") }, ":host::part(options)": { display: "flex", borderRadius: sn.segmentedOptionsBorderRadius("8px"), background: sn.segmentedOptionsBackground("#fff"), color: sn.segmentedOptionColor("#222"), overflow: "hidden", alignItems: sn.segmentedOptionAlignItems("stretch") }, ":host::part(custom)": { padding: sn.segmentedOptionPadding("4px 12px"), color: sn.segmentedOptionCurrentColor("#eee"), background: sn.segmentedOptionCurrentBackground("#44a"), font: sn.segmentedOptionFont("16px"), border: "0", outline: "none" }, ":host::part(custom)::placeholder": { color: sn.segmentedOptionCurrentColor("#eee"), opacity: sn.segmentedPlaceholderOpacity(0.75) } };
  constructor() {
    super();
    this.initAttributes("direction", "choices", "other", "multiple", "name", "placeholder", "localized");
  }
  valueChanged = false;
  handleChange = () => {
    let { options: e, custom: t } = this.parts;
    if (this.multiple) {
      let i = [...e.querySelectorAll("input:checked")];
      this.value = i.map((o) => o.value).join(",");
    } else {
      let i = e.querySelector("input:checked");
      if (!i)
        this.value = null;
      else if (i.value)
        t.setAttribute("hidden", ""), this.value = i.value;
      else
        t.removeAttribute("hidden"), t.focus(), t.select(), this.value = t.value;
    }
    this.valueChanged = true;
  };
  handleKey = (e) => {
    let t = false;
    switch (e.code) {
      case "Space":
        if (e.target instanceof HTMLLabelElement)
          e.target.click(), t = true;
        break;
      case "Tab":
        if (!(e.target instanceof HTMLLabelElement))
          e.target.closest("label").focus();
        break;
      case "ArrowLeft":
      case "ArrowUp":
        {
          let i = e.target.closest("label");
          if (i.previousElementSibling instanceof HTMLLabelElement)
            i.previousElementSibling.focus();
        }
        t = true;
        break;
      case "ArrowRight":
      case "ArrowDown":
        {
          let i = e.target.closest("label");
          if (i.nextElementSibling instanceof HTMLLabelElement)
            i.nextElementSibling.focus();
        }
        t = true;
        break;
    }
    if (t)
      e.preventDefault(), e.stopPropagation();
  };
  connectedCallback() {
    super.connectedCallback();
    let { options: e } = this.parts;
    if (this.name === "")
      this.name = this.instanceId;
    if (e.addEventListener("change", this.handleChange), e.addEventListener("keydown", this.handleKey), this.other && this.multiple)
      console.warn(this, "is set to [other] and [multiple]; [other] will be ignored"), this.other = "";
  }
  get _choices() {
    let e = Array.isArray(this.choices) ? this.choices : this.choices.split(",").filter((t) => t.trim() !== "").map((t) => {
      let [i, o] = t.split("=").map((r) => r.trim()), [s, n] = (o || i).split(":").map((r) => r.trim()), l = n ? c[n]() : "";
      return { value: i, icon: l, caption: s };
    });
    if (this.other && !this.multiple) {
      let [t, i] = this.other.split(":");
      e.push({ value: "", caption: t, icon: i });
    }
    return e;
  }
  get isOtherValue() {
    return Boolean(this.value === "" || this.value && !this._choices.find((e) => e.value === this.value));
  }
  render() {
    if (super.render(), this.valueChanged) {
      this.valueChanged = false;
      return;
    }
    let { options: e, custom: t } = this.parts;
    e.textContent = "";
    let i = this.multiple ? "checkbox" : "radio", { values: o, isOtherValue: s } = this;
    if (e.append(...this._choices.map((n) => {
      return Vs({ tabindex: 0 }, gi({ type: i, name: this.name, value: n.value, checked: o.includes(n.value) || n.value === "" && s, tabIndex: -1 }), n.icon || { class: "no-icon" }, this.localized ? Y2(n.caption) : Ds(n.caption));
    })), this.other && !this.multiple)
      t.hidden = !s, t.value = s ? this.value : "", t.placeholder = this.placeholder, e.append(t);
  }
}
var ka = fi2.elementCreator({ tag: "xin-segmented" });
var { slot: vi } = m;

class mi extends B {
  minSize = 800;
  navSize = 200;
  compact = false;
  contentVisible = false;
  value = "normal";
  content = [vi({ name: "nav", part: "nav" }), vi({ part: "content" })];
  static styleSpec = { ":host": { display: "grid", gridTemplateColumns: `${sn.navWidth("50%")} ${sn.contentWidth("50%")}`, gridTemplateRows: "100%", position: "relative", margin: sn.margin("0 0 0 -100%"), transition: sn.sideNavTransition("0.25s ease-out") }, ":host slot": { position: "relative" }, ":host slot:not([name])": { display: "block" }, ':host slot[name="nav"]': { display: "block" } };
  onResize = () => {
    let { content: e } = this.parts, t = this.offsetParent;
    if (t === null)
      return;
    let i = this.value;
    if (this.compact = t.offsetWidth < this.minSize, [...this.childNodes].find((s) => s instanceof Element ? s.getAttribute("slot") !== "nav" : true) === undefined)
      i = "compact/nav", this.style.setProperty("--nav-width", "100%"), this.style.setProperty("--content-width", "0%");
    else if (!this.compact)
      i = "normal", e.classList.add("-xin-sidenav-visible"), this.style.setProperty("--nav-width", `${this.navSize}px`), this.style.setProperty("--content-width", `calc(100% - ${this.navSize}px)`), this.style.setProperty("--margin", "0");
    else if (e.classList.remove("-xin-sidenav-visible"), this.style.setProperty("--nav-width", "50%"), this.style.setProperty("--content-width", "50%"), this.contentVisible)
      i = "compact/content", this.style.setProperty("--margin", "0 0 0 -100%");
    else
      i = "compact/nav", this.style.setProperty("--margin", "0 -100% 0 0");
    if (this.value !== i)
      this.value = i;
  };
  observer;
  connectedCallback() {
    super.connectedCallback(), this.contentVisible = this.parts.content.childNodes.length === 0, globalThis.addEventListener("resize", this.onResize), this.observer = new MutationObserver(this.onResize), this.observer.observe(this, { childList: true }), this.style.setProperty("--side-nav-transition", "0s"), setTimeout(() => {
      this.style.removeProperty("--side-nav-transition");
    }, 250);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), this.observer.disconnect();
  }
  constructor() {
    super();
    this.initAttributes("minSize", "navSize", "compact", "contentVisible");
  }
  render() {
    super.render(), this.onResize();
  }
}
var za = mi.elementCreator({ tag: "xin-sidenav" });
var { slot: bi } = m;

class ki extends B {
  minWidth = 0;
  minHeight = 0;
  value = "normal";
  content = [bi({ part: "normal" }), bi({ part: "small", name: "small" })];
  static styleSpec = { ":host": { display: "inline-block", position: "relative" } };
  constructor() {
    super();
    this.initAttributes("minWidth", "minHeight");
  }
  onResize = () => {
    let { normal: e, small: t } = this.parts, i = this.offsetParent;
    if (!(i instanceof HTMLElement))
      return;
    else if (i.offsetWidth < this.minWidth || i.offsetHeight < this.minHeight)
      e.hidden = true, t.hidden = false, this.value = "small";
    else
      e.hidden = false, t.hidden = true, this.value = "normal";
  };
  connectedCallback() {
    super.connectedCallback(), globalThis.addEventListener("resize", this.onResize);
  }
  disconnectedCallback() {
    super.disconnectedCallback(), globalThis.removeEventListener("resize", this.onResize);
  }
}
var Aa = ki.elementCreator({ tag: "xin-sizebreak" });

class Ci extends B {
  target = null;
  static styleSpec = { ":host": { _resizeIconFill: "#222", display: "block", position: "absolute", bottom: -7, right: -7, padding: 14, width: 44, height: 44, opacity: 0.25, transition: "opacity 0.25s ease-out" }, ":host(:hover)": { opacity: 0.5 }, ":host svg": { width: 16, height: 16, stroke: On.resizeIconFill } };
  content = c.resize();
  get minSize() {
    let { minWidth: e, minHeight: t } = getComputedStyle(this.target);
    return { width: parseFloat(e) || 32, height: parseFloat(t) || 32 };
  }
  resizeTarget = (e) => {
    let { target: t } = this;
    if (!t)
      return;
    let { offsetWidth: i, offsetHeight: o } = t;
    t.style.left = t.offsetLeft + "px", t.style.top = t.offsetTop + "px", t.style.bottom = "", t.style.right = "";
    let { minSize: s } = this;
    z3(e, (n, l, a2) => {
      if (t.style.width = Math.max(s.width, i + n) + "px", t.style.height = Math.max(s.height, o + l) + "px", a2.type === "mouseup")
        return true;
    }, "nwse-resize");
  };
  connectedCallback() {
    if (super.connectedCallback(), !this.target)
      this.target = this.parentElement;
    let e = { passive: true };
    this.addEventListener("mousedown", this.resizeTarget, e), this.addEventListener("touchstart", this.resizeTarget, e);
  }
}
var Oa = Ci.elementCreator({ tag: "xin-sizer" });
var { div: Gs, input: Ks, span: Js, button: nt } = m;

class lt extends B {
  caption = "";
  removeable = false;
  removeCallback = () => {
    this.remove();
  };
  content = () => [Js({ part: "caption" }, this.caption), nt(c.x(), { part: "remove", hidden: !this.removeable, onClick: this.removeCallback })];
  constructor() {
    super();
    this.initAttributes("caption", "removeable");
  }
}
var Qs = lt.elementCreator({ tag: "xin-tag", styleSpec: { ":host": { "--tag-close-button-color": "#000c", "--tag-close-button-bg": "#fffc", "--tag-button-opacity": "0.5", "--tag-button-hover-opacity": "0.75", "--tag-bg": sn.brandColor("blue"), "--tag-text-color": sn.brandTextColor("white"), display: "inline-flex", borderRadius: sn.tagRoundedRadius(On.spacing50), color: On.tagTextColor, background: On.tagBg, padding: `0 ${On.spacing75} 0 ${On.spacing75}`, height: `calc(${On.lineHeight} + ${On.spacing50})`, lineHeight: `calc(${On.lineHeight} + ${On.spacing50})` }, ':host > [part="caption"]': { position: "relative", whiteSpace: "nowrap", overflow: "hidden", flex: "1 1 auto", fontSize: sn.fontSize("16px"), color: On.tagTextColor, textOverflow: "ellipsis" }, ':host [part="remove"]': { boxShadow: "none", margin: `0 ${On.spacing_50} 0 ${On.spacing25}`, padding: 0, display: "inline-flex", alignItems: "center", alignSelf: "center", justifyContent: "center", height: On.spacing150, width: On.spacing150, color: On.tagCloseButtonColor, background: On.tagCloseButtonBg, borderRadius: sn.tagCloseButtonRadius("99px"), opacity: On.tagButtonOpacity }, ':host [part="remove"]:hover': { background: On.tagCloseButtonBg, opacity: On.tagButtonHoverOpacity } } });

class Mi extends B {
  disabled = false;
  name = "";
  availableTags = [];
  value = [];
  textEntry = false;
  editable = false;
  placeholder = "enter tags";
  get tags() {
    return typeof this.value === "string" ? this.value.split(",").map((e) => e.trim()).filter((e) => e !== "") : this.value;
  }
  constructor() {
    super();
    this.initAttributes("name", "value", "textEntry", "availableTags", "editable", "placeholder", "disabled");
  }
  addTag = (e) => {
    if (e.trim() === "")
      return;
    let { tags: t } = this;
    if (!t.includes(e))
      t.push(e);
    this.value = t, this.queueRender(true);
  };
  toggleTag = (e) => {
    if (this.tags.includes(e))
      this.value = this.tags.filter((t) => t !== e);
    else
      this.addTag(e);
    this.queueRender(true);
  };
  enterTag = (e) => {
    let { tagInput: t } = this.parts;
    switch (e.key) {
      case ",":
        {
          let i = t.value.split(",")[0];
          this.addTag(i);
        }
        break;
      case "Enter":
        {
          let i = t.value.split(",")[0];
          this.addTag(i);
        }
        e.stopPropagation(), e.preventDefault();
        break;
      default:
    }
  };
  popSelectMenu = () => {
    let { toggleTag: e } = this, { tagMenu: t } = this.parts, i = typeof this.availableTags === "string" ? this.availableTags.split(",") : this.availableTags, o = this.tags.filter((n) => !i.includes(n));
    if (o.length)
      i.push(null, ...o);
    let s = i.map((n) => {
      if (n === "" || n === null)
        return null;
      else if (typeof n === "object")
        return { checked: () => this.tags.includes(n.value), caption: n.caption, action() {
          e(n.value);
        } };
      else
        return { checked: () => this.tags.includes(n), caption: n, action() {
          e(n);
        } };
    });
    B3({ target: t, width: "auto", menuItems: s });
  };
  content = () => [nt({ style: { visibility: "hidden" }, tabindex: -1 }), Gs({ part: "tagContainer", class: "row" }), Ks({ part: "tagInput", class: "elastic", onKeydown: this.enterTag }), nt({ title: "add tag", part: "tagMenu", onClick: this.popSelectMenu }, c.chevronDown())];
  removeTag = (e) => {
    if (this.editable && !this.disabled) {
      let t = e.target.closest(lt.tagName);
      this.value = this.tags.filter((i) => i !== t.caption), t.remove(), this.queueRender(true);
    }
    e.stopPropagation(), e.preventDefault();
  };
  render() {
    super.render();
    let { tagContainer: e, tagMenu: t, tagInput: i } = this.parts;
    if (t.disabled = this.disabled, i.value = "", i.setAttribute("placeholder", this.placeholder), this.editable && !this.disabled)
      t.toggleAttribute("hidden", false), i.toggleAttribute("hidden", !this.textEntry);
    else
      t.toggleAttribute("hidden", true), i.toggleAttribute("hidden", true);
    e.textContent = "";
    let { tags: o } = this;
    for (let s of o)
      e.append(Qs({ caption: s, removeable: this.editable && !this.disabled, removeCallback: this.removeTag }));
  }
}
var Na = Mi.elementCreator({ tag: "xin-tag-list", styleSpec: { ":host": { "--tag-list-bg": "#f8f8f8", "--touch-size": "44px", "--spacing": "16px", display: "grid", gridTemplateColumns: "auto", alignItems: "center", background: On.tagListBg, gap: On.spacing25, borderRadius: sn.taglistRoundedRadius(On.spacing50), overflow: "hidden" }, ":host[editable]": { gridTemplateColumns: `0px auto ${On.touchSize}` }, ":host[editable][text-entry]": { gridTemplateColumns: `0px 2fr 1fr ${On.touchSize}` }, ':host [part="tagContainer"]': { display: "flex", content: '" "', alignItems: "center", background: On.inputBg, borderRadius: sn.tagContainerRadius(On.spacing50), boxShadow: On.borderShadow, flexWrap: "nowrap", overflow: "auto hidden", gap: On.spacing25, minHeight: `calc(${On.lineHeight} + ${On.spacing})`, padding: On.spacing25 }, ':host [part="tagMenu"]': { width: On.touchSize, height: On.touchSize, lineHeight: On.touchSize, textAlign: "center", padding: 0, margin: 0 }, ":host [hidden]": { display: "none !important" }, ':host button[part="tagMenu"]': { background: On.brandColor, color: On.brandTextColor } } });

// demo/src/index.tsx
var jsx_dev_runtime2 = __toESM(require_jsx_dev_runtime(), 1);
var container = document.querySelector("main");
var BodyMovin = reactWebComponents.xinLottie;
var Markdown = reactWebComponents.xinMd;
var root = import_client.default.createRoot(container);
root.render(/* @__PURE__ */ jsx_dev_runtime2.jsxDEV(jsx_dev_runtime2.Fragment, {
  children: /* @__PURE__ */ jsx_dev_runtime2.jsxDEV("div", {
    className: "column",
    children: [
      /* @__PURE__ */ jsx_dev_runtime2.jsxDEV("div", {
        className: "parallax sky"
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime2.jsxDEV("div", {
        className: "parallax far"
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime2.jsxDEV("div", {
        className: "parallax medium"
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime2.jsxDEV("div", {
        className: "parallax near"
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(BodyMovin, {
        style: {
          width: "300px",
          height: "300px",
          marginBottom: "-65px",
          zIndex: "1"
        },
        src: "/tosi.json"
      }, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(todo_default, {}, undefined, false, undefined, this),
      /* @__PURE__ */ jsx_dev_runtime2.jsxDEV(Markdown, {
        class: "doc",
        src: "/use-tosi.md"
      }, undefined, false, undefined, this)
    ]
  }, undefined, true, undefined, this)
}, undefined, false, undefined, this));
