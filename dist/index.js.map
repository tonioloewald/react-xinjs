{
  "version": 3,
  "sources": ["../src/use-tosi.ts", "../src/version.ts"],
  "sourcesContent": [
    "import React, {\n  useState,\n  useEffect,\n  createElement,\n  FunctionComponent,\n  ComponentPropsWithRef,\n} from \"react\";\nimport { xin, observe, unobserve, xinPath, XinTouchableType } from \"tosijs\";\n\ntype HookType<T = any> = [value: T, setValue: (newValue: T) => void];\n\n// TODO declare type the way it's declared for useState so that TypeScript\n// passes through type of initialValue to the right thing\n\nexport const useTosi = function <T = any>(\n  observed: XinTouchableType,\n  initialValue: T,\n): HookType<T> {\n  const path = typeof observed === \"string\" ? observed : xinPath(observed);\n  if (typeof path !== \"string\") {\n    console.error(\n      \"useXin must either be passed a path or a XinProxy\",\n      observed,\n    );\n    throw new Error(\"useXin must either be passed a path or a XinProxy\");\n  }\n  const [value, update] = useState(\n    xin[path] !== undefined ? xin[path] : initialValue,\n  );\n  useEffect(() => {\n    const observer = (): void => {\n      update(xin[path]);\n    };\n    const listener = observe(path, observer);\n    return () => {\n      unobserve(listener);\n    };\n  });\n  const setValue = (value: any): void => {\n    xin[path] = value;\n  };\n  return [value, setValue];\n};\n\nexport const useXin = useTosi;\n\nexport type WebComponent<\n  P extends object = {},\n  E extends HTMLElement = HTMLElement,\n> = FunctionComponent<\n  ComponentPropsWithRef<\"div\"> & P & { ref?: React.Ref<E> }\n>;\n\ntype WebComponentProxy = Record<string, WebComponent>;\n\nexport const reactWebComponents: WebComponentProxy = new Proxy(\n  {} as WebComponentProxy,\n  {\n    get(target, key): WebComponent {\n      if (typeof key !== \"string\") {\n        return (target as any)[key];\n      }\n\n      const tagName = key.replace(\n        /([a-z])([A-Z])/g,\n        (_: string, first: string, last: string): string => {\n          return first + \"-\" + last.toLocaleLowerCase();\n        },\n      );\n\n      if (!target[tagName]) {\n        target[tagName] = (props: any) =>\n          createElement<any, Element>(tagName, props);\n      }\n\n      return target[tagName];\n    },\n  },\n);\n",
    "export const version = '1.0.2'"
  ],
  "mappings": ";AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAOO,IAAM,UAAU,QAAkB,CACvC,UACA,cACa;AAAA,EACb,MAAM,OAAO,OAAO,aAAa,WAAW,WAAW,QAAQ,QAAQ;AAAA,EACvE,IAAI,OAAO,SAAS,UAAU;AAAA,IAC5B,QAAQ,MACN,qDACA,QACF;AAAA,IACA,MAAM,IAAI,MAAM,mDAAmD;AAAA,EACrE;AAAA,EACA,OAAO,OAAO,UAAU,SACtB,IAAI,UAAU,YAAY,IAAI,QAAQ,YACxC;AAAA,EACA,UAAU,MAAM;AAAA,IACd,MAAM,WAAW,MAAY;AAAA,MAC3B,OAAO,IAAI,KAAK;AAAA;AAAA,IAElB,MAAM,WAAW,QAAQ,MAAM,QAAQ;AAAA,IACvC,OAAO,MAAM;AAAA,MACX,UAAU,QAAQ;AAAA;AAAA,GAErB;AAAA,EACD,MAAM,WAAW,CAAC,WAAqB;AAAA,IACrC,IAAI,QAAQ;AAAA;AAAA,EAEd,OAAO,CAAC,OAAO,QAAQ;AAAA;AAGlB,IAAM,SAAS;AAWf,IAAM,qBAAwC,IAAI,MACvD,CAAC,GACD;AAAA,EACE,GAAG,CAAC,QAAQ,KAAmB;AAAA,IAC7B,IAAI,OAAO,QAAQ,UAAU;AAAA,MAC3B,OAAQ,OAAe;AAAA,IACzB;AAAA,IAEA,MAAM,UAAU,IAAI,QAClB,mBACA,CAAC,GAAW,OAAe,SAAyB;AAAA,MAClD,OAAO,QAAQ,MAAM,KAAK,kBAAkB;AAAA,KAEhD;AAAA,IAEA,IAAI,CAAC,OAAO,UAAU;AAAA,MACpB,OAAO,WAAW,CAAC,UACjB,cAA4B,SAAS,KAAK;AAAA,IAC9C;AAAA,IAEA,OAAO,OAAO;AAAA;AAElB,CACF;;AC9EO,IAAM,UAAU;",
  "debugId": "CBD1B1F7DB72F54B64756E2164756E21",
  "names": []
}